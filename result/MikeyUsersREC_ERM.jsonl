{"repo_info": {"repo_name": "ERM", "repo_owner": "MikeyUsersREC", "repo_url": "https://github.com/MikeyUsersREC/ERM"}}
{"type": "test_file", "path": "test_erm.py", "content": "import unittest\r\nfrom typing import Union\r\nfrom unittest.mock import MagicMock\r\n\r\nfrom discord import DMChannel\r\nfrom discord.ext.commands import CheckFailure, Context, NoPrivateMessage, has_any_role\r\n\r\nfrom helpers import MockContext, MockRole\r\n\r\n\r\nasync def has_any_role_check(ctx: Context, *roles: Union[str, int]) -> bool:\r\n    \"\"\"\r\n    Returns True if the context's author has any of the specified roles.\r\n    `roles` are the names or IDs of the roles for which to check.\r\n    False is always returns if the context is outside a guild.\r\n    \"\"\"\r\n    try:\r\n        return await has_any_role(*roles).predicate(ctx)\r\n    except CheckFailure:\r\n        return False\r\n\r\n\r\nasync def has_no_roles_check(ctx: Context, *roles: Union[str, int]) -> bool:\r\n    \"\"\"\r\n    Returns True if the context's author doesn't have any of the specified roles.\r\n    `roles` are the names or IDs of the roles for which to check.\r\n    False is always returns if the context is outside a guild.\r\n    \"\"\"\r\n    try:\r\n        return not await has_any_role(*roles).predicate(ctx)\r\n    except NoPrivateMessage:\r\n        return False\r\n    except CheckFailure:\r\n        return True\r\n\r\n\r\nclass ChecksTests(unittest.IsolatedAsyncioTestCase):\r\n    \"\"\"Tests the check functions defined in `bot.checks`.\"\"\"\r\n\r\n    def setUp(self):\r\n        self.ctx = MockContext()\r\n\r\n    async def test_has_any_role_check_without_guild(self):\r\n        \"\"\"`has_any_role_check` returns `False` for non-guild channels.\"\"\"\r\n        self.ctx.channel = MagicMock(DMChannel)\r\n        self.assertFalse(await has_any_role_check(self.ctx))\r\n\r\n    async def test_has_any_role_check_without_required_roles(self):\r\n        \"\"\"`has_any_role_check` returns `False` if `Context.author` lacks the required role.\"\"\"\r\n        self.ctx.author.roles = []\r\n        self.assertFalse(await has_any_role_check(self.ctx))\r\n\r\n    async def test_has_any_role_check_with_guild_and_required_role(self):\r\n        \"\"\"`has_any_role_check` returns `True` if `Context.author` has the required role.\"\"\"\r\n        self.ctx.author.roles.append(MockRole(id=10))\r\n        self.assertTrue(await has_any_role_check(self.ctx, 10))\r\n\r\n    async def test_has_no_roles_check_without_guild(self):\r\n        \"\"\"`has_no_roles_check` should return `False` when `Context.guild` is None.\"\"\"\r\n        self.ctx.channel = MagicMock(DMChannel)\r\n        self.ctx.guild = None\r\n        self.assertFalse(await has_no_roles_check(self.ctx))\r\n"}
{"type": "source_file", "path": "cogs/ActivityMonitoring.py", "content": "import datetime\n\nimport discord\nimport pytz\nfrom discord import app_commands\nfrom discord.ext import commands\nimport typing\nfrom menus import CustomExecutionButton\nfrom utils.constants import BLANK_COLOR, GREEN_COLOR, RED_COLOR\nfrom erm import is_management\nfrom utils.paginators import SelectPagination, CustomPage\nfrom utils.timestamp import td_format\nfrom utils.utils import (\n    require_settings,\n    time_converter,\n    get_elapsed_time,\n    generalised_interaction_check_failure,\n)\n\n\nclass ActivityMonitoring(commands.Cog):\n    def __init__(self, bot: commands.Bot):\n        self.bot = bot\n\n    @commands.hybrid_group(\n        name=\"activity\",\n        description=\"Monitor activity across an entire Staff Team effectively.\",\n        extras={\"category\": \"Activity Management\"},\n    )\n    async def activity(self, ctx: commands.Context):\n        pass\n\n    @commands.guild_only()\n    @activity.command(\n        name=\"show\",\n        description=\"Show newest activity monitoring report across a time period.\",\n        extras={\"category\": \"Activity Management\"},\n    )\n    @is_management()\n    @require_settings()\n    async def activity_show(\n        self,\n        ctx: commands.Context,\n        duration: str,\n        selected_role: typing.Optional[discord.Role],\n    ):\n\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\n        if not settings.get(\"shift_management\").get(\"enabled\"):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Enabled\",\n                    description=\"Shift Logging is not enabled on this server.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        try:\n            actual_conversion = time_converter(duration)\n        except ValueError:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Invalid Time\",\n                    description=\"This time format is not accepted by ERM. Please seek the documentation for details\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        timestamp_pre = (\n            datetime.datetime.now(tz=pytz.UTC).timestamp() - actual_conversion\n        )\n        timestamp_now = datetime.datetime.now(tz=pytz.UTC).timestamp()\n\n        all_staff = {}\n        specified_quota_roles = settings.get(\"shift_management\", {}).get(\n            \"role_quotas\", []\n        )\n\n        async for shift_document in self.bot.shift_management.shifts.db.find(\n            {\n                \"Guild\": ctx.guild.id,\n                \"StartEpoch\": {\"$gt\": timestamp_pre},\n                \"EndEpoch\": {\"$lt\": timestamp_now},\n            }\n        ):\n\n            shift_time = get_elapsed_time(shift_document)\n            if shift_time > 100_000_000:\n                continue\n            if shift_document[\"UserID\"] not in all_staff.keys():\n                try:\n                    member = await ctx.guild.fetch_member(shift_document[\"UserID\"])\n                except discord.NotFound:\n                    continue\n                if not member:\n                    continue\n                roles = member.roles\n                if selected_role is not None:\n                    if selected_role not in roles:\n                        continue\n                sorted_roles = sorted(member.roles, key=lambda x: x.position)\n                selected_quota = 0\n                for role in sorted_roles:\n                    # print(role)\n                    # print(specified_quota_roles)\n                    if role.id in [t[\"role\"] for t in specified_quota_roles]:\n                        found_item = [\n                            t for t in specified_quota_roles if t[\"role\"] == role.id\n                        ][0]\n                        selected_quota = found_item[\"quota\"]\n\n                if selected_quota == 0:\n                    selected_quota = settings.get(\"shift_management\").get(\"quota\", 0)\n                all_staff[shift_document[\"UserID\"]] = [shift_time, selected_quota]\n            else:\n                all_staff[shift_document[\"UserID\"]][0] += shift_time\n\n        if selected_role is not None:\n            for item in selected_role.members:\n                if item.id not in all_staff.keys():\n                    all_staff[item.id] = [\n                        0,\n                        settings.get(\"shift_management\").get(\"quota\", 0),\n                    ]\n\n        sorted_all_staff = sorted(all_staff.items(), key=lambda x: x[1], reverse=True)\n        # print(sorted_all_staff)\n        sorted_staff = dict(\n            zip(\n                [item[0] for item in sorted_all_staff],\n                [item[1] for item in sorted_all_staff],\n            )\n        )\n        # print(sorted_staff)\n        leaderboard_string = \"\"\n        loa_string = \"\"\n\n        for index, (user_id, (seconds, quota)) in enumerate(sorted_staff.items()):\n            # print(seconds, quota)\n            leaderboard_string += f\"**{index+1}.** <@{user_id}> • {td_format(datetime.timedelta(seconds=seconds))} {self.bot.emoji_controller.get_emoji('success') if seconds > quota else self.bot.emoji_controller.get_emoji('xmark')}\\n\"\n            if index == len(sorted_staff) - 1:\n                break\n        else:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"No Data\",\n                    description=\"There is no data to show for this period.\",\n                    color=BLANK_COLOR,\n                )\n            )\n        embeds = []\n        embed = discord.Embed(title=f\"Activity Report ({duration})\", color=BLANK_COLOR)\n        embed.description = f\"**Leaderboard**\\n\"\n        embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n        embeds.append(embed)\n        for item in leaderboard_string.split(\"\\n\"):\n            if len(embeds[-1].description.splitlines()) > 9:\n                embed = discord.Embed(\n                    title=f\"Activity Report ({duration})\", color=BLANK_COLOR\n                )\n                embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n                embeds.append(embed)\n                embeds[-1].description = f\"**Leaderboard**\\n\"\n            embeds[-1].description += f\"{item}\\n\"\n\n        actual_loas = []\n        async for loa_item in self.bot.loas.db.find({\"guild_id\": ctx.guild.id}):\n            starting_epoch = loa_item[\"_id\"].split(\"_\")[2]\n            if int(starting_epoch) >= timestamp_pre and loa_item.get(\"accepted\", True):\n                loa_item[\"start_epoch\"] = int(starting_epoch)\n                actual_loas.append(loa_item)\n\n        async def interaction_callback(interaction: discord.Interaction, _):\n            if interaction.user.id != ctx.author.id:\n                return await generalised_interaction_check_failure(interaction.response)\n\n            def setup_embed() -> discord.Embed:\n                embed = discord.Embed(title=\"Activity Notices\", color=BLANK_COLOR)\n                embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n                return embed\n\n            embeds = []\n            for item in actual_loas:\n                if len(embeds) == 0:\n                    embeds.append(setup_embed())\n\n                if len(embeds[-1].fields) > 4:\n                    embeds.append(setup_embed())\n\n                find_shift_staff = all_staff.get(item[\"user_id\"])\n\n                if find_shift_staff:\n                    embeds[-1].add_field(\n                        name=f\"{item['type']}\",\n                        value=(\n                            f\"> **Staff:** <@{item['user_id']}>\\n\"\n                            f\"> **Reason:** {item['reason']}\\n\"\n                            f\"> **Shift Time:** {td_format(datetime.timedelta(seconds=find_shift_staff[0]))} {self.bot.emoji_controller.get_emoji('success') if seconds > find_shift_staff[1] else self.bot.emoji_controller.get_emoji('xmark')}\\n\"\n                            f\"> **Started At:** <t:{int(item['start_epoch'])}>\\n\"\n                            f\"> **Ended At:** <t:{int(item['expiry'])}>\"\n                        ),\n                        inline=False,\n                    )\n                else:\n                    embeds[-1].add_field(\n                        name=f\"{item['type']}\",\n                        value=(\n                            f\"> **Staff:** <@{item['user_id']}>\\n\"\n                            f\"> **Reason:** {item['reason']}\\n\"\n                            f\"> **Shift Time:** {td_format(datetime.timedelta(seconds=0))} {self.bot.emoji_controller.get_emoji('success') if seconds > 0 else self.bot.emoji_controller.get_emoji('xmark')}\\n\"\n                            f\"> **Started At:** <t:{int(item['start_epoch'])}>\\n\"\n                            f\"> **Ended At:** <t:{int(item['expiry'])}>\"\n                        ),\n                        inline=False,\n                    )\n            pages = [\n                CustomPage(embeds=[embed], identifier=str(index + 1))\n                for index, embed in enumerate(embeds)\n            ]\n            paginator = SelectPagination(self.bot, ctx.author.id, pages=pages)\n            await interaction.response.send_message(\n                embed=embeds[0], view=paginator, ephemeral=True\n            )\n\n        button = CustomExecutionButton(\n            ctx.author.id,\n            \"View LOAs\",\n            style=discord.ButtonStyle.secondary,\n            func=interaction_callback,\n        )\n        extra_view = discord.ui.View()\n        if len(actual_loas) != 0:\n            extra_view.add_item(button)\n\n        view = SelectPagination(\n            self.bot,\n            ctx.author.id,\n            [\n                CustomPage(embeds=[embed], view=extra_view, identifier=str(index + 1))\n                for index, embed in enumerate(embeds)\n            ],\n        )\n\n        await ctx.send(\n            embed=embeds[0],\n            view=view.get_current_view() if len(embeds) > 1 else extra_view,\n        )\n\n\nasync def setup(bot):\n    await bot.add_cog(ActivityMonitoring(bot))\n"}
{"type": "source_file", "path": "cogs/CustomCommands.py", "content": "import discord\r\nfrom discord import app_commands\r\nfrom discord.ext import commands\r\n\r\nfrom erm import is_management, is_admin\r\nfrom utils.constants import BLANK_COLOR, GREEN_COLOR\r\nfrom utils.utils import generator\r\nfrom menus import (\r\n    ChannelSelect,\r\n    CustomModalView,\r\n    CustomSelectMenu,\r\n    EmbedCustomisation,\r\n    MessageCustomisation,\r\n    RemoveCustomCommand,\r\n    YesNoColourMenu,\r\n    CustomCommandOptionSelect,\r\n    CustomCommandModification,\r\n    CounterButton,\r\n    ViewVotersButton,\r\n)\r\nfrom utils.autocompletes import command_autocomplete\r\nfrom utils.utils import (\r\n    interpret_content,\r\n    interpret_embed,\r\n    invis_embed,\r\n    request_response,\r\n    log_command_usage,\r\n)\r\n\r\n\r\nclass CustomCommands(commands.Cog):\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n\r\n    @commands.hybrid_group(name=\"custom\")\r\n    @is_admin()\r\n    async def custom(self, ctx):\r\n        pass\r\n\r\n    @commands.guild_only()\r\n    @custom.command(\r\n        name=\"manage\",\r\n        description=\"Manage your custom commands.\",\r\n        extras={\"category\": \"Custom Commands\"},\r\n    )\r\n    @is_admin()\r\n    async def custom_manage(self, ctx):\r\n        bot = self.bot\r\n        Data = await bot.custom_commands.find_by_id(ctx.guild.id)\r\n        await log_command_usage(self.bot, ctx.guild, ctx.author, f\"Custom Manage\")\r\n        if Data is None:\r\n            Data = {\"_id\": ctx.guild.id, \"commands\": []}\r\n\r\n        embeds = []\r\n        current_embed = (\r\n            discord.Embed(title=\"Custom Commands\", color=BLANK_COLOR)\r\n            .set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n            .set_thumbnail(url=ctx.guild.icon)\r\n        )\r\n\r\n        for item in Data[\"commands\"]:\r\n            if len(current_embed.fields) >= 10:\r\n                embeds.append(current_embed)\r\n                current_embed = discord.Embed(\r\n                    title=\"Custom Commands (cont.)\", color=BLANK_COLOR\r\n                )\r\n\r\n            current_embed.add_field(\r\n                name=f\"{item['name']}\",\r\n                value=f\"> **Name:** {item['name']}\\n\"\r\n                f\"> **Command ID:** `{item['id']}`\\n\"\r\n                f\"> **Creator:** {'<@{}>'.format(item.get('author') if item.get('author') is not None else '1')}\\n\"\r\n                f\"> **Default Channel:** {'<#{}>'.format(item.get('channel')) if item.get('channel') is not None else 'None selected'}\",\r\n                inline=False,\r\n            )\r\n\r\n        if len(current_embed.fields) == 0:\r\n            current_embed.add_field(\r\n                name=\"No Custom Commands\",\r\n                value=f\"> No Custom Commands were found to be associated with this server.\",\r\n            )\r\n\r\n        embeds.append(current_embed)\r\n\r\n        view = CustomCommandOptionSelect(ctx.author.id)\r\n\r\n        new_msg = await ctx.reply(\r\n            embeds=embeds,\r\n            view=view,\r\n        )\r\n\r\n        timeout = await view.wait()\r\n        if timeout:\r\n            return\r\n\r\n        if view.value == \"create\":\r\n            name = view.modal.name.value\r\n            data = {\r\n                \"name\": name,\r\n                \"id\": next(generator),\r\n                \"message\": None,\r\n                \"author\": ctx.author.id,\r\n            }\r\n            view = CustomCommandModification(ctx.author.id, data)\r\n            # timeout = await view.wait()\r\n            # if timeout:\r\n            #     return\r\n            await new_msg.edit(\r\n                view=view,\r\n                embed=discord.Embed(\r\n                    title=\"Custom Commands\",\r\n                    description=(\r\n                        \"**Command Information**\\n\"\r\n                        f\"> **Command ID:** `{data['id']}`\\n\"\r\n                        f\"> **Command Name:** {data['name']}\\n\"\r\n                        f\"> **Creator:** <@{data.get('author', '0')}>\\n\"  # this is just to be sure that author actually exists!\r\n                        f\"> **Default Channel:** {'<#{}>'.format(data.get('channel')) if data.get('channel') is not None else 'None selected'}\\n\"\r\n                        f\"\\n**Message:**\\n\"\r\n                        f\"View the message below by clicking 'View Message'.\"\r\n                    ),\r\n                    color=BLANK_COLOR,\r\n                ),\r\n            )\r\n            await view.wait()\r\n            data = view.command_data\r\n\r\n            for item in Data[\"commands\"]:\r\n                if item[\"name\"] == name:\r\n                    return await ctx.reply(\r\n                        embed=discord.Embed(\r\n                            title=\"Command Mismatch\",\r\n                            description=\"This custom command already exists.\",\r\n                            color=BLANK_COLOR,\r\n                        )\r\n                    )\r\n\r\n            custom_command_data = {\r\n                \"_id\": ctx.guild.id,\r\n                \"commands\": [data],\r\n            }\r\n\r\n            if Data:\r\n                Data[\"commands\"].append(data)\r\n            else:\r\n                Data = custom_command_data\r\n\r\n            await bot.custom_commands.upsert(Data)\r\n            await new_msg.edit(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Command Created\",\r\n                    description=\"This custom command has been successfully created\",\r\n                    color=GREEN_COLOR,\r\n                ),\r\n                view=None,\r\n            )\r\n        elif view.value == \"edit\":\r\n            try:\r\n                id_var = int(view.modal.id.value)\r\n            except ValueError:\r\n                return await new_msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Invalid Format\",\r\n                        description=\"A Custom Command ID may only contain numbers, not letters.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    view=None,\r\n                )\r\n            command_id = None\r\n            existing_command_data = None\r\n            for item in Data[\"commands\"]:\r\n                if item[\"id\"] == id_var:\r\n                    command_id = item[\"id\"]\r\n                    existing_command_data = item\r\n                    break\r\n\r\n            if command_id is None:\r\n                await new_msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Command Mismatch\",\r\n                        description=\"This custom command doesn't exist.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    view=None,\r\n                )\r\n                return\r\n\r\n            if existing_command_data is None:\r\n                await new_msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Command Mismatch\",\r\n                        description=\"This custom command doesn't exist.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    view=None,\r\n                )\r\n                return\r\n\r\n            data = {}\r\n            try:\r\n                data = existing_command_data\r\n            except KeyError:\r\n                await new_msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Command Mismatch\",\r\n                        description=\"This custom command doesn't exist.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                return\r\n            view = CustomCommandModification(ctx.author.id, data)\r\n            await new_msg.edit(\r\n                view=view,\r\n                embed=discord.Embed(\r\n                    title=\"Custom Commands\",\r\n                    description=(\r\n                        \"**Command Information**\\n\"\r\n                        f\"> **Command ID:** `{data['id']}`\\n\"\r\n                        f\"> **Command Name:** {data['name']}\\n\"\r\n                        f\"> **Creator:** <@{data['author']}>\\n\"\r\n                        f\"> **Default Channel:** {'<#{}>'.format(data.get('channel')) if data.get('channel') is not None else 'None selected'}\\n\"\r\n                        f\"\\n**Message:**\\n\"\r\n                        f\"View the message below by clicking 'View Message'.\"\r\n                    ),\r\n                    color=BLANK_COLOR,\r\n                ),\r\n            )\r\n            await view.wait()\r\n            data = view.command_data\r\n            for index, item in enumerate(Data[\"commands\"]):\r\n                if item[\"id\"] == command_id:\r\n                    Data[\"commands\"][index] = data\r\n                    break\r\n            await bot.custom_commands.upsert(Data)\r\n            return await new_msg.edit(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Command Edited\",\r\n                    description=\"This custom command has been successfully edited\",\r\n                    color=GREEN_COLOR,\r\n                ),\r\n                view=None,\r\n            )\r\n        elif view.value == \"delete\":\r\n            identifier = view.modal.name.value\r\n\r\n            for index, item in enumerate(Data[\"commands\"]):\r\n                if str(item[\"name\"]).strip() == str(identifier).strip():\r\n                    Data[\"commands\"].pop(index)\r\n                    await bot.custom_commands.update_by_id(Data)\r\n                    break\r\n            else:\r\n                return await new_msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Command Mismatch\",\r\n                        description=\"This custom command doesn't exist.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    view=None,\r\n                )\r\n\r\n            return await new_msg.edit(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Deleted Command\",\r\n                    description=\"This custom command has been successfully deleted\",\r\n                    color=GREEN_COLOR,\r\n                ),\r\n                view=None,\r\n            )\r\n\r\n    @custom.command(\r\n        name=\"run\",\r\n        description=\"Run a custom command.\",\r\n        extras={\"category\": \"Custom Commands\", \"ephemeral\": True},\r\n    )\r\n    @app_commands.autocomplete(command=command_autocomplete)\r\n    @is_admin()\r\n    @app_commands.describe(command=\"What custom command would you like to run?\")\r\n    @app_commands.describe(\r\n        channel=\"Where do you want this custom command's output to go? (e.g. #general)\"\r\n    )\r\n    async def run(self, ctx, command: str, channel: discord.TextChannel = None):\r\n        bot = self.bot\r\n        Data = await bot.custom_commands.find_by_id(ctx.guild.id)\r\n        if Data is None:\r\n            return await ctx.reply(\r\n                embed=discord.Embed(\r\n                    title=\"No Commands\",\r\n                    description=\"There are no custom commands in this server.\",\r\n                )\r\n            )\r\n\r\n        is_command = False\r\n        selected = None\r\n        if isinstance(Data.get(\"commands\"), list):\r\n            for cmd in Data[\"commands\"]:\r\n                if cmd[\"name\"].lower().replace(\" \", \"\") == command.lower().replace(\r\n                    \" \", \"\"\r\n                ):\r\n                    is_command = True\r\n                    selected = cmd\r\n\r\n        if not is_command:\r\n            return await ctx.reply(\r\n                embed=discord.Embed(\r\n                    title=\"Command Mismatch\",\r\n                    description=\"This custom command doesn't exist.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        if selected.get(\"channel\") and channel is None:\r\n            try:\r\n                channel = await ctx.guild.fetch_channel(selected[\"channel\"])\r\n            except discord.HTTPException:\r\n                channel = None\r\n\r\n            if channel is None:  # Channel doesn't exist\r\n                channel = ctx.channel\r\n        elif channel is None:\r\n            channel = ctx.channel\r\n\r\n        embeds = []\r\n        if selected[\"message\"][\"embeds\"] is not None:\r\n            for embed in selected[\"message\"][\"embeds\"]:\r\n                embeds.append(\r\n                    await interpret_embed(bot, ctx, channel, embed, selected[\"id\"])\r\n                )\r\n        elif selected[\"message\"][\"embeds\"] is None:\r\n            pass\r\n\r\n        view = discord.ui.View()\r\n        for item in selected.get(\"buttons\", []):\r\n            if item[\"label\"] == \"0\" and \"row\" in item:\r\n                counter_button = CounterButton(row=item[\"row\"])\r\n                view_voters_button = ViewVotersButton(\r\n                    row=item[\"row\"], counter_button=counter_button\r\n                )\r\n                view.add_item(counter_button)\r\n                view.add_item(view_voters_button)\r\n            else:\r\n                view.add_item(\r\n                    discord.ui.Button(\r\n                        label=item[\"label\"],\r\n                        url=item[\"url\"],\r\n                        row=item[\"row\"],\r\n                        style=discord.ButtonStyle.url,\r\n                    )\r\n                )\r\n\r\n        if ctx.interaction:\r\n            if (\r\n                selected[\"message\"][\"content\"] in [None, \"\"]\r\n                and len(selected[\"message\"][\"embeds\"]) == 0\r\n            ):\r\n                return await ctx.interaction.followup.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Empty Command\",\r\n                        description=\"Due to Discord limitations, I am unable to send your reminder. Your message is most likely empty.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n            await ctx.interaction.followup.send(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Command Ran\",\r\n                    description=f\"I've just ran the custom command in {channel.mention}.\",\r\n                    color=GREEN_COLOR,\r\n                )\r\n            )\r\n            msg = await channel.send(\r\n                content=await interpret_content(\r\n                    bot, ctx, channel, selected[\"message\"][\"content\"], selected[\"id\"]\r\n                ),\r\n                embeds=embeds,\r\n                view=view,\r\n                allowed_mentions=discord.AllowedMentions(\r\n                    everyone=True, users=True, roles=True, replied_user=True\r\n                ),\r\n            )\r\n\r\n            # Fetch ICS entry\r\n            doc = await bot.ics.find_by_id(selected[\"id\"]) or {}\r\n            if doc is None:\r\n                return\r\n            doc[\"associated_messages\"] = (\r\n                [(channel.id, msg.id)]\r\n                if not doc.get(\"associated_messages\")\r\n                else doc[\"associated_messages\"] + [(channel.id, msg.id)]\r\n            )\r\n            doc[\"_id\"] = [ctx.guild.id]\r\n            await bot.ics.update_by_id(doc)\r\n        else:\r\n            if (\r\n                selected[\"message\"][\"content\"] in [None, \"\"]\r\n                and len(selected[\"message\"][\"embeds\"]) == 0\r\n            ):\r\n                return await ctx.reply(\r\n                    embed=discord.Embed(\r\n                        title=\"Empty Command\",\r\n                        description=\"Due to Discord limitations, I am unable to send your reminder. Your message is most likely empty.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n            await ctx.reply(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Command Ran\",\r\n                    description=f\"I've just ran the custom command in {channel.mention}.\",\r\n                    color=GREEN_COLOR,\r\n                )\r\n            )\r\n\r\n            msg = await channel.send(\r\n                content=await interpret_content(\r\n                    bot, ctx, channel, selected[\"message\"][\"content\"], selected[\"id\"]\r\n                ),\r\n                embeds=embeds,\r\n                view=view,\r\n                allowed_mentions=discord.AllowedMentions(\r\n                    everyone=True, users=True, roles=True, replied_user=True\r\n                ),\r\n            )\r\n\r\n            # Fetch ICS entry\r\n            doc = await bot.ics.find_by_id(selected[\"id\"]) or {}\r\n            if doc is None:\r\n                return\r\n            doc[\"associated_messages\"] = (\r\n                [(channel.id, msg.id)]\r\n                if not doc.get(\"associated_messages\")\r\n                else doc[\"associated_messages\"] + [(channel.id, msg.id)]\r\n            )\r\n            doc[\"_id\"] = doc.get(\"_id\") or selected[\"id\"]\r\n            await bot.ics.update_by_id(doc)\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(CustomCommands(bot))\r\n"}
{"type": "source_file", "path": "cogs/ERLC.py", "content": "import asyncio\nimport datetime\nimport json\nimport re\nimport discord\nimport roblox\nfrom discord.ext import commands\nfrom utils.autocompletes import erlc_players_autocomplete\nfrom roblox.thumbnails import AvatarThumbnailType  # Add this import\n\nimport logging\nfrom typing import List\nfrom erm import is_staff, is_management\nfrom utils.paginators import CustomPage, SelectPagination\nfrom menus import ReloadView, RefreshConfirmation, RiskyUsersMenu\nimport copy\nfrom utils.constants import *\nfrom utils.prc_api import (\n    Player,\n    ServerStatus,\n    KillLog,\n    JoinLeaveLog,\n    CommandLog,\n    ResponseFailure,\n)\nimport utils.prc_api as prc_api\nfrom utils.utils import get_discord_by_roblox, log_command_usage, secure_logging\nfrom discord import app_commands\nimport typing\n\n\nclass ERLC(commands.Cog):\n    def __init__(self, bot: commands.Bot):\n        self.bot = bot\n\n    @staticmethod\n    def is_server_linked():\n        async def predicate(ctx: commands.Context):\n            guild_id = ctx.guild.id\n            command_group = ctx.command.full_parent_name\n\n            try:\n                if command_group == \"erlc\":\n                    await ctx.bot.prc_api.get_server_status(guild_id)\n                elif command_group == \"mc\":\n                    await ctx.bot.mc_api.get_server_status(guild_id)\n            except prc_api.ResponseFailure as exc:\n                error = prc_api.ServerLinkNotFound(platform=command_group)\n                try:\n                    error.code = exc.json_data.get(\"code\") or exc.status_code\n                except json.JSONDecodeError:\n                    pass\n                raise error\n            return True\n\n        return commands.check(predicate)\n\n    async def secure_logging(\n        self,\n        guild_id,\n        author_id,\n        interpret_type: typing.Literal[\"Message\", \"Hint\", \"Command\"],\n        command_string: str,\n        attempted: bool = False,\n    ):\n        await secure_logging(\n            self.bot, guild_id, author_id, interpret_type, command_string, attempted\n        )\n\n    @commands.hybrid_group(name=\"erlc\")\n    async def server(self, ctx: commands.Context):\n        pass\n\n    @commands.hybrid_group(name=\"mc\")  # hmmmm...\n    async def mc(self, ctx: commands.Context):\n        pass\n\n    @mc.command(name=\"link\", description=\"Link your Maple County server with ERM!\")\n    @is_management()\n    async def mc_link(self, ctx: commands.Context, *, server_name: str):\n        # get the linked roblox user\n        roblox_id = 0\n        oauth2_user = (\n            await self.bot.oauth2_users.db.find_one({\"discord_id\": ctx.author.id}) or {}\n        )\n        if not oauth2_user.get(\"roblox_id\"):\n            # go to fallback\n            roblox_user = await self.bot.bloxlink.find_roblox(ctx.author.id)\n            if not roblox_user.get(\"robloxID\"):\n                return await ctx.send(\n                    embed=discord.Embed(\n                        title=\"Not Linked\",\n                        description=\"You are not linked to any ROBLOX account.\",\n                        color=BLANK_COLOR,\n                    )\n                )\n            roblox_id = roblox_user[\"robloxID\"]\n        else:\n            roblox_id = oauth2_user[\"roblox_id\"]\n\n        try:\n            server_token = await self.bot.mc_api.authorize(\n                roblox_id, server_name, ctx.guild.id\n            )\n        except prc_api.ResponseFailure:  # yes, this is correct.\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Server Not Found\",\n                    description=\"We could not find a server you own under the server name provided. Make sure you are linked with ERM by running `/link` in any server.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        await ctx.send(\n            embed=discord.Embed(\n                title=f\"{self.bot.emoji_controller.get_emoji('success')} Server Linked\",\n                description=f\"Your server has been linked with the name `{server_name}`.\",\n                color=GREEN_COLOR,\n            )\n        )\n\n    @mc.command(\n        name=\"info\",\n        description=\"Get information about the current players in your Maple County server.\",\n    )\n    @is_server_linked()\n    async def mc_info(self, ctx: commands.Context):\n        guild_id = ctx.guild.id\n\n        async def operate_and_reload_serverinfo(\n            msg: discord.Message | None, guild_id: str\n        ):\n            guild_id = int(guild_id)\n            status: ServerStatus = await self.bot.mc_api.get_server_status(guild_id)\n            players: list[Player] = await self.bot.mc_api.get_server_players(guild_id)\n            client = roblox.Client()\n\n            embed1 = discord.Embed(title=f\"{status.name}\", color=BLANK_COLOR)\n            embed1.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n            embed1.add_field(\n                name=\"Basic Info\",\n                value=(\n                    f\"> **Join Code:** [{status.join_key}](https://www.roblox.com/games/start?placeId=8416011646&launchData=psjoincode%3D{status.join_key}&deep_link_value=roblox%3A%2F%2FplaceId%3D8416011646)\\n\"\n                    f\"> **Current Players:** {status.current_players}/{status.max_players}\\n\"\n                ),\n                inline=False,\n            )\n            embed1.add_field(\n                name=\"Server Ownership\",\n                value=(\n                    f\"> **Owner:** [{(await client.get_user(status.owner_id)).name}](https://roblox.com/users/{status.owner_id}/profile)\\n\"\n                    f\"> **Co-Owners:** {f', '.join([f'[{user.name}](https://roblox.com/users/{user.id}/profile)' for user in await client.get_users(status.co_owner_ids, expand=False)])}\"\n                ),\n                inline=False,\n            )\n\n            embed1.add_field(\n                name=\"Staff Statistics\",\n                value=(\n                    f\"> **Moderators:** {len(list(filter(lambda x: x.permission == 'Server Moderator', players)))}\\n\"\n                    f\"> **Administrators:** {len(list(filter(lambda x: x.permission == 'Server Administrator', players)))}\\n\"\n                    f\"> **Staff In-Game:** {len(list(filter(lambda x: x.permission != 'Normal', players)))}\\n\"\n                    f\"> **Staff Clocked In:** {await self.bot.shift_management.shifts.db.count_documents({'Guild': guild_id, 'EndEpoch': 0})}\"\n                ),\n                inline=False,\n            )\n\n            if msg is None:\n                view = ReloadView(\n                    self.bot,\n                    ctx.author.id,\n                    operate_and_reload_serverinfo,\n                    [None, guild_id],\n                )\n                msg = await ctx.send(embed=embed1, view=view)\n                view.message = msg\n                view.callback_args[0] = msg\n            else:\n                await msg.edit(embed=embed1)\n\n        await operate_and_reload_serverinfo(None, guild_id)\n\n    @mc.command(name=\"logs\", description=\"See the Command Logs of your server.\")\n    @is_staff()\n    @is_server_linked()\n    async def mc_logs(self, ctx: commands.Context):\n        guild_id = ctx.guild.id\n\n        async def operate_and_reload_commandlogs(msg, guild_id: str):\n            guild_id = int(guild_id)\n            # status: ServerStatus = await self.bot.prc_api.get_server_status(guild_id)\n            command_logs: list[CommandLog] = await self.bot.mc_api.fetch_server_logs(\n                guild_id\n            )\n            embed = discord.Embed(\n                color=BLANK_COLOR, title=\"Command Logs\", description=\"\"\n            )\n\n            sorted_logs = sorted(\n                command_logs, key=lambda log: log.timestamp, reverse=True\n            )\n            for log in sorted_logs:\n                if len(embed.description) > 3800:\n                    break\n                embed.description += f\"> [{log.username}](https://roblox.com/users/{log.user_id}/profile) ran the command `{log.command}` • <t:{int(log.timestamp)}:R>\\n\"\n\n            if embed.description in [\"\", \"\\n\"]:\n                embed.description = \"> No player logs found.\"\n\n            embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n\n            if msg is None:\n                view = ReloadView(\n                    self.bot,\n                    ctx.author.id,\n                    operate_and_reload_commandlogs,\n                    [None, guild_id],\n                )\n                msg = await ctx.send(embed=embed, view=view)\n                view.message = msg\n                view.callback_args[0] = msg\n            else:\n                await msg.edit(embed=embed)\n\n        await operate_and_reload_commandlogs(None, guild_id)\n\n    @mc.command(name=\"bans\", description=\"Filter the bans of your server.\")\n    @is_staff()\n    @is_server_linked()\n    async def mc_bans(\n        self,\n        ctx: commands.Context,\n        username: typing.Optional[str],\n        user_id: typing.Optional[int],\n    ):\n        guild_id = ctx.guild.id\n        # status: ServerStatus = await self.bot.prc_api.get_server_status(guild_id)\n        try:\n            bans: list[prc_api.BanItem] = await self.bot.mc_api.fetch_bans(guild_id)\n        except prc_api.ResponseFailure:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"MC API Error\",\n                    description=\"There were no bans, or your API key is incorrect.\",\n                    color=BLANK_COLOR,\n                )\n            )\n        embed = discord.Embed(color=BLANK_COLOR, title=\"Bans\", description=\"\")\n        status = username or user_id\n\n        if not username and user_id:\n            username = \"[PLACEHOLDER]\"\n\n        if not user_id and username:\n            user_id = \"99999\"\n        old_embed = copy.copy(embed)\n        embeds = [embed]\n        for log in bans:\n            if str(username or \"\") in str(log.username).lower() or str(\n                user_id or \"\"\n            ) in str(log.user_id):\n                embed = embeds[-1]\n                if len(embed.description) > 3800:\n                    new = copy.copy(old_embed)\n                    embeds.append(new)\n                embeds[\n                    -1\n                ].description += f\"> [{log.username}:{log.user_id}](https://roblox.com/users/{log.user_id}/profile)\\n\"\n\n        if embeds[0].description in [\"\", \"\\n\"]:\n            embeds[0].description = (\n                \"> This ban was not found.\"\n                if status\n                else \"> Bans were not found in your server.\"\n            )\n\n        embeds[0].set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n\n        if len(embeds) > 1:\n            pages = [\n                CustomPage(embeds=[embeds[i]], identifier=str(i + 1))\n                for i in range(0, len(embeds) - 1)\n            ]\n            paginator = SelectPagination(self.bot, ctx.author.id, pages)\n            await ctx.send(embed=embeds[0], view=paginator.get_current_view())\n            return\n        else:\n            await ctx.send(embed=embed)\n\n    @mc.command(name=\"players\", description=\"See all players in the server.\")\n    @is_server_linked()\n    async def mc_players(\n        self, ctx: commands.Context, filter: typing.Optional[str] = None\n    ):\n        guild_id = int(ctx.guild.id)\n        players: list[Player] = await self.bot.mc_api.get_server_players(guild_id)\n        embed2 = discord.Embed(\n            title=f\"Server Players [{len(players)}]\", color=BLANK_COLOR, description=\"\"\n        )\n        actual_players = []\n        key_maps = {}\n        staff = []\n        for item in players:\n            if item.permission == \"Normal\":\n                actual_players.append(item)\n            else:\n                staff.append(item)\n\n        if filter not in [None, \"\"]:\n            actual_players_copy = []\n            for item in actual_players:\n                if item.username.lower().startswith(filter.lower()):\n                    actual_players_copy.append(item)\n            actual_players = actual_players_copy\n            staff_copy = []\n            for item in staff:\n                if item.username.lower().startswith(filter.lower()):\n                    staff_copy.append(item)\n            staff = staff_copy\n\n        embed2.description += f\"**Server Staff [{len(staff)}]**\\n\" + (\n            \", \".join(\n                [\n                    f\"[{plr.username}](https://roblox.com/users/{plr.id}/profile)\"\n                    for plr in staff\n                ]\n            )\n            or \"> No players in this category.\"\n        )\n\n        embed2.description += f\"\\n\\n**Online Players [{len(actual_players)}]**\\n\" + (\n            \", \".join(\n                [\n                    f\"[{plr.username}](https://roblox.com/users/{plr.id}/profile)\"\n                    for plr in actual_players\n                ]\n            )\n            or \"> No players in this category.\"\n        )\n\n        embed2.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n        if len(embed2.description) > 3999:\n            embed2.description = \"\"\n            embed2.description += f\"**Server Staff [{len(staff)}]**\\n\" + \", \".join(\n                [f\"{plr.username}\" for plr in staff]\n            )\n\n            embed2.description += (\n                f\"\\n\\n**Online Players [{len(actual_players)}]**\\n\"\n                + \", \".join([f\"{plr.username}\" for plr in actual_players])\n            )\n\n        await ctx.send(embed=embed2)\n\n    @server.command(\n        name=\"pm\",\n        description=\"Send a PM to players in your ER:LC server!\",\n        aliases=[\"private\", \"sendpm\", \"send\"],\n    )\n    @app_commands.autocomplete(target=erlc_players_autocomplete)\n    @app_commands.describe(\n        target=\"Who would you like to send this message to?\",\n        message=\"What would you like to send?\",\n    )\n    async def erlc_pm(self, ctx: commands.Context, target: str, *, message: str):\n        guild_id = ctx.guild.id\n        special_selections = [\"moderators\", \"admins\", \"players\", \"staff\"]\n        selected = []\n        if target in special_selections:\n            players = await self.bot.prc_api.get_server_players(guild_id)\n            for item in players:\n                if item.permission == \"Normal\" and target.lower() == \"players\":\n                    selected.append(item.username)\n                elif item.permission != \"Normal\" and target.lower() == \"staff\":\n                    selected.append(item.username)\n                elif (\n                    item.permission == \"Server Moderator\"\n                    and target.lower() == \"moderators\"\n                ):\n                    selected.append(item.username)\n                elif (\n                    item.permission == \"Server Administrator\"\n                    and target.lower() == \"admins\"\n                ):\n                    selected.append(item.username)\n        else:\n            selected = [target]\n\n        command_response = await self.bot.prc_api.run_command(\n            guild_id, f\":pm {','.join(selected)} {message}\"\n        )\n        if command_response[0] == 200:\n            await ctx.send(\n                embed=discord.Embed(\n                    title=\"<:success:1163149118366040106> Successfully Sent\",\n                    description=\"This PM has been sent to the server!\",\n                    color=GREEN_COLOR,\n                )\n            )\n            await self.secure_logging(\n                guild_id, ctx.author.id, \"Private Message\", message\n            )\n        else:\n            await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Executed\",\n                    description=\"This PM has not been sent to the server successfully.\",\n                    color=BLANK_COLOR,\n                )\n            )\n            await self.secure_logging(\n                guild_id, ctx.author.id, \"Private Message\", message\n            )\n\n    @server.command(\n        name=\"message\", description=\"Send a Message to your ER:LC server with ERM!\"\n    )\n    @is_staff()\n    @is_server_linked()\n    async def erlc_message(self, ctx: commands.Context, *, message: str):\n        guild_id = ctx.guild.id\n\n        command_response = await self.bot.prc_api.run_command(guild_id, f\":m {message}\")\n        if command_response[0] == 200:\n            await ctx.send(\n                embed=discord.Embed(\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Successfully Sent\",\n                    description=\"This message has been sent to the server!\",\n                    color=GREEN_COLOR,\n                )\n            )\n            await self.secure_logging(guild_id, ctx.author.id, \"Message\", message)\n        else:\n            await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Executed\",\n                    description=\"This message has not been sent to the server successfully.\",\n                    color=BLANK_COLOR,\n                )\n            )\n            await self.secure_logging(guild_id, ctx.author.id, \"Message\", message)\n\n    @server.command(\n        name=\"hint\", description=\"Send a Hint to your ER:LC server with ERM!\"\n    )\n    @is_staff()\n    @is_server_linked()\n    async def erlc_hint(self, ctx: commands.Context, *, hint: str):\n        guild_id = ctx.guild.id\n\n        await self.secure_logging(guild_id, ctx.author.id, \"Hint\", hint)\n\n        command_response = await self.bot.prc_api.run_command(guild_id, f\":h {hint}\")\n        if command_response[0] == 200:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Successfully Sent\",\n                    description=\"This Hint has been sent to the server!\",\n                    color=GREEN_COLOR,\n                )\n            )\n        else:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Executed\",\n                    description=\"This Hint has not been sent to the server successfully.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n    @server.command(\n        name=\"link\",\n        description=\"Link your ER:LC server with ERM!\",\n        extras={\"ignoreDefer\": True},\n    )\n    @is_management()\n    @app_commands.describe(\n        key=\"Your PRC Server Key - check your server settings for details\"\n    )\n    async def server_link(self, ctx: commands.Context, key: str):\n        await log_command_usage(self.bot, ctx.guild, ctx.author, f\"ER:LC Link\")\n        status: int | ServerStatus = await self.bot.prc_api.send_test_request(key)\n        if isinstance(status, int):\n            await (\n                ctx.send\n                if not ctx.interaction\n                else ctx.interaction.response.send_message\n            )(\n                embed=discord.Embed(\n                    title=\"Incorrect Key\",\n                    description=\"This Server Key is invalid and nonfunctional. Ensure you've entered it correctly.\",\n                    color=BLANK_COLOR,\n                ),\n                ephemeral=True,\n            )\n        else:\n            await self.bot.server_keys.upsert({\"_id\": ctx.guild.id, \"key\": key})\n\n            await (\n                ctx.send\n                if not ctx.interaction\n                else ctx.interaction.response.send_message\n            )(\n                embed=discord.Embed(\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Successfully Changed\",\n                    description=\"I have changed the Server Key successfully. You can now run ER:LC commands on your server.\",\n                    color=GREEN_COLOR,\n                ),\n                ephemeral=True,\n            )\n\n    @server.command(\n        name=\"command\",\n        description='Send a direct command to your ER:LC server, under \"Remote Server Management\"',\n        extras={\"ephemeral\": True},\n    )\n    @app_commands.describe(command=\"The command to send to your ER:LC server\")\n    @is_management()\n    @is_server_linked()\n    async def server_send_command(self, ctx: commands.Context, *, command: str):\n        if command[0] != \":\":\n            command = \":\" + command\n        elevated_privileges = None\n        status: ServerStatus = await self.bot.prc_api.get_server_status(ctx.guild.id)\n        for item in status.co_owner_ids + [status.owner_id]:\n            if int(item) == int(\n                (await self.bot.bloxlink.find_roblox(ctx.author.id) or {}).get(\n                    \"robloxID\"\n                )\n                or 0\n            ):\n                elevated_privileges = True\n                break\n        else:\n            elevated_privileges = False\n\n        if (\n            any([i in command for i in [\":admin\", \":unadmin\"]])\n            and not elevated_privileges\n        ):\n            # REQUIRES ELEVATION\n            if (\n                (await self.bot.settings.find_by_id(ctx.guild.id) or {}).get(\"ERLC\", {})\n                or {}\n            ).get(\"elevation_required\", True):\n                await self.secure_logging(\n                    ctx.guild.id, ctx.author.id, \"Command\", command, True\n                )\n                if ctx.interaction:\n                    await ctx.interaction.followup.send(\n                        embed=discord.Embed(\n                            title=\"Not Authorized\",\n                            description=\"This command is privileged and requires special elevation.\",\n                            color=BLANK_COLOR,\n                        ),\n                        ephemeral=True,\n                    )\n                else:\n                    await ctx.send(\n                        embed=discord.Embed(\n                            title=\"Not Authorized\",\n                            description=\"This command is privileged and requires special elevation.\",\n                            color=BLANK_COLOR,\n                        )\n                    )\n                return\n\n        guild_id = int(ctx.guild.id)\n        command_response = await self.bot.prc_api.run_command(guild_id, command)\n        if command_response[0] == 200:\n            await ctx.send(\n                embed=discord.Embed(\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Successfully Ran\",\n                    description=\"This command should have now been executed in your server.\",\n                    color=GREEN_COLOR,\n                )\n            )\n            await self.secure_logging(\n                int(ctx.guild.id), ctx.author.id, \"Command\", command\n            )\n        else:\n            await ctx.send(\n                embed=discord.Embed(\n                    title=f\"Not Executed ({command_response[0]})\",\n                    description=\"This command has not been sent to the server successfully.\",\n                    color=BLANK_COLOR,\n                )\n            )\n            await self.secure_logging(\n                int(ctx.guild.id), ctx.author.id, \"Command\", command\n            )\n\n    @server.command(\n        name=\"info\",\n        description=\"Get information about the current players in your ER:LC server.\",\n    )\n    @is_server_linked()\n    async def server_info(self, ctx: commands.Context):\n        guild_id = ctx.guild.id\n\n        async def operate_and_reload_serverinfo(\n            msg: discord.Message | None, guild_id: str\n        ):\n            guild_id = int(guild_id)\n            status: ServerStatus = await self.bot.prc_api.get_server_status(guild_id)\n            players: list[Player] = await self.bot.prc_api.get_server_players(guild_id)\n            queue: int = await self.bot.prc_api.get_server_queue(\n                guild_id, minimal=True\n            )  # this only returns the count\n            client = roblox.Client()\n\n            embed1 = discord.Embed(title=f\"{status.name}\", color=BLANK_COLOR)\n            embed1.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n            embed1.add_field(\n                name=\"Basic Info\",\n                value=(\n                    f\"> **Join Code:** [{status.join_key}](https://policeroleplay.community/join/{status.join_key})\\n\"\n                    f\"> **Current Players:** {status.current_players}/{status.max_players}\\n\"\n                    f\"> **Queue:** {queue}\\n\"\n                ),\n                inline=False,\n            )\n            embed1.add_field(\n                name=\"Server Ownership\",\n                value=(\n                    f\"> **Owner:** [{(await client.get_user(status.owner_id)).name}](https://roblox.com/users/{status.owner_id}/profile)\\n\"\n                    f\"> **Co-Owners:** {f', '.join([f'[{user.name}](https://roblox.com/users/{user.id}/profile)' for user in await client.get_users(status.co_owner_ids, expand=False)])}\"\n                ),\n                inline=False,\n            )\n\n            embed1.add_field(\n                name=\"Staff Statistics\",\n                value=(\n                    f\"> **Moderators:** {len(list(filter(lambda x: x.permission == 'Server Moderator', players)))}\\n\"\n                    f\"> **Administrators:** {len(list(filter(lambda x: x.permission == 'Server Administrator', players)))}\\n\"\n                    f\"> **Staff In-Game:** {len(list(filter(lambda x: x.permission != 'Normal', players)))}\\n\"\n                    f\"> **Staff Clocked In:** {await self.bot.shift_management.shifts.db.count_documents({'Guild': guild_id, 'EndEpoch': 0})}\"\n                ),\n                inline=False,\n            )\n\n            if msg is None:\n                view = ReloadView(\n                    self.bot,\n                    ctx.author.id,\n                    operate_and_reload_serverinfo,\n                    [None, guild_id],\n                )\n                msg = await ctx.send(embed=embed1, view=view)\n                view.message = msg\n                view.callback_args[0] = msg\n            else:\n                await msg.edit(embed=embed1)\n\n        await operate_and_reload_serverinfo(None, guild_id)\n\n    @server.command(\n        name=\"staff\", description=\"See the online staff members in your ER:LC server!\"\n    )\n    @is_staff()\n    @is_server_linked()\n    async def server_staff(self, ctx: commands.Context):\n        guild_id = int(ctx.guild.id)\n        status: ServerStatus = await self.bot.prc_api.get_server_status(guild_id)\n        players: list[Player] = await self.bot.prc_api.get_server_players(guild_id)\n        embed2 = discord.Embed(color=BLANK_COLOR)\n        embed2.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n        actual_players = []\n        key_maps = {}\n        for item in players:\n            if item.permission == \"Normal\":\n                actual_players.append(item)\n            else:\n                if item.permission not in key_maps:\n                    key_maps[item.permission] = [item]\n                else:\n                    key_maps[item.permission].append(item)\n\n        new_maps = [\"Server Owners\", \"Server Administrator\", \"Server Moderator\"]\n        new_vals = [\n            key_maps.get(\"Server Owner\", []) + key_maps.get(\"Server Co-Owner\", []),\n            key_maps.get(\"Server Administrator\", []),\n            key_maps.get(\"Server Moderator\", []),\n        ]\n        new_keymap = dict(zip(new_maps, new_vals))\n        embed2.title = f\"Online Staff Members [{sum([len(i) for i in new_vals])}]\"\n        for key, value in new_keymap.items():\n            if value:\n                value_length = len(value)\n                value = \"\\n\".join(\n                    [\n                        f\"[{plr.username}](https://roblox.com/users/{plr.id}/profile)\"\n                        for plr in value\n                    ]\n                )\n                embed2.add_field(\n                    name=f\"{key} [{value_length}]\", value=value, inline=False\n                )\n\n        if len(embed2.fields) == 0:\n            embed2.description = \"> There are no online staff members.\"\n        await ctx.send(embed=embed2)\n\n    @server.command(name=\"kills\", description=\"See the Kill Logs of your server.\")\n    @is_staff()\n    @is_server_linked()\n    async def kills(self, ctx: commands.Context):\n        guild_id = ctx.guild.id\n\n        async def operate_and_reload_kills(msg, guild_id: str):\n            guild_id = int(guild_id)\n            # status: ServerStatus = await self.bot.prc_api.get_server_status(guild_id)\n            kill_logs: list[KillLog] = await self.bot.prc_api.fetch_kill_logs(guild_id)\n            embed = discord.Embed(\n                color=BLANK_COLOR, title=\"Server Kill Logs\", description=\"\"\n            )\n\n            sorted_kill_logs = sorted(\n                kill_logs, key=lambda log: log.timestamp, reverse=True\n            )\n            for log in sorted_kill_logs:\n                if len(embed.description) > 3800:\n                    break\n                embed.description += f\"> [{log.killer_username}](https://roblox.com/users/{log.killer_user_id}/profile) killed [{log.killed_username}](https://roblox.com/users/{log.killed_user_id}/profile) • <t:{int(log.timestamp)}:R>\\n\"\n\n            if embed.description in [\"\", \"\\n\"]:\n                embed.description = \"> No kill logs found.\"\n\n            embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n\n            # embed.set_footer(icon_url=\"https://cdn.discordapp.com/emojis/1176999148084535326.webp?size=128&quality=lossless\",\n            #                   text=\"Last updated 5 seconds ago\")\n            if msg is None:\n                view = ReloadView(\n                    self.bot, ctx.author.id, operate_and_reload_kills, [None, guild_id]\n                )\n                msg = await ctx.send(embed=embed, view=view)\n                view.message = msg\n                view.callback_args[0] = msg\n            else:\n                await msg.edit(embed=embed)\n\n        await operate_and_reload_kills(None, guild_id)\n\n    @server.command(\n        name=\"playerlogs\", description=\"See the Join and Leave logs of your server.\"\n    )\n    @is_staff()\n    @is_server_linked()\n    async def playerlogs(self, ctx: commands.Context):\n        guild_id = ctx.guild.id\n\n        async def operate_and_reload_playerlogs(msg, guild_id: str):\n            guild_id = int(guild_id)\n            # status: ServerStatus = await self.bot.prc_api.get_server_status(guild_id)\n            player_logs: list[JoinLeaveLog] = await self.bot.prc_api.fetch_player_logs(\n                guild_id\n            )\n            embed = discord.Embed(\n                color=BLANK_COLOR, title=\"Player Join/Leave Logs\", description=\"\"\n            )\n\n            sorted_logs = sorted(\n                player_logs, key=lambda log: log.timestamp, reverse=True\n            )\n            for log in sorted_logs:\n                if len(embed.description) > 3800:\n                    break\n                embed.description += f\"> [{log.username}](https://roblox.com/users/{log.user_id}/profile) {'joined the server' if log.type == 'join' else 'left the server'} • <t:{int(log.timestamp)}:R>\\n\"\n\n            if embed.description in [\"\", \"\\n\"]:\n                embed.description = \"> No player logs found.\"\n\n            embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n\n            # embed.set_footer(icon_url=\"https://cdn.discordapp.com/emojis/1176999148084535326.webp?size=128&quality=lossless\",\n            #                   text=\"Last updated 5 seconds ago\")\n            if msg is None:\n                view = ReloadView(\n                    self.bot,\n                    ctx.author.id,\n                    operate_and_reload_playerlogs,\n                    [None, guild_id],\n                )\n                msg = await ctx.send(embed=embed, view=view)\n                view.message = msg\n                view.callback_args[0] = msg\n            else:\n                await msg.edit(embed=embed)\n\n        await operate_and_reload_playerlogs(None, guild_id)\n\n    @server.command(name=\"logs\", description=\"See the Command Logs of your server.\")\n    @is_staff()\n    @is_server_linked()\n    async def commandlogs(self, ctx: commands.Context):\n        guild_id = ctx.guild.id\n\n        async def operate_and_reload_commandlogs(msg, guild_id: str):\n            guild_id = int(guild_id)\n            # status: ServerStatus = await self.bot.prc_api.get_server_status(guild_id)\n            command_logs: list[CommandLog] = await self.bot.prc_api.fetch_server_logs(\n                guild_id\n            )\n            embed = discord.Embed(\n                color=BLANK_COLOR, title=\"Command Logs\", description=\"\"\n            )\n\n            sorted_logs = sorted(\n                command_logs, key=lambda log: log.timestamp, reverse=True\n            )\n            for log in sorted_logs:\n                if len(embed.description) > 3800:\n                    break\n                embed.description += f\"> [{log.username}](https://roblox.com/users/{log.user_id}/profile) ran the command `{log.command}` • <t:{int(log.timestamp)}:R>\\n\"\n\n            if embed.description in [\"\", \"\\n\"]:\n                embed.description = \"> No player logs found.\"\n\n            embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n\n            # embed.set_footer(icon_url=\"https://cdn.discordapp.com/emojis/1176999148084535326.webp?size=128&quality=lossless\",\n            #                   text=\"Last updated 5 seconds ago\")\n            if msg is None:\n                view = ReloadView(\n                    self.bot,\n                    ctx.author.id,\n                    operate_and_reload_commandlogs,\n                    [None, guild_id],\n                )\n                msg = await ctx.send(embed=embed, view=view)\n                view.message = msg\n                view.callback_args[0] = msg\n            else:\n                await msg.edit(embed=embed)\n\n        await operate_and_reload_commandlogs(None, guild_id)\n\n    @server.command(name=\"bans\", description=\"Filter the bans of your server.\")\n    @is_staff()\n    @is_server_linked()\n    async def bans(\n        self,\n        ctx: commands.Context,\n        username: typing.Optional[str],\n        user_id: typing.Optional[int],\n    ):\n        guild_id = ctx.guild.id\n        # status: ServerStatus = await self.bot.prc_api.get_server_status(guild_id)\n        try:\n            bans: list[prc_api.BanItem] = await self.bot.prc_api.fetch_bans(guild_id)\n        except prc_api.ResponseFailure:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"PRC API Error\",\n                    description=\"There were no bans, or your API key is incorrect.\",\n                    color=BLANK_COLOR,\n                )\n            )\n        embed = discord.Embed(color=BLANK_COLOR, title=\"Bans\", description=\"\")\n        status = username or user_id\n\n        if not username and user_id:\n            username = \"[PLACEHOLDER]\"\n\n        if not user_id and username:\n            user_id = \"99999\"\n        old_embed = copy.copy(embed)\n        embeds = [embed]\n        for log in bans:\n            if str(username or \"\") in str(log.username).lower() or str(\n                user_id or \"\"\n            ) in str(log.user_id):\n                embed = embeds[-1]\n                if len(embed.description) > 3800:\n                    new = copy.copy(old_embed)\n                    embeds.append(new)\n                embeds[\n                    -1\n                ].description += f\"> [{log.username}:{log.user_id}](https://roblox.com/users/{log.user_id}/profile)\\n\"\n\n        if embeds[0].description in [\"\", \"\\n\"]:\n            embeds[0].description = (\n                \"> This ban was not found.\"\n                if status\n                else \"> Bans were not found in your server.\"\n            )\n\n        embeds[0].set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n\n        if len(embeds) > 1:\n            pages = [\n                CustomPage(embeds=[embeds[i]], identifier=str(i + 1))\n                for i in range(0, len(embeds) - 1)\n            ]\n            paginator = SelectPagination(self.bot, ctx.author.id, pages)\n            await ctx.send(embed=embeds[0], view=paginator.get_current_view())\n            return\n        else:\n            await ctx.send(embed=embeds[0])\n\n    @server.command(\n        name=\"risk\",\n        description=\"Search for Users with 'all' or 'others' in their username.\"\n    )\n    @is_staff()\n    @is_server_linked()\n    async def risk(self, ctx: commands.Context):\n        msg = await ctx.send(\n            embed=discord.Embed(\n                title=f\"{await self.bot.emoji_controller.get_emoji('Clock')} Checking...\",\n                description=\"This may take a while.\",\n                color=BLANK_COLOR\n            )\n        )\n        guild_id = ctx.guild.id\n        players: list[Player] = await self.bot.prc_api.get_server_players(guild_id)\n\n        if not players:\n            return await msg.edit(\n                embed=discord.Embed(\n                    title=\"No Players Found\",\n                    description=\"There are no players in the server to check.\",\n                    color=BLANK_COLOR\n                )\n            )\n\n        risky_prefixes = ('all', 'others', 'ail', 'ali', 'aii', 'a1i', 'ai1', 'a1l', 'al1')\n        risky_users = [player for player in players if player.username.lower().startswith(risky_prefixes)]\n\n        if not risky_users:\n            return await msg.edit(\n                embed=discord.Embed(\n                    title=\"No Risk Players Found\",\n                    description=\"There are no risk players in the server.\",\n                    color=BLANK_COLOR\n                )\n            )\n\n        embed = discord.Embed(\n            title=\"Users with Risky Usernames\",\n            color=BLANK_COLOR,\n            description=\"\\n\".join(\n                f\"> [{user.username}](https://roblox.com/users/{user.id}/profile)\" for user in risky_users)\n        )\n        embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon if ctx.guild.icon else None)\n        view = RiskyUsersMenu(self.bot, guild_id, risky_users, ctx.author.id)\n        await msg.edit(embed=embed, view=view)\n        \n    @server.command(name=\"players\", description=\"See all players in the server.\")\n    @is_server_linked()\n    async def server_players(\n        self, ctx: commands.Context, filter: typing.Optional[str] = None\n    ):\n        guild_id = int(ctx.guild.id)\n        # status: ServerStatus = await self.bot.prc_api.get_server_status(guild_id)\n        players: list[Player] = await self.bot.prc_api.get_server_players(guild_id)\n        queue: list[Player] = await self.bot.prc_api.get_server_queue(guild_id)\n        embed2 = discord.Embed(\n            title=f\"Server Players [{len(players)}]\", color=BLANK_COLOR, description=\"\"\n        )\n        actual_players = []\n        key_maps = {}\n        staff = []\n        for item in players:\n            if item.permission == \"Normal\":\n                actual_players.append(item)\n            else:\n                staff.append(item)\n\n        if filter not in [None, \"\"]:\n            actual_players_copy = []\n            for item in actual_players:\n                if item.username.lower().startswith(filter.lower()):\n                    actual_players_copy.append(item)\n            actual_players = actual_players_copy\n            staff_copy = []\n            for item in staff:\n                if item.username.lower().startswith(filter.lower()):\n                    staff_copy.append(item)\n            staff = staff_copy\n\n        embed2.description += f\"**Server Staff [{len(staff)}]**\\n\" + (\n            \", \".join(\n                [\n                    f\"[{plr.username} ({plr.team})](https://roblox.com/users/{plr.id}/profile)\"\n                    for plr in staff\n                ]\n            )\n            or \"> No players in this category.\"\n        )\n\n        embed2.description += f\"\\n\\n**Online Players [{len(actual_players)}]**\\n\" + (\n            \", \".join(\n                [\n                    f\"[{plr.username} ({plr.team})](https://roblox.com/users/{plr.id}/profile)\"\n                    for plr in actual_players\n                ]\n            )\n            or \"> No players in this category.\"\n        )\n\n        embed2.description += f\"\\n\\n**Queue [{len(queue)}]**\\n\" + (\n            \", \".join(\n                [\n                    f\"[{plr.username}](https://roblox.com/users/{plr.id}/profile)\"\n                    for plr in queue\n                ]\n            )\n            or \"> No players in this category.\"\n        )\n\n        embed2.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n        if len(embed2.description) > 3999:\n            embed2.description = \"\"\n            embed2.description += f\"**Server Staff [{len(staff)}]**\\n\" + \", \".join(\n                [f\"{plr.username} ({plr.team})\" for plr in staff]\n            )\n\n            embed2.description += (\n                f\"\\n\\n**Online Players [{len(actual_players)}]**\\n\"\n                + \", \".join([f\"{plr.username} ({plr.team})\" for plr in actual_players])\n            )\n\n            embed2.description += f\"\\n\\n**Queue [{len(queue)}]**\\n\" + \", \".join(\n                [f\"{plr.username}\" for plr in queue]\n            )\n\n        await ctx.send(embed=embed2)\n\n    @server.command(\n        name=\"teams\", description=\"See all players in the server, grouped by team.\"\n    )\n    @is_staff()\n    @is_server_linked()\n    async def server_teams(\n        self, ctx: commands.Context, filter: typing.Optional[str] = None\n    ):\n        guild_id = int(ctx.guild.id)\n        players: list[Player] = await self.bot.prc_api.get_server_players(guild_id)\n        embed2 = discord.Embed(\n            title=f\"Server Players by Team [{len(players)}]\",\n            color=BLANK_COLOR,\n            description=\"\",\n        )\n\n        teams = {}\n        for plr in players:\n            if filter and not plr.username.lower().startswith(filter.lower()):\n                continue\n            if plr.team not in teams:\n                teams[plr.team] = []\n            teams[plr.team].append(plr)\n\n        team_order = [\"Police\", \"Sheriff\", \"Fire\", \"DOT\", \"Civilian\"]\n        for team in team_order:\n            team_players = []\n            if team in teams:\n                team_players = teams[team]\n            embed2.description += (\n                f\"**{team} [{len(team_players)}]**\\n\"\n                + \", \".join(\n                    [\n                        f\"[{plr.username}](https://roblox.com/users/{plr.id}/profile)\"\n                        for plr in team_players\n                    ]\n                )\n                + \"\\n\\n\"\n            )\n        if embed2.description.strip() == \"\":\n            embed2.description = \"> There are no players in-game.\"\n\n        embed2.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n\n        if len(embed2.description) > 3999:\n            embed2.description = \"> The list is too long to display.\"\n\n        await ctx.send(embed=embed2)\n\n    @server.command(\n        name=\"vehicles\", description=\"See all vehicles of players in the server.\"\n    )\n    @is_staff()\n    @is_server_linked()\n    async def server_vehicles(self, ctx: commands.Context):\n        guild_id = int(ctx.guild.id)\n        players: list[Player] = await self.bot.prc_api.get_server_players(guild_id)\n        vehicles: list[prc_api.ActiveVehicle] = (\n            await self.bot.prc_api.get_server_vehicles(guild_id)\n        )\n\n        if len(vehicles) <= 0:\n            emb = discord.Embed(\n                title=f\"Server Vehicles [{len(vehicles)}/{len(players)}]\",\n                description=\"> There are no active vehicles in your server.\",\n                color=BLANK_COLOR,\n            )\n            emb.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon.url)\n            return ctx.send(embed=emb)\n\n        matched = {}\n        for item in vehicles:\n            for x in players:\n                if x.username == item.username:\n                    matched[item] = x\n\n        actual_players = []\n        staff = []\n        for item in players:\n            if item.permission == \"Normal\":\n                actual_players.append(item)\n            else:\n                staff.append(item)\n\n        descriptions = []\n        description = \"\"\n        for index, (veh, plr) in enumerate(matched.items()):\n            description += f\"[{plr.username}](https://roblox.com/users/{plr.id}/profile) - {veh.vehicle} **({veh.texture})**\\n\"\n            if (index + 1) % 10 == 0 or (index + 1) == len(matched):\n                descriptions.append(description)\n                description = \"\"\n\n        if not descriptions:\n            descriptions.append(\"> There are no active vehicles in your server.\")\n\n        pages = []\n        for index, description in enumerate(descriptions):\n            embed = discord.Embed(\n                title=f\"Server Vehicles [{len(vehicles)}/{len(players)}]\",\n                color=BLANK_COLOR,\n                description=description,\n            )\n            embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon.url)\n\n            page = CustomPage(embeds=[embed], identifier=embed.title, view=None)\n            pages.append(page)\n\n        paginator = SelectPagination(self.bot, ctx.author.id, pages)\n        try:\n            await ctx.send(embeds=pages[0].embeds, view=paginator.get_current_view())\n        except discord.HTTPException:\n            await ctx.send(\n                embed=discord.Embed(\n                    title=\"Critical Error\",\n                    description=\"Configuration error; 827\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n    @server.command(\n        name=\"check\",\n        description=\"Perform a Discord check on your server to see if all players are in the Discord server.\",\n    )\n    @is_staff()\n    @is_server_linked()\n    async def check(self, ctx: commands.Context):\n        msg = await ctx.send(\n            embed=discord.Embed(\n                title=f\"{self.bot.emoji_controller.get_emoji('Clock')} Checking...\",\n                description=\"This may take a while.\",\n                color=BLANK_COLOR,\n            )\n        )\n        guild_id = ctx.guild.id\n        try:\n            players: list[Player] = await self.bot.prc_api.get_server_players(guild_id)\n        except ResponseFailure:\n            return await msg.edit(\n                embed=discord.Embed(\n                    title=f\"{self.bot.emoji_controller.get_emoji('WarningIcon')} PRC API Error\",\n                    description=\"There was an error fetching players from the PRC API.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        if not players:\n            return await msg.edit(\n                embed=discord.Embed(\n                    title=\"No Players Found\",\n                    description=\"There are no players in the server to check.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        embed = discord.Embed(\n            title=\"Players in ER:LC Not in Discord\", color=BLANK_COLOR, description=\"\"\n        )\n\n        for player in players:\n            pattern = re.compile(re.escape(player.username), re.IGNORECASE)\n            member_found = False\n\n            for member in ctx.guild.members:\n                if (\n                    pattern.search(member.name)\n                    or pattern.search(member.display_name)\n                    or (\n                        hasattr(member, \"global_name\")\n                        and member.global_name\n                        and pattern.search(member.global_name)\n                    )\n                ):\n                    member_found = True\n                    break\n\n            if not member_found:\n                try:\n                    discord_id = await get_discord_by_roblox(self.bot, player.username)\n                    if discord_id:\n                        member = ctx.guild.get_member(discord_id)\n                        if member:\n                            member_found = True\n                except discord.HTTPException:\n                    pass\n\n            if not member_found:\n                embed.description += f\"> [{player.username}](https://roblox.com/users/{player.id}/profile)\\n\"\n\n        if embed.description == \"\":\n            embed.description = \"> All players are in the Discord server.\"\n\n        embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n        await msg.edit(embed=embed)\n\n    @server.command(\n        name=\"refresh\", description=\"Refresh the author in the ER:LC server.\"\n    )\n    @is_server_linked()\n    async def refresh(self, ctx: commands.Context):\n        settings = await self.bot.settings.find_by_id(ctx.guild.id) or {}\n        erlc_settings = settings.get(\"ERLC\", {})\n        if not erlc_settings.get(\"allow_player_refresh\", False):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Enabled\",\n                    description=\"Player refresh is not enabled in this server.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        user = ctx.author\n\n        guild_id = ctx.guild.id\n        roblox_user = await self.bot.bloxlink.find_roblox(user.id)\n        if not roblox_user or not (roblox_user or {}).get(\"robloxID\"):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Could not find user\",\n                    description=\"I couldn't find your ROBLOX user. Please make sure that you're verified with Bloxlink.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        roblox_info = await self.bot.bloxlink.get_roblox_info(roblox_user[\"robloxID\"])\n        username = roblox_info.get(\"name\")\n\n        if not username:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Could not find username\",\n                    description=\"I could not find this user's ROBLOX username.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        client = roblox.Client()\n        roblox_player = await client.get_user_by_username(username)\n        thumbnails = await client.thumbnails.get_user_avatar_thumbnails(\n            [roblox_player], type=AvatarThumbnailType.headshot\n        )\n        thumbnail_url = thumbnails[0].image_url\n\n        embed = discord.Embed(\n            title=\"Confirm Refresh\",\n            description=f\"Is this your account? If not, be sure to set a new primary account with Bloxlink.\",\n            color=BLANK_COLOR,\n        )\n        embed.set_thumbnail(url=thumbnail_url)\n        embed.add_field(\n            name=\"Account Information\",\n            value=(\n                f\"> **Username:** {username}\\n\"\n                f\"> **User ID:** {roblox_user['robloxID']}\\n\"\n                f\"> **Discord:** {user.mention}\\n\"\n            ),\n        )\n\n        view = RefreshConfirmation(ctx.author.id)\n        msg = await ctx.send(embed=embed, view=view)\n        view.message = msg\n\n        await view.wait()\n        if not view.value:\n            return await msg.edit(\n                embed=discord.Embed(\n                    title=\"Cancelled\",\n                    description=\"Refresh has been cancelled.\",\n                    color=BLANK_COLOR,\n                ),\n                view=None,\n            )\n\n        command_response = await self.bot.prc_api.run_command(\n            guild_id, f\":refresh {username}\"\n        )\n        if command_response[0] == 200:\n            await msg.edit(\n                embed=discord.Embed(\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Successfully Refreshed\",\n                    description=f\"Successfully refreshed {username} in-game.\",\n                    color=GREEN_COLOR,\n                ),\n                view=None,\n            )\n        else:\n            await msg.edit(\n                embed=discord.Embed(\n                    title=f\"Not Executed ({command_response[0]})\",\n                    description=\"This command has not been sent to the server successfully.\",\n                    color=BLANK_COLOR,\n                ),\n                view=None,\n            )\n\n\nasync def setup(bot):\n    await bot.add_cog(ERLC(bot))\n"}
{"type": "source_file", "path": "datamodels/FiveMLinks.py", "content": "from discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass FiveMLinks(Document):\r\n    pass\r\n"}
{"type": "source_file", "path": "datamodels/Analytics.py", "content": "from discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass Analytics(Document):\r\n    pass\r\n"}
{"type": "source_file", "path": "datamodels/IntegrationCommandStorage.py", "content": "from discord.ext import commands\nimport discord\nfrom utils.mongo import Document\n\n\nclass IntegrationCommandStorage(Document):\n    pass\n"}
{"type": "source_file", "path": "cogs/Utility.py", "content": "import datetime\r\nimport logging\r\nimport aiohttp\r\nimport os\r\nfrom decouple import config\r\n\r\nimport discord\r\nfrom discord import app_commands\r\nfrom discord.app_commands import AppCommandGroup\r\nfrom discord.ext import commands\r\n\r\nfrom menus import LinkView, CustomSelectMenu, MultiPaginatorMenu, APIKeyConfirmation\r\nfrom utils.constants import BLANK_COLOR, GREEN_COLOR\r\nfrom utils.timestamp import td_format\r\nfrom utils.utils import invis_embed, failure_embed, require_settings\r\nfrom erm import is_staff, is_management\r\n\r\n\r\nclass Utility(commands.Cog):\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n\r\n    @commands.hybrid_command(\r\n        name=\"staff_sync\",\r\n        description=\"Internal Use Command, used for connection staff privileged individuals to their Roblox counterparts.\",\r\n        extras={\"category\": \"Utility\"},\r\n        hidden=True,\r\n        with_app_command=False,\r\n    )\r\n    @commands.has_role(988055417907200010)\r\n    async def staff_sync(self, ctx: commands.Context, discord_id: int, roblox_id: int):\r\n        from bson import ObjectId\r\n        from datamodels.StaffConnections import StaffConnection\r\n\r\n        await self.bot.staff_connections.insert_connection(\r\n            StaffConnection(\r\n                roblox_id=roblox_id, discord_id=discord_id, document_id=ObjectId()\r\n            )\r\n        )\r\n        roblox_user = await self.bot.roblox.get_user(roblox_id)\r\n        await ctx.send(\r\n            embed=discord.Embed(\r\n                title=\"Staff Sync\",\r\n                description=f\"Successfully synced <@{discord_id}> to {roblox_user.name}\",\r\n                color=BLANK_COLOR,\r\n            )\r\n        )\r\n\r\n    @commands.hybrid_command(\r\n        name=\"ping\",\r\n        description=\"Shows information of the bot, such as uptime and latency\",\r\n        extras={\"category\": \"Utility\"},\r\n    )\r\n    async def ping(self, ctx):\r\n        latency = round(self.bot.latency * 1000)\r\n        embed = discord.Embed(\r\n            title=\"Bot Status\",\r\n            color=BLANK_COLOR,\r\n        )\r\n\r\n        if ctx.guild is not None:\r\n            embed.set_author(\r\n                name=ctx.guild.name,\r\n                icon_url=ctx.guild.icon,\r\n            )\r\n        else:\r\n            embed.set_author(\r\n                name=ctx.author.name,\r\n                icon_url=ctx.author.display_avatar.url,\r\n            )\r\n\r\n        data = await self.bot.db.command(\"ping\")\r\n\r\n        status: str | None = None\r\n\r\n        if list(data.keys())[0] == \"ok\":\r\n            status = \"Connected\"\r\n        else:\r\n            status = \"Not Connected\"\r\n\r\n        embed.add_field(\r\n            name=\"Information\",\r\n            value=(\r\n                f\"> **Latency:** `{latency}ms`\\n\"\r\n                f\"> **Uptime:** <t:{int(self.bot.start_time)}:R>\\n\"\r\n                f\"> **Database Connection:** {status}\\n\"\r\n                f\"> **Shards:** `{self.bot.shard_count-1 if isinstance(self.bot, commands.AutoShardedBot) else 0}`\\n\"\r\n            ),\r\n            inline=False,\r\n        )\r\n\r\n        embed.set_footer(\r\n            text=f\"Shard {ctx.guild.shard_id if ctx.guild and isinstance(self.bot, commands.AutoShardedBot) else 0}/{self.bot.shard_count-1 if isinstance(self.bot, commands.AutoShardedBot) else 0}\"\r\n        )\r\n        embed.timestamp = datetime.datetime.utcnow()\r\n        embed.set_thumbnail(url=ctx.guild.icon)\r\n        await ctx.send(embed=embed)\r\n\r\n    @commands.hybrid_command(\r\n        name=\"modpanel\",\r\n        aliases=[\"panel\"],\r\n        description=\"Get the link to this server's mod panel.\",\r\n        extras={\"category\": \"Website\"},\r\n    )\r\n    @is_staff()\r\n    @require_settings()\r\n    async def mod_panel(self, ctx: commands.Context):\r\n        guild_icon = ctx.guild.icon.url if ctx.guild.icon else None\r\n\r\n        await ctx.send(\r\n            embed=discord.Embed(\r\n                color=BLANK_COLOR,\r\n                description=\"Visit your server's Moderation Panel using the button below.\",\r\n            ).set_author(name=ctx.guild.name, icon_url=guild_icon),\r\n            view=LinkView(\r\n                label=\"Mod Panel\", url=f\"https://ermbot.xyz/{ctx.guild.id}/panel\"\r\n            ),\r\n        )\r\n\r\n    @commands.hybrid_command(\r\n        name=\"dashboard\",\r\n        aliases=[\"dash\", \"applications\"],\r\n        description=\"Get the link to manage your server through the dashboard.\",\r\n        extras={\"category\": \"Website\"},\r\n    )\r\n    @is_management()\r\n    async def dashboard(self, ctx: commands.Context):\r\n        guild_icon = ctx.guild.icon.url if ctx.guild.icon else None\r\n\r\n        await ctx.send(\r\n            embed=discord.Embed(\r\n                color=BLANK_COLOR,\r\n                description=\"Visit your server's Dashboard using the button below.\",\r\n            ).set_author(name=ctx.guild.name, icon_url=guild_icon),\r\n            view=LinkView(\r\n                label=\"Dashboard\", url=f\"https://ermbot.xyz/{ctx.guild.id}/dashboard\"\r\n            ),\r\n        )\r\n\r\n    @commands.hybrid_command(\r\n        name=\"support\",\r\n        aliases=[\"support-server\"],\r\n        description=\"Information about the ERM Support Server\",\r\n        extras={\"category\": \"Utility\"},\r\n    )\r\n    async def support_server(self, ctx):\r\n        # using an embed\r\n        # [**Support Server**](https://discord.gg/5pMmJEYazQ)\r\n\r\n        await ctx.reply(\r\n            embed=discord.Embed(\r\n                title=\"ERM Support\",\r\n                description=\"You can join the ERM Systems Discord server using the button below.\",\r\n                color=BLANK_COLOR,\r\n            ),\r\n            view=LinkView(label=\"Support Server\", url=\"https://discord.gg/FAC629TzBy\"),\r\n        )\r\n\r\n    @commands.hybrid_command(\r\n        name=\"about\",\r\n        aliases=[\"info\"],\r\n        description=\"Information about ERM\",\r\n        extras={\"category\": \"Utility\"},\r\n    )\r\n    async def about(self, ctx):\r\n        # using an embed\r\n        # [**Support Server**](https://discord.gg/5pMmJEYazQ)\r\n        embed = discord.Embed(\r\n            title=\"About ERM\",\r\n            color=BLANK_COLOR,\r\n            description=\"ERM is the all-in-one approach to game moderation logging, shift logging and more.\",\r\n        )\r\n\r\n        embed.add_field(\r\n            name=f\"Bot Information\",\r\n            value=(\r\n                \"> **Website:** [View Website](https://ermbot.xyz)\\n\"\r\n                \"> **Support:** [Join Server](https://discord.gg/FAC629TzBy)\\n\"\r\n                f\"> **Invite:** [Invite Bot](https://discord.com/oauth2/authorize?client_id={self.bot.user.id}&permissions=8&scope=bot%20applications.commands)\\n\"\r\n                \"> **Documentation:** [View Documentation](https://docs.ermbot.xyz)\\n\"\r\n                \"> **Desktop:** [Download ERM Desktop](https://ermbot.xyz/download)\"\r\n            ),\r\n            inline=False,\r\n        )\r\n        embed.set_author(\r\n            name=self.bot.user.name,\r\n            icon_url=self.bot.user.display_avatar.url,\r\n        )\r\n        await ctx.reply(embed=embed)\r\n\r\n    @commands.hybrid_group(name=\"api\")\r\n    async def api(self, ctx):\r\n        pass\r\n\r\n    @commands.guild_only()\r\n    @api.command(\r\n        name=\"generate\",\r\n        description=\"Generate an API key for your server\",\r\n        extras={\"category\": \"Utility\"},\r\n    )\r\n    @is_management()\r\n    @require_settings()\r\n    async def api_generate(self, ctx: commands.Context):\r\n        view = APIKeyConfirmation(ctx.author.id)\r\n        msg = await ctx.send(\r\n            embed=discord.Embed(\r\n                title=\"Generate API Key\",\r\n                description=\"Are you sure you want to generate an API key? This will invalidate any existing keys.\",\r\n                color=BLANK_COLOR,\r\n            ),\r\n            view=view,\r\n            ephemeral=isinstance(ctx.interaction, discord.Interaction),\r\n        )\r\n\r\n        await view.wait()\r\n        if not view.value:\r\n            return\r\n\r\n        api_url = f\"{config('OPENERM_API_URL')}/api/v1/auth/token\"\r\n        auth_token = config(\"OPENERM_AUTH_TOKEN\")\r\n        full_url = f\"{api_url}?guild_id={ctx.guild.id}&auth_token={auth_token}\"\r\n\r\n        async with aiohttp.ClientSession() as session:\r\n            try:\r\n                async with session.post(full_url) as response:\r\n\r\n                    response_text = await response.text()\r\n\r\n                    if response.status == 200:\r\n                        api_key = response_text\r\n\r\n                        if isinstance(ctx.interaction, discord.Interaction):\r\n                            await ctx.send(\r\n                                embed=discord.Embed(\r\n                                    title=\"API Key Generated\",\r\n                                    description=\"Here is your API key. Please save it somewhere safe - we won't show it again.\",\r\n                                    color=BLANK_COLOR,\r\n                                ).add_field(name=\"API Key\", value=f\"```{api_key}```\"),\r\n                                ephemeral=True,\r\n                            )\r\n                        else:\r\n                            await ctx.author.send(\r\n                                embed=discord.Embed(\r\n                                    title=\"API Key Generated\",\r\n                                    description=\"Here is your API key. Please save it somewhere safe - we won't show it again.\",\r\n                                    color=BLANK_COLOR,\r\n                                ).add_field(name=\"API Key\", value=f\"```{api_key}```\")\r\n                            )\r\n                            await msg.edit(\r\n                                embed=discord.Embed(\r\n                                    title=f\"{self.bot.emoji_controller.get_emoji('success')} API Key Generated\",\r\n                                    description=\"I have successfully generated an API key and sent it to your DMs!\",\r\n                                    color=GREEN_COLOR,\r\n                                ),\r\n                                view=None,\r\n                            )\r\n                    else:\r\n                        error_msg = f\"API returned non-200 status: {response.status}\"\r\n                        logging.error(error_msg)\r\n                        await ctx.send(\r\n                            embed=discord.Embed(\r\n                                title=\"Error\",\r\n                                description=\"Failed to generate API key. Please try again later.\",\r\n                                color=BLANK_COLOR,\r\n                            ),\r\n                            ephemeral=isinstance(ctx.interaction, discord.Interaction),\r\n                        )\r\n            except aiohttp.ClientError as e:\r\n                error_msg = f\"API request failed: {str(e)}\"\r\n                logging.error(error_msg)\r\n                await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Error\",\r\n                        description=\"Failed to connect to API. Please try again later.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    ephemeral=isinstance(ctx.interaction, discord.Interaction),\r\n                )\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(Utility(bot))\r\n"}
{"type": "source_file", "path": "datamodels/APITokens.py", "content": "from discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass APITokens(Document):\r\n    pass\r\n"}
{"type": "source_file", "path": "cogs/OAuth2.py", "content": "import discord\nfrom discord.ext import commands\n\nfrom menus import YesNoMenu, AccountLinkingMenu\nfrom utils.constants import BLANK_COLOR, GREEN_COLOR\nimport asyncio\nimport time\n\n\nclass OAuth2(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n\n    @commands.hybrid_command(\n        name=\"link\",\n        description=\"Link your Roblox account with ERM.\",\n        extras={\"ephemeral\": True},\n    )\n    async def link_roblox(self, ctx: commands.Context):\n        msg = None\n        linked_account = await self.bot.oauth2_users.db.find_one(\n            {\"discord_id\": ctx.author.id}\n        )\n        if linked_account:\n            user = await self.bot.roblox.get_user(linked_account[\"roblox_id\"])\n            msg = await ctx.send(\n                embed=discord.Embed(\n                    title=\"Already Linked\",\n                    description=f\"You have already linked your account with `{user.name}`. Are you sure you would like to relink?\",\n                    color=BLANK_COLOR,\n                ),\n                view=(view := YesNoMenu(ctx.author.id)),\n            )\n            timeout = await view.wait()\n            if timeout or not view.value:\n                await msg.edit(\n                    embed=discord.Embed(\n                        title=\"Cancelled\",\n                        description=\"This action was cancelled by the user.\",\n                        color=BLANK_COLOR,\n                    ),\n                    view=None,\n                )\n                return\n        timestamp = time.time()\n        verification_message = {\n            \"embed\": discord.Embed(\n                title=\"Verify with ERM\",\n                description=\"**To link your account with ERM, click the button below.**\\nIf you encounter an error, please contact ERM Support by running `/support`.\",\n                color=BLANK_COLOR,\n            ),\n            \"view\": AccountLinkingMenu(self.bot, ctx.author, ctx.interaction),\n        }\n\n        await self.bot.pending_oauth2.db.insert_one({\"discord_id\": ctx.author.id})\n\n        if msg is None:\n            await ctx.send(**verification_message)\n        else:\n            await msg.edit(**verification_message)\n\n        attempts = 0\n        while await asyncio.sleep(3):\n            if attempts > 60:\n                break\n            if not linked_account:\n                if await self.bot.oauth2_users.db.find_one(\n                    {\"discord_id\": ctx.author.id}\n                ):\n                    await msg.edit(\n                        embed=discord.Embed(\n                            title=f\"{self.bot.emoji_controller.get_emoji('success')} Linked\",\n                            description=\"Your Roblox account has been successfully linked to ERM.\",\n                            color=GREEN_COLOR,\n                        )\n                    )\n                    break\n            else:\n                if item := await self.bot.oauth2_users.db.find_one(\n                    {\"discord_id\": ctx.author.id}\n                ):\n                    if item.get(\"last_updated\", 0) > timestamp:\n                        await msg.edit(\n                            embed=discord.Embed(\n                                title=f\"{self.bot.emoji_controller.get_emoji('success')} Linked\",\n                                description=\"Your Roblox account has been successfully linked to ERM.\",\n                                color=GREEN_COLOR,\n                            )\n                        )\n                        break\n                else:\n                    linked_account = None\n\n\nasync def setup(bot):\n    await bot.add_cog(OAuth2(bot))\n"}
{"type": "source_file", "path": "datamodels/PendingOAuth2.py", "content": "from discord.ext import commands\nimport discord\nfrom utils.mongo import Document\n\n\nclass PendingOAuth2(Document):\n    pass\n"}
{"type": "source_file", "path": "cogs/Configuration.py", "content": "from copy import copy\r\nfrom pprint import pformat\r\n\r\nimport discord\r\nfrom discord import HTTPException\r\nfrom discord.ext import commands\r\nfrom copy import deepcopy\r\n\r\nfrom erm import check_privacy, generator, is_management\r\nfrom utils.constants import blank_color, BLANK_COLOR\r\nfrom menus import (\r\n    ChannelSelect,\r\n    CustomSelectMenu,\r\n    ERLCIntegrationConfiguration,\r\n    RoleSelect,\r\n    YesNoColourMenu,\r\n    NextView,\r\n    BasicConfiguration,\r\n    LOAConfiguration,\r\n    ShiftConfiguration,\r\n    RAConfiguration,\r\n    PunishmentsConfiguration,\r\n    GameSecurityConfiguration,\r\n    GameLoggingConfiguration,\r\n    AntipingConfiguration,\r\n    ActivityNoticeManagement,\r\n    PunishmentManagement,\r\n    ShiftLoggingManagement,\r\n    ERMCommandLog,\r\n    WhitelistVehiclesManagement,\r\n    PriorityRequestConfiguration,\r\n)\r\nfrom utils.paginators import CustomPage, SelectPagination\r\nfrom utils.utils import require_settings, generator, log_command_usage\r\n\r\n\r\nclass Configuration(commands.Cog):\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n\r\n    @commands.guild_only()\r\n    @commands.hybrid_command(\r\n        name=\"setup\",\r\n        description=\"Begin using ERM!\",\r\n        extras={\"category\": \"Configuration\"},\r\n    )\r\n    @is_management()\r\n    async def _setup(self, ctx: commands.Context):\r\n        await log_command_usage(self.bot, ctx.guild, ctx.author, f\"Setup\")\r\n        bot = self.bot\r\n        from utils.constants import base_configuration\r\n\r\n        current_settings = None\r\n        # del base_configuration['_id']\r\n        modifications = {\r\n            \"_id\": ctx.guild.id,\r\n            **deepcopy(base_configuration),\r\n        }  # we create a deep copy because we don't want to modify the base configuration\r\n        msg = None\r\n\r\n        current_settings = await bot.settings.find_by_id(ctx.guild.id)\r\n        if current_settings:\r\n            msg = await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Already Setup\",\r\n                    description=\"You've already setup ERM in this server! Are you sure you would like to go through the setup process again?\",\r\n                    color=blank_color,\r\n                ),\r\n                view=(confirmation_view := YesNoColourMenu(ctx.author.id)),\r\n            )\r\n            timeout = await confirmation_view.wait()\r\n            if confirmation_view.value is False:\r\n                return await msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Successfully Cancelled\",\r\n                        description=\"Cancelled the setup process for this server. All settings have been kept.\",\r\n                        color=blank_color,\r\n                    ),\r\n                    view=None,\r\n                )\r\n\r\n        if msg is None:\r\n            msg = await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Let's get started!\",\r\n                    description=\"To setup ERM, press the arrow button below!\",\r\n                    color=blank_color,\r\n                ),\r\n                view=(next_view := NextView(bot, ctx.author.id)),\r\n            )\r\n        else:\r\n            await msg.edit(\r\n                embed=discord.Embed(\r\n                    title=\"Let's get started!\",\r\n                    description=\"To setup ERM, press the arrow button below!\",\r\n                    color=blank_color,\r\n                ),\r\n                view=(next_view := NextView(bot, ctx.author.id)),\r\n            )\r\n\r\n        timeout = await next_view.wait()\r\n        if timeout or not next_view.value:\r\n            await msg.edit(\r\n                embed=discord.Embed(\r\n                    title=\"Cancelled\",\r\n                    description=\"You have took too long to complete this part of the setup.\",\r\n                    color=blank_color,\r\n                ),\r\n                view=None,\r\n            )\r\n            return\r\n\r\n        secret_key = next(generator)\r\n\r\n        def get_active_view_state() -> discord.ui.View | None:\r\n            return self.bot.view_state_manager.get(secret_key)\r\n\r\n        def set_active_view_state(view: discord.ui.View):\r\n            self.bot.view_state_manager[secret_key] = view\r\n\r\n        async def discard_unlock_override(interaction: discord.Interaction):\r\n            if interaction.user != ctx.author:\r\n                return\r\n            await interaction.response.defer()\r\n\r\n        async def check_unlock_override(interaction: discord.Interaction):\r\n            view = get_active_view_state()\r\n            if interaction.user != ctx.author:\r\n                return\r\n            # if view is None:\r\n            #     return\r\n            await interaction.response.defer()\r\n\r\n            impurities = []\r\n            for item in view.children:\r\n                if (\r\n                    isinstance(item, discord.ui.Select)\r\n                    or isinstance(item, discord.ui.RoleSelect)\r\n                    or isinstance(item, discord.ui.ChannelSelect)\r\n                ):\r\n                    if item.callback != discard_unlock_override:\r\n                        if len(item.values) == 0:\r\n                            impurities.append(item)\r\n            # print(impurities)\r\n            if len(impurities) == 0:\r\n                buttons = list(\r\n                    filter(lambda x: isinstance(x, discord.ui.Button), view.children)\r\n                )\r\n                # print(buttons)\r\n                if len(buttons) != 0:\r\n                    buttons[0].disabled = False\r\n                    for item in view.children:\r\n                        if isinstance(item, discord.ui.Select):\r\n                            value = item.values[0]\r\n                            stored_index = 0\r\n                            for index, obj in enumerate(item.options):\r\n                                if obj.value == value:\r\n                                    stored_index = index\r\n                            item.options[stored_index].default = True\r\n                            for select_opt in item.options:\r\n                                if item.options[stored_index] != select_opt:\r\n                                    select_opt.default = False\r\n                            # print(f'defaults: {len([i for i in item.options if i.default is True])}')\r\n                    await interaction.message.edit(view=view)\r\n            else:\r\n                buttons = list(\r\n                    filter(lambda x: isinstance(x, discord.ui.Button), view.children)\r\n                )\r\n                # print(buttons)\r\n                if len(buttons) != 0:\r\n                    if buttons[0].disabled is False:\r\n                        buttons[0].disabled = True\r\n                        await interaction.message.edit(view=view)\r\n\r\n        async def callback_override(interaction: discord.Interaction, *args, **kwargs):\r\n            await interaction.response.defer()\r\n\r\n        basic_settings = discord.ui.View()\r\n        next_button = NextView(bot, ctx.author.id).children[0]\r\n        next_button.row = 4\r\n        next_button.disabled = True\r\n\r\n        staff_roles = RoleSelect(ctx.author.id).children[0]\r\n        staff_roles.row = 0\r\n        staff_roles.placeholder = \"Staff Roles\"\r\n        staff_roles.callback = check_unlock_override\r\n        staff_roles.min_values = 0\r\n\r\n        admin_roles = RoleSelect(ctx.author.id).children[0]\r\n        admin_roles.row = 1\r\n        admin_roles.placeholder = \"Admin Roles\"\r\n        admin_roles.callback = discard_unlock_override\r\n        admin_roles.min_values = 0\r\n\r\n        management_roles = RoleSelect(ctx.author.id).children[0]\r\n        management_roles.row = 2\r\n        management_roles.placeholder = \"Management Roles\"\r\n        management_roles.callback = check_unlock_override\r\n        management_roles.min_values = 0\r\n\r\n        prefix_view = CustomSelectMenu(\r\n            ctx.author.id,\r\n            [\r\n                discord.SelectOption(\r\n                    label=\"!\", description=\"Use '!' as your custom prefix.\"\r\n                ),\r\n                discord.SelectOption(\r\n                    label=\">\", description=\"Use '>' as your custom prefix.\"\r\n                ),\r\n                discord.SelectOption(\r\n                    label=\"?\", description=\"Use '?' as your custom prefix.\"\r\n                ),\r\n                discord.SelectOption(\r\n                    label=\":\", description=\"Use ':' as your custom prefix.\"\r\n                ),\r\n                discord.SelectOption(\r\n                    label=\"-\", description=\"Use '-' as your custom prefix.\"\r\n                ),\r\n            ],\r\n        )\r\n        prefix = prefix_view.children[0]\r\n        prefix.row = 3\r\n        prefix.placeholder = \"Prefix\"\r\n        prefix.callback = check_unlock_override\r\n\r\n        async def stop_override(interaction: discord.Interaction):\r\n            if interaction.user != ctx.author:\r\n                return\r\n            await interaction.response.defer()\r\n            get_active_view_state().stop()\r\n\r\n        # prefix.callback = callback_override\r\n        next_button.callback = stop_override\r\n\r\n        for item in [staff_roles, admin_roles, management_roles, prefix, next_button]:\r\n            basic_settings.add_item(item)\r\n\r\n        set_active_view_state(basic_settings)\r\n\r\n        await msg.edit(\r\n            embed=discord.Embed(\r\n                title=\"Basic Settings\",\r\n                description=(\r\n                    \"**Staff Role:** A staff role is the role that is going to be able to use most ERM commands. You'd assign this role to the people you want to be able to use ERM's core functionalities.\\n\\n\"\r\n                    \"**Admin Role:** An admin role is the role that can manage LOAs, RAs & other peoples' shifts but it can not use server manage and config.\\n\\n\"\r\n                    \"**Management Role:** A management role is the roles of your server management members. These people will be able to delete punishments, modify people's shift time, and accept LOA Requests.\\n\\n\"\r\n                    \"**Prefix:** This will be a prefix you are able to use instead of our slash command system. You can use this prefix to execute commands slightly faster and to take advantage of some extra features.\"\r\n                ),\r\n                color=blank_color,\r\n            ),\r\n            view=basic_settings,\r\n        )\r\n        await basic_settings.wait()\r\n\r\n        for item in basic_settings.children:\r\n            if isinstance(item, discord.ui.Select) or isinstance(\r\n                item, discord.ui.RoleSelect\r\n            ):\r\n                if len(item.values) > 0:\r\n                    if item.placeholder == \"Staff Roles\":\r\n                        modifications[\"staff_management\"][\"role\"] = [\r\n                            i.id for i in item.values\r\n                        ]\r\n                    if item.placeholder == \"Prefix\":\r\n                        modifications[\"customisation\"][\"prefix\"] = item.values[0]\r\n                    elif item.placeholder == \"Management Roles\":\r\n                        modifications[\"staff_management\"][\"management_role\"] = [\r\n                            i.id for i in item.values\r\n                        ]\r\n                    elif item.placeholder == \"Admin Roles\":\r\n                        modifications[\"staff_management\"][\"admin_role\"] = [\r\n                            i.id for i in item.values\r\n                        ]\r\n\r\n        loa_requests_settings = discord.ui.View()\r\n\r\n        loa_channel_view = ChannelSelect(ctx.author.id, limit=1)\r\n        loa_channel_select = loa_channel_view.children[0]\r\n        loa_channel_select.placeholder = \"LOA Channel\"\r\n        loa_channel_select.row = 1\r\n\r\n        loa_role_view = RoleSelect(ctx.author.id, limit=1)\r\n        loa_role_select = loa_role_view.children[0]\r\n        loa_role_select.placeholder = \"LOA Role\"\r\n        loa_role_select.row = 2\r\n\r\n        loa_enabled_view = CustomSelectMenu(\r\n            ctx.author.id,\r\n            [\r\n                discord.SelectOption(\r\n                    label=\"Enabled\",\r\n                    value=\"enabled\",\r\n                    description=\"LOA Requests are enabled.\",\r\n                ),\r\n                discord.SelectOption(\r\n                    label=\"Disabled\",\r\n                    value=\"disabled\",\r\n                    description=\"LOA Requests are disabled.\",\r\n                ),\r\n            ],\r\n        )\r\n        loa_enabled_select = loa_enabled_view.children[0]\r\n        loa_enabled_select.callback = callback_override\r\n        loa_enabled_select.row = 0\r\n        loa_enabled_select.placeholder = \"LOA Requests\"\r\n\r\n        next_view = NextView(bot, ctx.author.id)\r\n        next_button = next_view.children[0]\r\n        next_button.callback = stop_override\r\n        next_button.row = 4\r\n\r\n        for item in [\r\n            loa_enabled_select,\r\n            loa_role_select,\r\n            loa_channel_select,\r\n            next_button,\r\n        ]:\r\n            loa_requests_settings.add_item(item)\r\n\r\n        await msg.edit(\r\n            embed=discord.Embed(\r\n                title=f\"{self.bot.emoji_controller.get_emoji('loa')} LOA Requests\",\r\n                description=(\r\n                    \"**Enabled:** This setting enables or disables the LOA Requests module. When enabled, this allows your staff members to fill out Leave of Absence requests for your management members to approve.\\n\\n\"\r\n                    \"**LOA Role:** This role is given to those who are on Leave of Absence, and is removed when they go off Leave of Absence.\\n\\n\"\r\n                    \"**LOA Channel:** This channel will be where Leave of Absence requests will be logged, and where they will be accepted or denied. Make sure this is a channel that Management members can see, so that they can approve LOA requests.\"\r\n                ),\r\n                color=blank_color,\r\n            ),\r\n            view=loa_requests_settings,\r\n        )\r\n\r\n        set_active_view_state(loa_requests_settings)\r\n        await loa_requests_settings.wait()\r\n\r\n        for item in loa_requests_settings.children:\r\n            if (\r\n                isinstance(item, discord.ui.Select)\r\n                or isinstance(item, discord.ui.RoleSelect)\r\n                or isinstance(item, discord.ui.ChannelSelect)\r\n            ):\r\n                if len(item.values) > 0:\r\n                    if item.placeholder == \"LOA Role\":\r\n                        modifications[\"staff_management\"][\"loa_role\"] = [\r\n                            r.id for r in item.values\r\n                        ]\r\n                    elif item.placeholder == \"LOA Channel\":\r\n                        modifications[\"staff_management\"][\"channel\"] = item.values[0].id\r\n                    elif item.placeholder == \"LOA Requests\":\r\n                        modifications[\"staff_management\"][\"enabled\"] = bool(\r\n                            item.values[0] == \"enabled\"\r\n                        )\r\n\r\n        ra_requests_settings = discord.ui.View()\r\n\r\n        ra_role_view = RoleSelect(ctx.author.id, limit=1)\r\n        ra_role_select = ra_role_view.children[0]\r\n        ra_role_select.placeholder = \"RA Role\"\r\n        ra_role_select.row = 2\r\n        ra_role_select.min_values = 0\r\n\r\n        next_view = NextView(bot, ctx.author.id)\r\n        next_button = next_view.children[0]\r\n        next_button.callback = stop_override\r\n        next_button.row = 4\r\n\r\n        for item in [ra_role_select, next_button]:\r\n            ra_requests_settings.add_item(item)\r\n\r\n        await msg.edit(\r\n            embed=discord.Embed(\r\n                title=f\"{self.bot.emoji_controller.get_emoji('loa')} RA Requests\",\r\n                description=(\r\n                    \"**What are RA Requests?** RA Requests, also called Reduced Activity Requests, are a form of Leave of Absence where the staff member isn't required to complete the full quota, but expects that they will be able to complete it partially.\\n\\n\"\r\n                    \"**RA Role:** This role is given to those who are on Reduced Activity, and is removed when they go off Reduced Activity.\\n\\n\"\r\n                ),\r\n                color=blank_color,\r\n            ),\r\n            view=ra_requests_settings,\r\n        )\r\n        set_active_view_state(ra_requests_settings)\r\n\r\n        await ra_requests_settings.wait()\r\n\r\n        for item in ra_requests_settings.children:\r\n            if isinstance(item, discord.ui.Select) or isinstance(\r\n                item, discord.ui.RoleSelect\r\n            ):\r\n                if len(item.values) > 0:\r\n                    if item.placeholder == \"RA Role\":\r\n                        modifications[\"staff_management\"][\"ra_role\"] = item.values[0].id\r\n\r\n        punishment_settings = discord.ui.View()\r\n\r\n        next_view = NextView(bot, ctx.author.id)\r\n        next_button = next_view.children[0]\r\n        next_button.callback = stop_override\r\n        next_button.row = 4\r\n\r\n        punishment_channel_view = ChannelSelect(ctx.author.id, limit=1)\r\n        punishment_channel_select: discord.ui.ChannelSelect = (\r\n            punishment_channel_view.children[0]\r\n        )\r\n        punishment_channel_select.min_values = 0\r\n        punishment_channel_select.placeholder = \"Punishments Channel\"\r\n        punishment_channel_select.row = 1\r\n\r\n        punishments_enabled_view = CustomSelectMenu(\r\n            ctx.author.id,\r\n            [\r\n                discord.SelectOption(\r\n                    label=\"Enabled\",\r\n                    value=\"enabled\",\r\n                    description=\"ROBLOX Punishments are enabled.\",\r\n                ),\r\n                discord.SelectOption(\r\n                    label=\"Disabled\",\r\n                    value=\"disabled\",\r\n                    description=\"ROBLOX Punishments are disabled.\",\r\n                ),\r\n            ],\r\n        )\r\n        punishments_enabled_item = punishments_enabled_view.children[0]\r\n        punishments_enabled_item.placeholder = \"ROBLOX Punishments\"\r\n        punishments_enabled_item.row = 0\r\n        punishments_enabled_item.callback = callback_override\r\n\r\n        for item in [punishments_enabled_item, punishment_channel_select, next_button]:\r\n            punishment_settings.add_item(item)\r\n\r\n        await msg.edit(\r\n            embed=discord.Embed(\r\n                title=f\"{self.bot.emoji_controller.get_emoji('log')} ROBLOX Punishments\",\r\n                description=(\r\n                    \"**What is the ROBLOX Punishments module?** The ROBLOX Punishments module allows for members of your Staff Team to log punishments against a ROBLOX player using ERM! You can specify custom types of punishments, where they will go, as well as manage and search individual punishments.\\n\\n\"\r\n                    \"**Enabled:** This setting toggles the ROBLOX Punishments module. When enabled, staff members will be able to use `/punish`, and management members will be able to additionally use `/punishment manage`.\\n\\n\"\r\n                    \"**Punishments Channel:** This is where most punishments made with the ROBLOX Punishments go. Any logged actions of a ROBLOX player will go to this channel.\"\r\n                ),\r\n                color=blank_color,\r\n            ),\r\n            view=punishment_settings,\r\n        )\r\n        set_active_view_state(punishment_settings)\r\n        await punishment_settings.wait()\r\n\r\n        for item in punishment_settings.children:\r\n            if (\r\n                isinstance(item, discord.ui.Select)\r\n                or isinstance(item, discord.ui.RoleSelect)\r\n                or isinstance(item, discord.ui.ChannelSelect)\r\n            ):\r\n                if len(item.values) > 0:\r\n                    if item.placeholder == \"ROBLOX Punishments\":\r\n                        if not modifications.get(\"punishments\"):\r\n                            modifications[\"punishments\"] = {}\r\n                        modifications[\"punishments\"][\"enabled\"] = bool(\r\n                            item.values[0] == \"enabled\"\r\n                        )\r\n                    elif item.placeholder == \"Punishments Channel\":\r\n                        if not modifications.get(\"punishments\"):\r\n                            modifications[\"punishments\"] = {}\r\n                        modifications[\"punishments\"][\"channel\"] = item.values[0].id\r\n\r\n        shift_management_settings = discord.ui.View()\r\n\r\n        shift_enabled_view = CustomSelectMenu(\r\n            ctx.author.id,\r\n            [\r\n                discord.SelectOption(\r\n                    label=\"Enabled\",\r\n                    value=\"enabled\",\r\n                    description=\"Enable the Shift Management module.\",\r\n                ),\r\n                discord.SelectOption(\r\n                    label=\"Disabled\",\r\n                    value=\"disabled\",\r\n                    description=\"Disable the Shift Management module.\",\r\n                ),\r\n            ],\r\n        )\r\n        shift_enabled_select = shift_enabled_view.children[0]\r\n        shift_enabled_select.placeholder = \"Shift Management\"\r\n        shift_enabled_select.row = 0\r\n        shift_enabled_select.callback = callback_override\r\n\r\n        shift_channel_view = ChannelSelect(ctx.author.id, limit=1)\r\n        shift_channel_select = shift_channel_view.children[0]\r\n        shift_channel_select.row = 1\r\n        shift_channel_select.placeholder = \"Shift Channel\"\r\n        shift_channel_select.min_values = 0\r\n\r\n        shift_role_view = RoleSelect(ctx.author.id, limit=5)\r\n        shift_role_select = shift_role_view.children[0]\r\n        shift_role_select.row = 2\r\n        shift_role_select.placeholder = \"On-Duty Role\"\r\n        shift_channel_select.min_values = 0\r\n\r\n        next_menu = NextView(bot, ctx.author.id)\r\n        next_button = next_menu.children[0]\r\n        next_button.disabled = False\r\n        next_button.callback = stop_override\r\n        next_button.row = 4\r\n\r\n        for item in [\r\n            shift_enabled_select,\r\n            shift_role_select,\r\n            shift_channel_select,\r\n            next_button,\r\n        ]:\r\n            shift_management_settings.add_item(item)\r\n\r\n        await msg.edit(\r\n            embed=discord.Embed(\r\n                title=f\"{self.bot.emoji_controller.get_emoji('shift')} Shift Management\",\r\n                description=(\r\n                    \"**What is Shift Management?** The Shift Management module allows for staff members to log how much time they were in-game, or moderating, or on as a staff member. It allows for a comprehensive guide of who is the most active in your staff team.\\n\\n\"\r\n                    \"**Enabled:** When enabled, staff members will be able to run `/duty` commands to manage their shift, see how much time they have, as well as see how much time other people have. Management members will be able to administrate people's shifts, add time, remove time, and clear people's shifts.\\n\\n\"\r\n                    \"**Shift Channel:** This is where all shift logs will go to. This channel will be used for all modifications to shifts, any person that may be starting or ending their shift.\\n\\n\"\r\n                    \"**On-Duty Role:** When someone is on shift, they will be given this role. When the staff member goes off shift, this role will be removed from them.\"\r\n                ),\r\n                color=blank_color,\r\n            ),\r\n            view=shift_management_settings,\r\n        )\r\n        set_active_view_state(shift_management_settings)\r\n        await shift_management_settings.wait()\r\n\r\n        for item in shift_management_settings.children:\r\n            if (\r\n                isinstance(item, discord.ui.Select)\r\n                or isinstance(item, discord.ui.RoleSelect)\r\n                or isinstance(item, discord.ui.ChannelSelect)\r\n            ):\r\n                if len(item.values) > 0:\r\n                    if item.placeholder == \"Shift Management\":\r\n                        modifications[\"shift_management\"][\"enabled\"] = bool(\r\n                            item.values[0] == \"enabled\"\r\n                        )\r\n                    elif item.placeholder == \"Shift Channel\":\r\n                        modifications[\"shift_management\"][\"channel\"] = item.values[0].id\r\n                    elif item.placeholder == \"On-Duty Role\":\r\n                        modifications[\"shift_management\"][\"role\"] = [\r\n                            role.id for role in item.values\r\n                        ]\r\n\r\n        new_configuration = copy(base_configuration)\r\n        new_configuration.update(modifications)\r\n        new_configuration[\"_id\"] = ctx.guild.id\r\n        await bot.settings.upsert(new_configuration)\r\n        await msg.edit(\r\n            embed=discord.Embed(\r\n                title=f'{self.bot.emoji_controller.get_emoji(\"success\")} Success!',\r\n                description=\"You are now setup with ERM, and have finished the Setup Wizard! You should now be able to use ERM in your staff team. If you'd like to change any of these settings, use `/config`!\\n\\n**ERM has lots more modules than what's mentioned here! You can enable them by going into `/config`!**\",\r\n                color=0x1FD373,\r\n            ),\r\n            view=None,\r\n        )\r\n\r\n    @commands.guild_only()\r\n    @commands.hybrid_command(\r\n        name=\"config\",\r\n        description=\"View your ERM settings\",\r\n        aliases=[\"settings\"],\r\n        extras={\"category\": \"Configuration\"},\r\n    )\r\n    @require_settings()\r\n    @is_management()\r\n    async def _config(self, ctx: commands.Context):\r\n        bot = self.bot\r\n        settings = await bot.settings.find_by_id(ctx.guild.id)\r\n\r\n        await log_command_usage(self.bot, ctx.guild, ctx.author, f\"Config\")\r\n\r\n        basic_settings_view = BasicConfiguration(\r\n            bot,\r\n            ctx.author.id,\r\n            [\r\n                (\r\n                    \"Staff Roles\",\r\n                    [\r\n                        discord.utils.get(ctx.guild.roles, id=role)\r\n                        for role in settings[\"staff_management\"].get(\"role\") or [0]\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Admin Role\",\r\n                    [\r\n                        discord.utils.get(ctx.guild.roles, id=role)\r\n                        for role in settings[\"staff_management\"].get(\"admin_role\")\r\n                        or [0]\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Management Roles\",\r\n                    [\r\n                        discord.utils.get(ctx.guild.roles, id=role)\r\n                        for role in settings[\"staff_management\"].get(\r\n                            \"management_role\", []\r\n                        )\r\n                        or [0]\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Prefix\",\r\n                    [\r\n                        [\"CUSTOM_CONF\", {\"_FIND_BY_LABEL\": True}],\r\n                        (\r\n                            settings[\"customisation\"].get(\"prefix\")\r\n                            if settings[\"customisation\"].get(\"prefix\")\r\n                            in [\"!\", \">\", \"?\", \":\", \"-\"]\r\n                            else None\r\n                        ),\r\n                    ],\r\n                ),\r\n            ],\r\n        )\r\n\r\n        loa_config = settings[\"staff_management\"].get(\"loa_role\")\r\n        if isinstance(loa_config, list):\r\n            loa_roles = [discord.utils.get(ctx.guild.roles, id=i) for i in loa_config]\r\n        elif isinstance(loa_config, int):\r\n            loa_roles = [discord.utils.get(ctx.guild.roles, id=loa_config)]\r\n        else:\r\n            loa_roles = [0]\r\n\r\n        loa_configuration_view = LOAConfiguration(\r\n            bot,\r\n            ctx.author.id,\r\n            [\r\n                (\r\n                    \"LOA Requests\",\r\n                    [\r\n                        [\"CUSTOM_CONF\", {\"_FIND_BY_LABEL\": True}],\r\n                        (\r\n                            \"Enabled\"\r\n                            if settings[\"staff_management\"].get(\"enabled\") is True\r\n                            else \"Disabled\"\r\n                        ),\r\n                    ],\r\n                ),\r\n                (\"LOA Role\", loa_roles),\r\n                (\r\n                    \"LOA Channel\",\r\n                    [\r\n                        (\r\n                            discord.utils.get(ctx.guild.channels, id=channel)\r\n                            if (channel := settings[\"staff_management\"].get(\"channel\"))\r\n                            else 0\r\n                        )\r\n                    ],\r\n                ),\r\n            ],\r\n        )\r\n\r\n        shift_management_view = ShiftConfiguration(\r\n            bot,\r\n            ctx.author.id,\r\n            [\r\n                (\r\n                    \"On-Duty Role\",\r\n                    [\r\n                        discord.utils.get(ctx.guild.roles, id=role)\r\n                        for role in (settings[\"shift_management\"].get(\"role\") or [0])\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Shift Channel\",\r\n                    [\r\n                        (\r\n                            discord.utils.get(ctx.guild.channels, id=channel)\r\n                            if (channel := settings[\"shift_management\"].get(\"channel\"))\r\n                            else 0\r\n                        )\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Shift Management\",\r\n                    [\r\n                        [\"CUSTOM_CONF\", {\"_FIND_BY_LABEL\": True}],\r\n                        (\r\n                            \"Enabled\"\r\n                            if settings[\"shift_management\"].get(\"enabled\") is True\r\n                            else \"Disabled\"\r\n                        ),\r\n                    ],\r\n                ),\r\n            ],\r\n        )\r\n\r\n        ra_config = settings[\"staff_management\"].get(\"ra_role\")\r\n        if isinstance(ra_config, list):\r\n            ra_roles = [discord.utils.get(ctx.guild.roles, id=i) for i in ra_config]\r\n        elif isinstance(ra_config, int):\r\n            ra_roles = [discord.utils.get(ctx.guild.roles, id=ra_config)]\r\n        else:\r\n            ra_roles = [0]\r\n\r\n        ra_view = RAConfiguration(bot, ctx.author.id, [(\"RA Role\", ra_roles)])\r\n\r\n        roblox_punishments = PunishmentsConfiguration(\r\n            bot,\r\n            ctx.author.id,\r\n            [\r\n                (\r\n                    \"Punishments Channel\",\r\n                    [\r\n                        (\r\n                            discord.utils.get(ctx.guild.channels, id=channel)\r\n                            if (channel := settings[\"punishments\"].get(\"channel\"))\r\n                            else 0\r\n                        )\r\n                    ],\r\n                ),\r\n                (\r\n                    \"ROBLOX Punishments\",\r\n                    [\r\n                        [\"CUSTOM_CONF\", {\"_FIND_BY_LABEL\": True}],\r\n                        (\r\n                            \"Enabled\"\r\n                            if settings[\"punishments\"].get(\"enabled\") is True\r\n                            else \"Disabled\"\r\n                        ),\r\n                    ],\r\n                ),\r\n            ],\r\n        )\r\n\r\n        security_view = GameSecurityConfiguration(\r\n            bot,\r\n            ctx.author.id,\r\n            [\r\n                (\r\n                    \"Game Security\",\r\n                    [\r\n                        [\"CUSTOM_CONF\", {\"_FIND_BY_LABEL\": True}],\r\n                        (\r\n                            \"Enabled\"\r\n                            if settings.get(\"game_security\", {}).get(\"enabled\") is True\r\n                            else \"Disabled\"\r\n                        ),\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Alert Channel\",\r\n                    [\r\n                        (\r\n                            discord.utils.get(ctx.guild.channels, id=channel)\r\n                            if (\r\n                                channel := settings.get(\"game_security\", {}).get(\r\n                                    \"channel\"\r\n                                )\r\n                            )\r\n                            else 0\r\n                        )\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Webhook Channel\",\r\n                    [\r\n                        (\r\n                            discord.utils.get(ctx.guild.channels, id=channel)\r\n                            if (\r\n                                channel := settings.get(\"game_security\", {}).get(\r\n                                    \"webhook_channel\"\r\n                                )\r\n                            )\r\n                            else 0\r\n                        )\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Mentionables\",\r\n                    [\r\n                        discord.utils.get(ctx.guild.roles, id=role)\r\n                        for role in (\r\n                            settings.get(\"game_security\", {}).get(\"role\") or [0]\r\n                        )\r\n                    ],\r\n                ),\r\n            ],\r\n        )\r\n\r\n        logging_view = GameLoggingConfiguration(\r\n            bot,\r\n            ctx.author.id,\r\n            [\r\n                (\r\n                    \"Message Logging\",\r\n                    [\r\n                        [\"CUSTOM_CONF\", {\"_FIND_BY_LABEL\": True}],\r\n                        (\r\n                            \"Enabled\"\r\n                            if settings.get(\"game_logging\", {})\r\n                            .get(\"message\", {})\r\n                            .get(\"enabled\", None)\r\n                            is True\r\n                            else \"Disabled\"\r\n                        ),\r\n                    ],\r\n                ),\r\n                (\r\n                    \"STS Logging\",\r\n                    [\r\n                        [\"CUSTOM_CONF\", {\"_FIND_BY_LABEL\": True}],\r\n                        (\r\n                            \"Enabled\"\r\n                            if settings.get(\"game_logging\", {})\r\n                            .get(\"sts\", {})\r\n                            .get(\"enabled\", None)\r\n                            is True\r\n                            else \"Disabled\"\r\n                        ),\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Priority Logging\",\r\n                    [\r\n                        [\"CUSTOM_CONF\", {\"_FIND_BY_LABEL\": True}],\r\n                        (\r\n                            \"Enabled\"\r\n                            if settings.get(\"game_logging\", {})\r\n                            .get(\"priority\", {})\r\n                            .get(\"enabled\", None)\r\n                            is True\r\n                            else \"Disabled\"\r\n                        ),\r\n                    ],\r\n                ),\r\n            ],\r\n        )\r\n\r\n        antiping_view = AntipingConfiguration(\r\n            bot,\r\n            ctx.author.id,\r\n            [\r\n                (\r\n                    \"Anti-Ping\",\r\n                    [\r\n                        [\"CUSTOM_CONF\", {\"_FIND_BY_LABEL\": True}],\r\n                        (\r\n                            \"Enabled\"\r\n                            if settings.get(\"antiping\", {}).get(\"enabled\", None) is True\r\n                            else \"Disabled\"\r\n                        ),\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Use Hierarchy\",\r\n                    [\r\n                        [\"CUSTOM_CONF\", {\"_FIND_BY_LABEL\": True}],\r\n                        (\r\n                            \"Enabled\"\r\n                            if settings.get(\"antiping\", {}).get(\"use_hierarchy\", None)\r\n                            is True\r\n                            else \"Disabled\"\r\n                        ),\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Affected Roles\",\r\n                    [\r\n                        discord.utils.get(ctx.guild.roles, id=role)\r\n                        for role in (settings.get(\"antiping\", {}).get(\"role\") or [0])\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Bypass Roles\",\r\n                    [\r\n                        discord.utils.get(ctx.guild.roles, id=role)\r\n                        for role in (\r\n                            settings.get(\"antiping\", {}).get(\"bypass_role\") or [0]\r\n                        )\r\n                    ],\r\n                ),\r\n            ],\r\n        )\r\n\r\n        erlc_view = ERLCIntegrationConfiguration(\r\n            bot,\r\n            ctx.author.id,\r\n            [\r\n                (\r\n                    \"Elevation Required\",\r\n                    [\r\n                        [\"CUSTOM_CONF\", {\"_FIND_BY_LABEL\": True}],\r\n                        (\r\n                            \"Enabled\"\r\n                            if (settings.get(\"ERLC\", {}) or {}).get(\r\n                                \"elevation_required\", True\r\n                            )\r\n                            is True\r\n                            else \"Disabled\"\r\n                        ),\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Player Logs Channel\",\r\n                    [\r\n                        (\r\n                            discord.utils.get(ctx.guild.channels, id=channel)\r\n                            if (\r\n                                channel := (settings.get(\"ERLC\", {}) or {}).get(\r\n                                    \"player_logs\"\r\n                                )\r\n                            )\r\n                            else 0\r\n                        )\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Kill Logs Channel\",\r\n                    [\r\n                        (\r\n                            discord.utils.get(ctx.guild.channels, id=channel)\r\n                            if (\r\n                                channel := (settings.get(\"ERLC\", {}) or {}).get(\r\n                                    \"kill_logs\"\r\n                                )\r\n                            )\r\n                            else 0\r\n                        )\r\n                    ],\r\n                ),\r\n            ],\r\n        )\r\n\r\n        erm_command_log_view = ERMCommandLog(\r\n            bot,\r\n            ctx.author.id,\r\n            [\r\n                (\r\n                    \"ERM Log Channel\",\r\n                    [\r\n                        (\r\n                            discord.utils.get(ctx.guild.channels, id=channel)\r\n                            if (\r\n                                channel := settings.get(\"staff_management\", {}).get(\r\n                                    \"erm_log_channel\"\r\n                                )\r\n                            )\r\n                            else 0\r\n                        )\r\n                    ],\r\n                )\r\n            ],\r\n        )\r\n\r\n        priority_settings = await self.bot.priority_settings.db.find_one(\r\n            {\"guild_id\": str(ctx.guild.id)}\r\n        )\r\n\r\n        priority_requests = PriorityRequestConfiguration(\r\n            bot,\r\n            ctx.author.id,\r\n            [\r\n                (\r\n                    \"Blacklisted Roles\",\r\n                    [\r\n                        discord.utils.get(ctx.guild.roles, id=int(role))\r\n                        for role in (priority_settings or {}).get(\"blacklisted_roles\")\r\n                        or [0]\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Mentioned Roles\",\r\n                    [\r\n                        discord.utils.get(ctx.guild.roles, id=int(role))\r\n                        for role in (priority_settings or {}).get(\"mentioned_roles\")\r\n                        or [0]\r\n                    ],\r\n                ),\r\n                (\r\n                    \"Priority Channel\",\r\n                    [\r\n                        (\r\n                            discord.utils.get(ctx.guild.channels, id=channel)\r\n                            if (\r\n                                channel := ((priority_settings or {}).get(\"channel_id\"))\r\n                            )\r\n                            else 0\r\n                        )\r\n                    ],\r\n                ),\r\n            ],\r\n        )\r\n\r\n        pages = []\r\n\r\n        for index, view in enumerate(\r\n            [\r\n                basic_settings_view,\r\n                loa_configuration_view,\r\n                shift_management_view,\r\n                ra_view,\r\n                roblox_punishments,\r\n                security_view,\r\n                logging_view,\r\n                antiping_view,\r\n                erlc_view,\r\n                erm_command_log_view,\r\n                priority_requests,\r\n            ]\r\n        ):\r\n            corresponding_embeds = [\r\n                discord.Embed(\r\n                    title=\"Basic Settings\",\r\n                    description=(\r\n                        \"**Staff Role:** A staff role is the role that is going to be able to use most ERM commands. You'd assign this role to the people you want to be able to use ERM's core functionalities.\\n\\n\"\r\n                        \"**Admin Role:** An admin role is the role that can manage LOAs, RAs & other peoples' shifts but it can not use server manage and config.\\n\\n\"\r\n                        \"**Management Role:** A management role is the roles of your server management members. These people will be able to delete punishments, modify people's shift time, and accept LOA Requests.\\n\\n\"\r\n                        \"**Prefix:** This will be a prefix you are able to use instead of our slash command system. You can use this prefix to execute commands slightly faster and to take advantage of some extra features.\"\r\n                    ),\r\n                    color=blank_color,\r\n                ),\r\n                discord.Embed(\r\n                    title=\"LOA Requests\",\r\n                    description=(\r\n                        \"**Enabled:** This setting enables or disables the LOA Requests module. When enabled, this allows your staff members to fill out Leave of Absence requests for your management members to approve.\\n\\n\"\r\n                        \"**LOA Role:** This role is given to those who are on Leave of Absence, and is removed when they go off Leave of Absence.\\n\\n\"\r\n                        \"**LOA Channel:** This channel will be where Leave of Absence requests will be logged, and where they will be accepted or denied. Make sure this is a channel that Management members can see, so that they can approve LOA requests.\"\r\n                    ),\r\n                    color=blank_color,\r\n                ),\r\n                discord.Embed(\r\n                    title=\"Shift Management\",\r\n                    description=(\r\n                        \"**What is Shift Management?** The Shift Management module allows for staff members to log how much time they were in-game, or moderating, or on as a staff member. It allows for a comprehensive guide of who is the most active in your staff team.\\n\\n\"\r\n                        \"**Enabled:** When enabled, staff members will be able to run `/duty` commands to manage their shift, see how much time they have, as well as see how much time other people have. Management members will be able to administrate people's shifts, add time, remove time, and clear people's shifts.\\n\\n\"\r\n                        \"**Shift Channel:** This is where all shift logs will go to. This channel will be used for all modifications to shifts, any person that may be starting or ending their shift.\\n\\n\"\r\n                        \"**On-Duty Role:** When someone is on shift, they will be given this role. When the staff member goes off shift, this role will be removed from them.\"\r\n                    ),\r\n                    color=blank_color,\r\n                ),\r\n                discord.Embed(\r\n                    title=\"RA Requests\",\r\n                    description=(\r\n                        \"**What are RA Requests?** RA Requests, also called Reduced Activity Requests, are a form of Leave of Absence where the staff member isn't required to complete the full quota, but expects that they will be able to complete it partially.\\n\\n\"\r\n                        \"**RA Role:** This role is given to those who are on Reduced Activity, and is removed when they go off Reduced Activity.\\n\\n\"\r\n                    ),\r\n                    color=blank_color,\r\n                ),\r\n                discord.Embed(\r\n                    title=\"ROBLOX Punishments\",\r\n                    description=(\r\n                        \"**What is the ROBLOX Punishments module?** The ROBLOX Punishments module allows for members of your Staff Team to log punishments against a ROBLOX player using ERM! You can specify custom types of punishments, where they will go, as well as manage and search individual punishments.\\n\\n\"\r\n                        \"**Enabled:** This setting toggles the ROBLOX Punishments module. When enabled, staff members will be able to use `/punish`, and management members will be able to additionally use `/punishment manage`.\\n\\n\"\r\n                        \"**Punishments Channel:** This is where most punishments made with the ROBLOX Punishments go. Any logged actions of a ROBLOX player will go to this channel.\"\r\n                    ),\r\n                    color=blank_color,\r\n                ),\r\n                discord.Embed(\r\n                    title=\"Game Security\",\r\n                    description=(\r\n                        \"**What is the Game Security module?** As of right now, this module only applies to private servers of Emergency Response: Liberty County. This module aims to protect and secure private servers by detecting if a staff member runs a potentially abusive command, and notifying management of this incident.\\n\\n\"\r\n                        \"**Enabled:** Game Security is a module that aims to protect private servers from abuse of administrative privileges. This only works for particular games and servers. You should disable this if you aren't a game listed above.\\n\\n\"\r\n                        \"**Webhook Channel:** This channel is where the bot will read the webhooks from the game server. This is not where alerts will be sent. Rather, this is where the bot will detect any admin abuse.\\n\\n\"\r\n                        \"**Alert Channel:** This channel is where the bot will send the corresponding alerts for abuse of administrative privileges in your private server. It is recommended for this not to be the same as your Webhook Channel so that you don't miss any unresolved Security Alerts.\\n\\n\"\r\n                        \"**Mentionables:** These roles will be mentioned when a security alert is sent by ERM. All of these roles will be mentioned in the message, and they should be able to deal with the situation at hand for maximum staff efficiency.\"\r\n                    ),\r\n                    color=blank_color,\r\n                ),\r\n                discord.Embed(\r\n                    title=\"Game Logging\",\r\n                    color=blank_color,\r\n                    description=(\r\n                        \"**What is Game Logging?** Game Logging is an ERM module, particularly tailored towards private servers of Emergency Response: Liberty County, but can apply to other roleplay games in a similar genre. Game Logging allows for staff members to log events of interest, such as custom in-game messages, priority timers, as well as STS events. This allows for streamlined management of staff efficiency.\\n\\n\"\r\n                        \"### Message Logging\\n\\n\"\r\n                        \"**Enabled:** This dictates whether the in-game message section of the Game Logging module is enabled. This part of the module automatically and allows for manual logs of in-game messages and 'hints' so that management can effectively see if staff members are sending the correct amount of notifications.\\n\\n\"\r\n                        \"**Message Logging Channel:** This channel will be where these message and notification logs will be sent to.\\n\\n\"\r\n                        \"### STS Logging\\n\\n\"\r\n                        \"**Enabled:** This dictates whether the Shoulder-to-Shoulder event logging section of the Game Logging module is enabled. When enabled, staff members can log the duration of their events, as well as who hosted them and other important information.\\n\\n\"\r\n                        \"**STS Logging Channel:** This is where the event logs for Shoulder-to-Shoulder events will appear. Management members will be able to see all relevant information of an STS here.\\n\\n\"\r\n                        \"### Priority Logging\\n\\n\"\r\n                        \"**Enabled:** This section of the Game Logging module, correspondingly named the Priority Logging part, allows for staff members to log Priority Timer events, their reason, duration, as well as any notable information which may be necessary for management members.\\n\\n\"\r\n                        \"**Priority Logging Channel:** This channel will be where priority timer events and event notifications will be logged accordingly for management members to view.\"\r\n                    ),\r\n                ),\r\n                discord.Embed(\r\n                    title=\"Anti-Ping\",\r\n                    color=blank_color,\r\n                    description=(\r\n                        \"**What is Anti-Ping?** Anti-ping is an ERM module which specialises in preventing mention abuse of High Ranks within a Discord server. ERM detects if an unauthorized individual mentions a High Ranking individual, and notifies them to discontinue any further attempts to violate the server's regulations.\\n\\n\"\r\n                        \"**Enabled:** This setting dictates whether ERM will take action upon these users, and intervene when necessary. When disabled, the Anti-Ping module will not activate.\\n\\n\"\r\n                        \"**Affected Roles:** These roles clarify the individuals who are affected by Anti-Ping, and are classed as important individuals to ERM. An individual who pings someone with these affected roles, will activate Anti-Ping.\\n\\n\"\r\n                        \"**Bypass Roles:** An individual who holds one of these roles will not be able to trigger Anti-Ping filters, and will be able to ping any individual within the Affected Roles list without ERM intervening.\\n\\n\"\r\n                        \"**Use Hierarchy:** This setting dictates whether Anti-Ping will take into account role hierarchy for each of the affected roles. For example, if you set Moderation as an affected role, it would also apply for all roles above Moderation, such as Administration or Management.\"\r\n                    ),\r\n                ),\r\n                discord.Embed(\r\n                    title=\"ER:LC Integration\",\r\n                    color=blank_color,\r\n                    description=(\r\n                        \"**What is the ER:LC Integration?** ER:LC Integration allows for ERM to communicate with the Police Roleplay Community APIs, and your Emergency Response: Liberty County server. In particular, these configurations allow for Join Logs, Leave Logs, and Kill Logs to be logged.\\n\\n\"\r\n                        \"**Elevation Required:** This setting dictates whether elevated permissions are required to run commands such as `:admin` and `:unadmin`. In such case where this is enabled, Co-Owner permissions are required to run these commands to prevent security risk. If disabled, those with the Management Roles in your server can run these commands. **It is advised you keep this enabled unless you have a valid reason to turn it off.** Contact ERM Support if you are unsure what this setting does.\\n\\n\"\r\n                        \"**Player Logs Channel:** This channel is where Player Join and Leave logs will be sent by ERM. ERM will check your server every 45 seconds to see if new members have joined or left, and report of their time accordingly.\\n\\n\"\r\n                        \"**Kill Logs Channel:** This setting is where Kill Logs will be sent by ERM. ERM will check your server every 45 seconds and constantly contact your ER:LC private server to know if there are any new kill logs. If there are, to log them in the corresponding channel.\"\r\n                    ),\r\n                ),\r\n                discord.Embed(\r\n                    title=\"ERM Logging\",\r\n                    color=blank_color,\r\n                    description=(\r\n                        \"**ERM Log Channel:** This channel is where ERM will log all administrative commands and configuration changes made by Admin & Management Roles. This is useful for auditing purposes, ensuring transparency, and detecting any potential abuse of administrative privileges. This is a critical part of ERM and should be enabled for all servers using ERM.\\n\\n\"\r\n                        \"All commands such as Duty Admin, LOA Admin, RA Admin, Server Manage, Config, etc., as well as nearly all configuration changes, will be logged in this channel.\"\r\n                    ),\r\n                ),\r\n                discord.Embed(\r\n                    title=\"Priority Requests\",\r\n                    color=blank_color,\r\n                    description=(\r\n                        \"**Blacklisted Roles:** These are the roles which are unable to use the ERM Priority Request system. They will not be able to submit priority requests if they have any of these roles.\\n\\n\"\r\n                        \"**Mentioned Roles:** When a priority request is submitted, these roles will be mentioned in the accompanying message advising staff in regards to the priority request.\\n\\n\"\r\n                        \"**Priority Channel:** This channel will be where priority requests are submitted, and where the message advising staff in regards to the priority request will be sent.\"\r\n                    ),\r\n                ),\r\n            ]\r\n            embed = corresponding_embeds[index]\r\n            page = CustomPage()\r\n            page.embeds = [embed]\r\n            page.identifier = embed.title\r\n            page.view = view\r\n\r\n            pages.append(page)\r\n\r\n        paginator = SelectPagination(self.bot, ctx.author.id, pages)\r\n        try:\r\n            await ctx.send(embeds=pages[0].embeds, view=paginator.get_current_view())\r\n        except discord.HTTPException:\r\n            await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Critical Error\",\r\n                    description=\"Configuration error; 827\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n    @commands.hybrid_group(\r\n        name=\"server\",\r\n        description=\"This is a namespace for commands relating to the Server Management functionality\",\r\n        extras={\"category\": \"Configuration\"},\r\n    )\r\n    async def server(self, ctx: commands.Context):\r\n        pass\r\n\r\n    @commands.guild_only()\r\n    @server.command(\r\n        name=\"manage\",\r\n        description=\"Manage your server's ERM data!\",\r\n        extras={\"category\": \"Configuration\"},\r\n    )\r\n    @is_management()\r\n    @require_settings()\r\n    async def server_management(self, ctx: commands.Context):\r\n        await log_command_usage(self.bot, ctx.guild, ctx.author, f\"Server Manage\")\r\n\r\n        embeds = [\r\n            discord.Embed(\r\n                title=\"Introduction\",\r\n                description=(\r\n                    \"This **Server Management Panel** allows individuals who have access to it, to manage your data regarding ERM on your server. This contains any of the data contained within the 3 main modules, which are Activity Notices, ROBLOX Punishments, and Shift Logging.\\n\\n\"\r\n                    \"Using this panel, you can clear certain parts of data, or erase the data of a particular module in its entirety. For some modules, you can also erase its data by a particular specification - such as removing all punishments from a punishment type.\\n\\n\"\r\n                    \"Members with **Management** permissions can access this panel, and erase your server's data, so ensure you only give this access to people who you trust. As with particular parts of this panel, some actions are reversible when contacting ERM Support.\"\r\n                ),\r\n                color=BLANK_COLOR,\r\n            ).set_author(name=ctx.guild.name, icon_url=ctx.guild.icon),\r\n            discord.Embed(\r\n                title=\"Activity Notices\",\r\n                description=(\r\n                    \"Activity Notices allow for routine and robust staff management and administration, with the implementation of Leave of Absence requests and Reduced Activity requests. Staff members can request for one of these facilities, and Management can approve and deny on a case-by-case basis.\\n\\n\"\r\n                    \"Using this panel, you can perform 3 actions. You can **Erase Pending Requests** to remove all ongoing Activity Notice requests. You can also **Erase LOA Notices** and **Erase RA Notices** to erase their correspondent activity notices. **These will not automatically remove the LOA or RA roles, as these actions only erase these notices from our database.**\"\r\n                ),\r\n                color=BLANK_COLOR,\r\n            ).set_author(name=ctx.guild.name, icon_url=ctx.guild.icon),\r\n            discord.Embed(\r\n                title=\"ROBLOX Punishments\",\r\n                description=(\r\n                    \"ROBLOX Punishments allow for staff members to log their punishments on the ROBLOX platform using ERM. ERM allows a robust experience for a staff member utilising this module, as commands are easy to learn and execute, as well as to effectively be implemented into a staff member's workflow.\\n\\n\"\r\n                    \"Using this panel, you can **Erase All Punishments**, as well as **Erase Punishments By Type** and **Erase Punishments By Username**.\"\r\n                ),\r\n                color=BLANK_COLOR,\r\n            ).set_author(name=ctx.guild.name, icon_url=ctx.guild.icon),\r\n            discord.Embed(\r\n                title=\"Shift Logging\",\r\n                description=(\r\n                    'Shift Logging allow for an easy experience for staff members looking to log their active shift time using ERM. Staff members can run simple commands to go \"on-duty\", as well as go on break to signify unavailability. Once they are ready, they can go \"off-duty\" to signify that they are no longer available for any administrative action.\\n\\n'\r\n                    \"Using this panel, you can **Erase All Shifts**, as well as utilise **Erase Past Shifts** and **Erase Active Shifts**. You can also **Erase Shifts By Type**.\"\r\n                ),\r\n                color=BLANK_COLOR,\r\n            ).set_author(name=ctx.guild.name, icon_url=ctx.guild.icon),\r\n        ]\r\n        views = [\r\n            discord.ui.View(),\r\n            ActivityNoticeManagement(self.bot, ctx.author.id),\r\n            PunishmentManagement(self.bot, ctx.author.id),\r\n            ShiftLoggingManagement(self.bot, ctx.author.id),\r\n        ]\r\n\r\n        paginator = SelectPagination(\r\n            self.bot,\r\n            ctx.author.id,\r\n            [\r\n                CustomPage(embeds=[embed], identifier=embed.title, view=view)\r\n                for embed, view in zip(embeds, views)\r\n            ],\r\n        )\r\n\r\n        await ctx.send(embed=embeds[0], view=paginator.get_current_view())\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(Configuration(bot))\r\n"}
{"type": "source_file", "path": "cogs/ShiftLogging.py", "content": "import datetime\nfrom io import BytesIO\nimport logging\n\nimport discord\nimport pytz\nfrom decouple import config\nfrom discord import app_commands\nfrom discord.ext import commands\n\nfrom datamodels.ShiftManagement import ShiftItem\nfrom erm import (\n    credentials_dict,\n    is_management,\n    is_staff,\n    is_admin,\n    management_predicate,\n    scope,\n)\nfrom menus import (\n    CustomExecutionButton,\n    CustomSelectMenu,\n    RequestGoogleSpreadsheet,\n    ShiftMenu,\n    AdministratedShiftMenu,\n)\nfrom utils.autocompletes import shift_type_autocomplete, all_shift_type_autocomplete\nfrom utils.constants import BLANK_COLOR, GREEN_COLOR, ORANGE_COLOR, RED_COLOR\nfrom utils.paginators import SelectPagination, CustomPage\nfrom utils.timestamp import td_format\nfrom utils.utils import (\n    get_elapsed_time,\n    new_failure_embed,\n    require_settings,\n    log_command_usage,\n)\n\n\nclass ShiftLogging(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n\n    @commands.hybrid_group(name=\"duty\")\n    async def duty(self, ctx):\n        pass\n\n    @commands.guild_only()\n    @duty.command(\n        name=\"time\",\n        description=\"Allows for you to check your shift time, as well as your past data.\",\n        extras={\"category\": \"Shift Management\"},\n        with_app_command=True,\n    )\n    @is_staff()\n    @require_settings()\n    async def duty_time(self, ctx, member: discord.Member = None):\n        if self.bot.shift_management_disabled is True:\n            return await new_failure_embed(\n                ctx,\n                \"Maintenance\",\n                \"This command is currently disabled as ERM is currently undergoing maintenance updates. This command will be turned off briefly to ensure that no data is lost during the maintenance.\",\n            )\n\n        bot = self.bot\n        if not member:\n            member = ctx.author\n\n        configItem = await bot.settings.find_by_id(ctx.guild.id)\n\n        if not configItem[\"shift_management\"][\"enabled\"]:\n            return await new_failure_embed(\n                ctx, \"Not Enabled\", \"Shift Logging is not enabled on this server.\"\n            )\n\n        embed = discord.Embed(\n            title=(\n                f\"Total Shifts\"\n                if member == ctx.author\n                else f\"{member.name}'s Total Shifts\"\n            ),\n            color=BLANK_COLOR,\n        )\n        embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n\n        # Get current shift\n        shift = None\n        shift_data = await bot.shift_management.get_current_shift(member, ctx.guild.id)\n        if shift_data:\n            if shift_data[\"Guild\"] == ctx.guild.id:\n                shift = shift_data\n\n        # Get all past shifts\n        shifts = []\n        storage_item = [\n            i\n            async for i in bot.shift_management.shifts.db.find(\n                {\"UserID\": member.id, \"Guild\": ctx.guild.id}\n            )\n        ]\n\n        for s in storage_item:\n            if s[\"EndEpoch\"] != 0:\n                shifts.append(s)\n\n        total_seconds = sum([get_elapsed_time(i) for i in shifts])\n        sorted_roles = sorted(member.roles, key=lambda x: x.position)\n        selected_quota = 0\n        specified_quota_roles = configItem.get(\"shift_management\", {}).get(\n            \"role_quotas\", []\n        )\n        for role in sorted_roles:\n            # print(role)\n            # print(specified_quota_roles)\n            if role.id in [t[\"role\"] for t in specified_quota_roles]:\n                found_item = [t for t in specified_quota_roles if t[\"role\"] == role.id][\n                    0\n                ]\n                selected_quota = found_item[\"quota\"]\n\n        if selected_quota == 0:\n            selected_quota = configItem.get(\"shift_management\").get(\"quota\", 0)\n\n        met_quota = None\n        if selected_quota != 0:\n            met_quota = bool(total_seconds > selected_quota)\n\n        try:\n            if shift:\n                embed.add_field(\n                    name=\"Ongoing Shift\",\n                    value=f\"{td_format(datetime.timedelta(seconds=get_elapsed_time(shift)))}\",\n                    inline=False,\n                )\n        except OverflowError:\n            if shift:\n                embed.add_field(\n                    name=\"Ongoing Shift\",\n                    value=\"Could not display current shift time.\",\n                    inline=False,\n                )\n\n        newline = \"\\n\"\n        embed.add_field(\n            name=f\"Shift Time [{len(shifts)}]\",\n            value=f\"{td_format(datetime.timedelta(seconds=total_seconds))} {'{0}*{1}*'.format(newline, 'Met Quota' if met_quota is True else 'Not Met Quota') if met_quota is not None else ''}\",\n        )\n\n        embed.set_thumbnail(url=member.display_avatar.url)\n        await ctx.reply(\n            embed=embed,\n        )\n\n    @duty.command(\n        name=\"admin\",\n        description=\"Allows for you to administrate someone else's shift\",\n        extras={\"category\": \"Shift Management\"},\n    )\n    @require_settings()\n    @is_admin()\n    @app_commands.autocomplete(type=shift_type_autocomplete)\n    async def duty_admin(\n        self, ctx, member: discord.Member, type: str = \"Default\", force: str = \"false\"\n    ):\n        if self.bot.shift_management_disabled is True:\n            return await new_failure_embed(\n                ctx,\n                \"Maintenance\",\n                \"This command is currently disabled as ERM is currently undergoing maintenance updates. This command will be turned off briefly to ensure that no data is lost during the maintenance.\",\n            )\n\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\n        if not settings.get(\"shift_management\", {}).get(\"enabled\", False):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Enabled\",\n                    description=\"Shift Logging is not enabled on this server.\",\n                    color=BLANK_COLOR,\n                )\n            )\n        msg = None\n        shift_types = settings.get(\"shift_types\", {}).get(\"types\", [])\n        if shift_types:\n            if type.lower() not in [t[\"name\"].lower() for t in shift_types]:\n                msg = await ctx.send(\n                    embed=discord.Embed(\n                        title=\"Incorrect Shift Type\",\n                        description=\"The shift type provided is not valid.\",\n                        color=BLANK_COLOR,\n                    ),\n                    view=(\n                        view := CustomSelectMenu(\n                            ctx.author.id,\n                            [\n                                discord.SelectOption(\n                                    label=i[\"name\"],\n                                    value=i[\"name\"],\n                                    description=i[\"name\"],\n                                )\n                                for i in shift_types\n                            ],\n                        )\n                    ),\n                )\n                timeout = await view.wait()\n                if timeout:\n                    return\n\n                if view.value:\n                    type = view.value\n\n            shift_type_item = None\n            for item in shift_types:\n                if item[\"name\"].lower() == type.lower():\n                    shift_type_item = item\n\n            if shift_type_item:\n                if shift_type_item.get(\"access_roles\") is not None:\n                    item = shift_type_item\n                    access_roles = item.get(\"access_roles\") or []\n                    if len(access_roles) > 0:\n                        access = False\n                        for role in access_roles:\n                            if role in [i.id for i in member.roles]:\n                                access = True\n                                break\n                        if access is False and force.lower() != \"true\":\n                            if not msg:\n                                return await ctx.send(\n                                    embed=discord.Embed(\n                                        title=\"Access Denied\",\n                                        description=\"This individual does not have access to this shift type.\",\n                                        color=BLANK_COLOR,\n                                    )\n                                )\n                            else:\n                                return await msg.edit(\n                                    embed=discord.Embed(\n                                        title=\"Access Denied\",\n                                        description=\"This individual does not have access to this shift type.\",\n                                        color=BLANK_COLOR,\n                                    ),\n                                    view=None,\n                                )\n                        elif access is False and force.lower() == \"true\":\n                            pass\n\n        shift = await self.bot.shift_management.get_current_shift(member, ctx.guild.id)\n        await log_command_usage(\n            self.bot, ctx.guild, ctx.author, f\"Duty Admin for {member.name}\"\n        )\n        previous_shifts = [\n            i\n            async for i in self.bot.shift_management.shifts.db.find(\n                {\"UserID\": member.id, \"Guild\": ctx.guild.id, \"EndEpoch\": {\"$ne\": 0}}\n            )\n        ]\n        embed = discord.Embed(color=BLANK_COLOR)\n\n        embed.add_field(\n            name=\"Current Statistics\",\n            value=(\n                f\"> **Total Shift Duration:** {td_format(datetime.timedelta(seconds=sum([get_elapsed_time(item) for item in previous_shifts])))}\\n\"\n                f\"> **Total Shifts:** {len(previous_shifts)}\\n\"\n                f\"> **Average Shift Duration:** {td_format(datetime.timedelta(seconds=(sum([get_elapsed_time(item) for item in previous_shifts]).__truediv__(len(previous_shifts) or 1))))}\\n\"\n            ),\n            inline=False,\n        )\n\n        embed.set_author(\n            name=ctx.guild.name,\n            icon_url=ctx.guild.icon,\n        )\n\n        if shift:\n            if (shift.get(\"Breaks\", [{}]) or [{}])[-1].get(\"EndEpoch\", 1) == 0:\n                status = \"break\"\n            else:\n                status = \"on\"\n        else:\n            status = \"off\"\n\n        contained_document = None\n        if status == \"on\":\n            contained_document: ShiftItem = await self.bot.shift_management.fetch_shift(\n                shift[\"_id\"]\n            )\n            embed.colour = GREEN_COLOR\n            embed.add_field(\n                name=\"Current Shift\",\n                value=(\n                    f\"> **Started:** <t:{int(contained_document.start_epoch)}:R>\\n\"\n                    f\"> **Breaks:** {len(contained_document.breaks)}\\n\"\n                    f\"> **Elapsed Time:** {td_format(datetime.timedelta(seconds=get_elapsed_time(shift)))}\"\n                ),\n                inline=False,\n            )\n            embed.title = (\n                f\"{self.bot.emoji_controller.get_emoji('ShiftStarted')} **On-Duty**\"\n            )\n        elif status == \"break\":\n            contained_document: ShiftItem = await self.bot.shift_management.fetch_shift(\n                shift[\"_id\"]\n            )\n\n            current_break = None\n            for break_item in contained_document.breaks:\n                if break_item.end_epoch == 0:\n                    current_break = break_item\n                    break\n\n            if current_break:\n                break_start_time = (\n                    f\"> **Break Started:** <t:{int(current_break.start_epoch)}:R>\\n\"\n                )\n            else:\n                break_start_time = \"> **Break Started:** No ongoing break\\n\"\n\n            embed.colour = ORANGE_COLOR\n            embed.add_field(\n                name=\"Current Shift\",\n                value=(\n                    f\"> **Shift Started:** <t:{int(contained_document.start_epoch)}:R>\\n\"\n                    f\"{break_start_time}\"\n                    f\"> **Breaks:** {len(contained_document.breaks)}\\n\"\n                    f\"> **Elapsed Time:** {td_format(datetime.timedelta(seconds=get_elapsed_time(shift)))}\"\n                ),\n                inline=False,\n            )\n            embed.title = (\n                f\"{self.bot.emoji_controller.get_emoji('ShiftBreak')} **On-Break**\"\n            )\n        else:\n            embed.colour = RED_COLOR\n            embed.title = (\n                f\"{self.bot.emoji_controller.get_emoji('ShiftEnded')} **Off-Duty**\"\n            )\n        try:\n            view = AdministratedShiftMenu(\n                self.bot,\n                status,\n                ctx.author.id,\n                member.id,\n                (shift_type_item or {}).get(\"name\") or type,\n                shift,\n                contained_document,\n            )\n        except UnboundLocalError:\n            view = AdministratedShiftMenu(\n                self.bot,\n                status,\n                ctx.author.id,\n                member.id,\n                type,\n                shift,\n                contained_document,\n            )\n\n        if not msg:\n            view.message = await ctx.send(embed=embed, view=view)\n        else:\n            await msg.edit(embed=embed, view=view)\n            view.message = msg\n\n    @commands.guild_only()\n    @duty.command(\n        name=\"manage\",\n        description=\"Manage your own shift in an easy way!\",\n        extras={\"category\": \"Shift Management\"},\n    )\n    @is_staff()\n    @require_settings()\n    @app_commands.autocomplete(type=shift_type_autocomplete)\n    async def duty_manage(self, ctx, *, type: str = \"Default\"):\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\n        if not settings.get(\"shift_management\", {}).get(\"enabled\", False):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Enabled\",\n                    description=\"Shift Logging is not enabled on this server.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        shift_types = settings.get(\"shift_types\", {}).get(\"types\", [])\n        msg = None\n        shift_type_item = None\n        if shift_types:\n            if type.lower() not in [t[\"name\"].lower() for t in shift_types]:\n                msg = await ctx.send(\n                    embed=discord.Embed(\n                        title=\"Incorrect Shift Type\",\n                        description=\"The shift type provided is not valid.\",\n                        color=BLANK_COLOR,\n                    ),\n                    view=(\n                        view := CustomSelectMenu(\n                            ctx.author.id,\n                            [\n                                discord.SelectOption(\n                                    label=i[\"name\"],\n                                    value=i[\"name\"],\n                                    description=i[\"name\"],\n                                )\n                                for i in shift_types\n                            ],\n                        )\n                    ),\n                )\n                timeout = await view.wait()\n                if timeout:\n                    return\n\n                if view.value:\n                    type = view.value\n\n            for item in shift_types:\n                if item[\"name\"].lower() == type.lower():\n                    shift_type_item = item\n\n            if shift_type_item:\n                if shift_type_item.get(\"access_roles\") is not None:\n                    item = shift_type_item\n                    access_roles = item.get(\"access_roles\") or []\n                    if len(access_roles) > 0:\n                        access = False\n                        for role in access_roles:\n                            if role in [i.id for i in ctx.author.roles]:\n                                access = True\n                                break\n                        if access is False:\n                            if not msg:\n                                return await ctx.send(\n                                    embed=discord.Embed(\n                                        title=\"Access Denied\",\n                                        description=\"You do not have access to this shift type.\",\n                                        color=BLANK_COLOR,\n                                    )\n                                )\n                            else:\n                                return await msg.edit(\n                                    embed=discord.Embed(\n                                        title=\"Access Denied\",\n                                        description=\"You do not have access to this shift type.\",\n                                        color=BLANK_COLOR,\n                                    ),\n                                    view=None,\n                                )\n\n        if self.bot.shift_management_disabled is True:\n            return await new_failure_embed(\n                ctx,\n                \"Maintenance\",\n                \"This command is currently disabled as ERM is currently undergoing maintenance updates. This command will be turned off briefly to ensure that no data is lost during the maintenance.\",\n            )\n        try:\n            maximum_staff = settings.get(\"shift_management\", {}).get(\"maximum_staff\", 0)\n            # print(f\"Maximum Staff: {maximum_staff}\")\n        except AttributeError:\n            # print(\"Attribute Error\")\n            return\n\n        try:\n            on_duty_staff = await self.bot.shift_management.shifts.db.count_documents(\n                {\"Guild\": ctx.guild.id, \"EndEpoch\": 0}\n            )\n            # print(f\"Staff on Duty: {on_duty_staff}\")\n        except AttributeError:\n            # print(\"Attribute Error\")\n            return\n        # if author is on duty then bypass the limit\n        shift_zero = [\n            i\n            async for i in self.bot.shift_management.shifts.db.find(\n                {\"Guild\": ctx.guild.id, \"EndEpoch\": 0, \"UserID\": ctx.author.id}\n            )\n        ]\n\n        if len(shift_zero) == 0:\n            if (on_duty_staff) >= (maximum_staff or 0) and (maximum_staff or 0) != 0:\n                return await ctx.send(\n                    embed=discord.Embed(\n                        title=\"Staff Limit Reached\",\n                        description=\"The maximum amount of staff members on duty has been reached.\",\n                        color=BLANK_COLOR,\n                    )\n                )\n\n        shift = await self.bot.shift_management.get_current_shift(\n            ctx.author, ctx.guild.id\n        )\n        # view = ModificationSelectMenu(ctx.author.id)\n        previous_shifts = [\n            i\n            async for i in self.bot.shift_management.shifts.db.find(\n                {\"UserID\": ctx.author.id, \"Guild\": ctx.guild.id, \"EndEpoch\": {\"$ne\": 0}}\n            )\n        ]\n        embed = discord.Embed(color=BLANK_COLOR)\n\n        embed.add_field(\n            name=\"Current Statistics\",\n            value=(\n                f\"> **Total Shift Duration:** {td_format(datetime.timedelta(seconds=sum([get_elapsed_time(item) for item in previous_shifts])))}\\n\"\n                f\"> **Total Shifts:** {len(previous_shifts)}\\n\"\n                f\"> **Average Shift Duration:** {td_format(datetime.timedelta(seconds=(sum([get_elapsed_time(item) for item in previous_shifts]).__truediv__(len(previous_shifts) or 1))))}\\n\"\n            ),\n            inline=False,\n        )\n\n        embed.set_author(\n            name=ctx.guild.name,\n            icon_url=ctx.guild.icon,\n        )\n\n        if shift:\n            if (shift.get(\"Breaks\", [{}]) or [{}])[-1].get(\"EndEpoch\", 1) == 0:\n                status = \"break\"\n            else:\n                status = \"on\"\n        else:\n            status = \"off\"\n\n        contained_document = None\n        if status == \"on\":\n            contained_document: ShiftItem = await self.bot.shift_management.fetch_shift(\n                shift[\"_id\"]\n            )\n            embed.colour = GREEN_COLOR\n            embed.add_field(\n                name=\"Current Shift\",\n                value=(\n                    f\"> **Started:** <t:{int(contained_document.start_epoch)}:R>\\n\"\n                    f\"> **Breaks:** {len(contained_document.breaks)}\\n\"\n                    f\"> **Elapsed Time:** {td_format(datetime.timedelta(seconds=get_elapsed_time(shift)))}\"\n                ),\n                inline=False,\n            )\n            embed.title = (\n                f\"{self.bot.emoji_controller.get_emoji('ShiftStarted')} **On-Duty**\"\n            )\n        elif status == \"break\":\n            print(\"On Break status called\")\n            contained_document: ShiftItem = await self.bot.shift_management.fetch_shift(\n                shift[\"_id\"]\n            )\n\n            logging.info(f\"All Breaks: {contained_document.breaks}\")\n\n            current_break = None\n            for break_item in contained_document.breaks:\n                logging.info(\n                    f\"Checking break: {break_item}\"\n                )  # Debugging log to print each break\n                if (\n                    break_item.end_epoch == 0\n                ):  # Assuming end_epoch is 0 if the break hasn't ended yet\n                    current_break = break_item\n                    break\n\n            if current_break:\n                break_start_time = (\n                    f\"> **Break Started:** <t:{int(current_break.start_epoch)}:R>\\n\"\n                )\n            else:\n                break_start_time = \"> **Break Started:** No ongoing break\\n\"\n            embed.colour = ORANGE_COLOR\n            embed.add_field(\n                name=\"Current Shift\",\n                value=(\n                    f\"> **Shift Started:** <t:{int(contained_document.start_epoch)}:R>\\n\"\n                    f\"{break_start_time}\"\n                    f\"> **Breaks:** {len(contained_document.breaks)}\\n\"\n                    f\"> **Elapsed Time:** {td_format(datetime.timedelta(seconds=get_elapsed_time(shift)))}\"\n                ),\n                inline=False,\n            )\n            embed.title = (\n                f\"{self.bot.emoji_controller.get_emoji('ShiftBreak')} **On-Break**\"\n            )\n        else:\n            embed.colour = RED_COLOR\n            embed.title = (\n                f\"{self.bot.emoji_controller.get_emoji('ShiftEnded')} **Off-Duty**\"\n            )\n\n        view = ShiftMenu(\n            self.bot,\n            status,\n            ctx.author.id,\n            shift_type_item[\"name\"] if shift_type_item else type,\n            starting_document=shift,\n            starting_container=contained_document,\n        )\n\n        if not msg:\n            view.message = await ctx.send(embed=embed, view=view)\n        else:\n            await msg.edit(embed=embed, view=view)\n            view.message = msg\n\n    @duty.command(\n        name=\"active\",\n        description=\"Get all members of the server currently on shift.\",\n        extras={\"category\": \"Shift Management\"},\n    )\n    @require_settings()\n    @app_commands.autocomplete(type=all_shift_type_autocomplete)\n    @is_staff()\n    async def duty_active(self, ctx: commands.Context, *, type: str = None):\n        if self.bot.shift_management_disabled is True:\n            return await new_failure_embed(\n                ctx,\n                \"Maintenance\",\n                \"This command is currently disabled as ERM is currently undergoing maintenance updates. This command will be turned off briefly to ensure that no data is lost during the maintenance.\",\n            )\n\n        bot = self.bot\n        configItem = await bot.settings.find_by_id(ctx.guild.id)\n        if not configItem.get(\"shift_management\", {}).get(\"enabled\", False):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Enabled\",\n                    description=\"Shift Logging is not enabled on this server.\",\n                )\n            )\n\n        shift_type = None\n        if configItem.get(\"shift_types\"):\n            shift_types = configItem.get(\"shift_types\")\n            if len(shift_types.get(\"types\")) > 1:\n                shift_types = shift_types.get(\"types\")\n\n                view = CustomSelectMenu(\n                    ctx.author.id,\n                    [\n                        discord.SelectOption(\n                            label=i[\"name\"],\n                            value=i[\"name\"],\n                            description=i[\"name\"],\n                        )\n                        for i in shift_types\n                    ]\n                    + [\n                        discord.SelectOption(\n                            label=\"All\",\n                            value=\"all\",\n                            description=\"Data from all shift types\",\n                        )\n                    ],\n                )\n                type_value = (type or \"\").lower()\n                if (\n                    type_value not in [i[\"name\"].lower() for i in shift_types]\n                    and type_value != \"all\"\n                ):\n                    msg = await ctx.reply(\n                        embed=discord.Embed(\n                            title=\"Incorrect Shift Type\",\n                            description=\"The shift type provided is not valid.\",\n                            color=BLANK_COLOR,\n                        ),\n                        view=view,\n                    )\n\n                    timeout = await view.wait()\n                    if timeout:\n                        return\n\n                    type_value = view.value.lower()\n                else:\n                    type_value = type_value.lower()\n\n                if type_value:\n                    if type_value == \"all\":\n                        shift_type = None\n                    else:\n                        shift_type_str = type_value\n                        shift_list = [\n                            i\n                            for i in shift_types\n                            if i[\"name\"].lower() == shift_type_str\n                        ]\n                        if shift_list:\n                            shift_type = shift_list[0]\n                        else:\n                            return await new_failure_embed(\n                                ctx,\n                                \"Critical Error\",\n                                \"if you somehow encounter this error, please contact [ERM Support](https://discord.gg/FAC629TzBy)\",\n                            )\n                else:\n                    return\n\n        embed = discord.Embed(title=\"Active Shifts\", color=BLANK_COLOR)\n        embed.description = f\"**Total Shifts**\"\n        embed.set_author(\n            name=f\"{ctx.guild.name}\",\n            icon_url=ctx.guild.icon,\n        )\n\n        embeds = []\n        embeds.append(embed)\n\n        all_staff = []\n        staff_members = []\n\n        if not shift_type:\n            async for sh in bot.shift_management.shifts.db.find(\n                {\"Guild\": ctx.guild.id, \"EndEpoch\": 0}\n            ):\n                if sh[\"Guild\"] == ctx.guild.id:\n                    member = discord.utils.get(ctx.guild.members, id=sh[\"UserID\"])\n                    if member:\n                        if member not in staff_members:\n                            staff_members.append(member)\n        else:\n            async for shift in bot.shift_management.shifts.db.find(\n                {\"Guild\": ctx.guild.id, \"Type\": shift_type[\"name\"], \"EndEpoch\": 0}\n            ):\n                s = shift\n                member = discord.utils.get(ctx.guild.members, id=shift[\"UserID\"])\n                if member:\n                    if member not in staff_members:\n                        staff_members.append(member)\n\n        for member in staff_members:\n            sh = await bot.shift_management.get_current_shift(member, ctx.guild.id)\n\n            time_delta = datetime.timedelta(seconds=get_elapsed_time(sh))\n\n            break_seconds = 0\n            if \"Breaks\" in sh.keys():\n                for item in sh[\"Breaks\"]:\n                    if item[\"EndEpoch\"] == 0:\n                        break_seconds += (\n                            ctx.message.created_at.replace(tzinfo=pytz.UTC).timestamp()\n                            - item[\"StartEpoch\"]\n                        )\n\n            all_staff.append(\n                {\n                    \"id\": sh[\"UserID\"],\n                    \"total_seconds\": time_delta.total_seconds(),\n                    \"break_seconds\": break_seconds,\n                }\n            )\n\n        sorted_staff = sorted(all_staff, key=lambda x: x[\"total_seconds\"], reverse=True)\n        added_staff = []\n        for index, staff in enumerate(sorted_staff):\n            # # print(staff)\n            member = discord.utils.get(ctx.guild.members, id=staff[\"id\"])\n            if not member:\n                continue\n\n            if (\n                len((embeds[-1].description or \"\").splitlines()) >= 16\n                and member.id not in added_staff\n            ):\n                embed = discord.Embed(title=\"Active Shifts\", color=BLANK_COLOR)\n                embed.description = f\"**Total Shifts**\"\n                embed.set_author(\n                    name=f\"{ctx.guild.name}\",\n                    icon_url=ctx.guild.icon,\n                )\n                added_staff.append(member.id)\n                embeds.append(embed)\n            if member.id not in added_staff:\n                embeds[\n                    -1\n                ].description += f\"\\n**{index+1}.** {member.mention} • {td_format(datetime.timedelta(seconds=staff['total_seconds']))}{(' **(Currently on break: {})**'.format(td_format(datetime.timedelta(seconds=staff['break_seconds'])))) if staff['break_seconds'] > 0 else ''}\"\n\n        paginator = SelectPagination(\n            bot,\n            ctx.author.id,\n            [\n                CustomPage(embeds=[embed], identifier=str(index + 1))\n                for index, embed in enumerate(embeds)\n            ],\n        )\n\n        if len(embeds) == 1:\n            if embeds[0].description == \"**Total Shifts**\":\n                try:\n                    return await msg.edit(\n                        embed=discord.Embed(\n                            title=\"No Active Shifts\",\n                            description=\"No active shifts have been found in this server.\",\n                            color=BLANK_COLOR,\n                        ),\n                        view=None,\n                    )\n                except UnboundLocalError:\n                    return await ctx.send(\n                        embed=discord.Embed(\n                            title=\"No Active Shifts\",\n                            description=\"No active shifts have been found in this server.\",\n                            color=BLANK_COLOR,\n                        )\n                    )\n            try:\n                return await msg.edit(embed=embed, view=None)\n            except UnboundLocalError:\n                return await ctx.reply(embed=embed)\n        try:\n            await msg.edit(embed=embeds[0], view=paginator.get_current_view())\n        except UnboundLocalError:\n            await ctx.reply(embed=embeds[0], view=paginator.get_current_view())\n\n    @commands.guild_only()\n    @duty.command(\n        name=\"leaderboard\",\n        description=\"Get the total time worked for the whole of the staff team.\",\n        extras={\"category\": \"Shift Management\"},\n        aliases=[\"lb\"],\n    )\n    @require_settings()\n    @app_commands.autocomplete(type=all_shift_type_autocomplete)\n    @is_staff()\n    async def shift_leaderboard(self, ctx: commands.Context, *, type: str = None):\n        if self.bot.shift_management_disabled is True:\n            return await new_failure_embed(\n                ctx,\n                \"Maintenance\",\n                \"This command is currently disabled as ERM is currently undergoing maintenance updates. This command will be turned off briefly to ensure that no data is lost during the maintenance.\",\n            )\n\n        bot = self.bot\n        configItem = await bot.settings.find_by_id(ctx.guild.id)\n        if not configItem.get(\"shift_management\", {}).get(\"enabled\", False):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Enabled\",\n                    description=\"Shift Logging is not enabled on this server.\",\n                )\n            )\n\n        shift_type = None\n        msg = None\n        if configItem.get(\"shift_types\"):\n            shift_types = configItem.get(\"shift_types\")\n            if len(shift_types.get(\"types\")) > 1:\n                shift_types = shift_types.get(\"types\")\n\n                view = CustomSelectMenu(\n                    ctx.author.id,\n                    [\n                        discord.SelectOption(\n                            label=i[\"name\"],\n                            value=i[\"name\"],\n                            description=i[\"name\"],\n                        )\n                        for i in shift_types\n                    ]\n                    + [\n                        discord.SelectOption(\n                            label=\"All\",\n                            value=\"all\",\n                            description=\"Data from all shift types\",\n                        )\n                    ],\n                )\n                valid_shift_types = [i[\"name\"].lower() for i in shift_types] + [\"all\"]\n                if not (type or \"\").lower() in valid_shift_types:\n                    msg = await ctx.reply(\n                        embed=discord.Embed(\n                            title=\"Incorrect Shift Type\",\n                            description=\"The shift type provided is not valid.\",\n                            color=BLANK_COLOR,\n                        ),\n                        view=view,\n                    )\n\n                    timeout = await view.wait()\n                    if timeout:\n                        return\n\n                    type_value = view.value\n                else:\n                    type_value = type\n\n                if type_value:\n                    if type_value.lower() == \"all\":\n                        shift_type = 0\n                    else:\n                        shift_type_str = type_value\n                        shift_list = [\n                            i\n                            for i in shift_types\n                            if i[\"name\"].lower() == shift_type_str.lower()\n                        ]\n                        if shift_list:\n                            shift_type = shift_list[0]\n                        else:\n                            return await new_failure_embed(\n                                ctx,\n                                \"Critical Error\",\n                                \"if you somehow encounter this error, please contact [ERM Support](https://discord.gg/FAC629TzBy)\",\n                            )\n                else:\n                    return\n\n        pipeline = [\n            {\"$match\": {\"Guild\": ctx.guild.id, \"EndEpoch\": {\"$ne\": 0}}},\n            {\n                \"$group\": {\n                    \"_id\": \"$UserID\",\n                    \"total_seconds\": {\n                        \"$sum\": {\n                            \"$add\": [\n                                {\"$subtract\": [\"$EndEpoch\", \"$StartEpoch\"]},\n                                \"$AddedTime\",\n                                {\"$multiply\": [\"$RemovedTime\", -1]},\n                            ]\n                        }\n                    },\n                    \"moderations\": {\n                        \"$sum\": {\n                            \"$cond\": [\n                                {\"$isArray\": \"$Moderations\"},\n                                {\"$size\": \"$Moderations\"},\n                                0,\n                            ]\n                        }\n                    },\n                    \"lowest_time\": {\"$min\": \"$StartEpoch\"},\n                    \"breaks\": {\"$push\": \"$Breaks\"},\n                }\n            },\n        ]\n\n        if shift_type != 0 and shift_type is not None:\n            pipeline[0][\"$match\"][\"Type\"] = shift_type[\"name\"]\n\n        all_staff = {}\n        async for doc in bot.shift_management.shifts.db.aggregate(pipeline):\n            total_seconds = doc[\"total_seconds\"]\n\n            # Calculate total break time for the shift\n            total_break_time = 0\n            for break_periods in doc[\"breaks\"]:\n                for break_period in break_periods:\n                    break_start = break_period.get(\"StartEpoch\", 0)\n                    break_end = break_period.get(\"EndEpoch\", 0)\n                    if break_start and break_end:\n                        total_break_time += break_end - break_start\n\n            # Adjust total_seconds by subtracting the break time\n            adjusted_total_seconds = max(total_seconds - total_break_time, 0)\n\n            all_staff[doc[\"_id\"]] = {\n                \"id\": doc[\"_id\"],\n                \"total_seconds\": adjusted_total_seconds,\n                \"moderations\": doc[\"moderations\"],\n                \"lowest_time\": doc[\"lowest_time\"],\n            }\n\n        # Fetch additional moderation data in bulk\n        mod_ids = [\n            staff[\"id\"] for staff in all_staff.values() if staff[\"moderations\"] == 0\n        ]\n        if mod_ids:\n            mod_pipeline = [\n                {\"$match\": {\"ModeratorID\": {\"$in\": mod_ids}, \"Guild\": ctx.guild.id}},\n                {\"$group\": {\"_id\": \"$ModeratorID\", \"mod_count\": {\"$sum\": 1}}},\n            ]\n            async for doc in bot.punishments.db.aggregate(mod_pipeline):\n                if doc[\"_id\"] in all_staff:\n                    all_staff[doc[\"_id\"]][\"moderations\"] = doc[\"mod_count\"]\n\n        if len(all_staff) == 0:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"No Shifts\",\n                    description=\"No shifts have been found in this server.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        sorted_staff = sorted(\n            all_staff.values(), key=lambda x: x[\"total_seconds\"], reverse=True\n        )\n\n        buffer = None\n        embeds = []\n\n        embed = discord.Embed(color=BLANK_COLOR, title=\"Shift Leaderboard\")\n        embed.set_author(\n            name=f\"{ctx.guild.name}\",\n            icon_url=ctx.guild.icon,\n        )\n\n        embeds.append(embed)\n        data = []\n\n        if not sorted_staff:\n            if shift_type != 0 and shift_type is not None:\n                if not msg:\n                    return await ctx.send(\n                        embed=discord.Embed(\n                            title=\"No Shifts\",\n                            description=\"No shifts have been found in this server for this Shift Type.\",\n                            color=BLANK_COLOR,\n                        )\n                    )\n                else:\n                    return await msg.edit(\n                        embed=discord.Embed(\n                            title=\"No Shifts\",\n                            description=\"No shifts have been found in this server for this Shift Type.\",\n                            color=BLANK_COLOR,\n                        )\n                    )\n            else:\n                if not msg:\n                    return await ctx.send(\n                        embed=discord.Embed(\n                            title=\"No Shifts\",\n                            description=\"No shifts have been found in this server.\",\n                            color=BLANK_COLOR,\n                        )\n                    )\n                else:\n                    return await ctx.send(\n                        embed=discord.Embed(\n                            title=\"No Shifts\",\n                            description=\"No shifts have been found in this server.\",\n                            color=BLANK_COLOR,\n                        )\n                    )\n\n        my_data = None\n        member_list = await ctx.guild.chunk()\n        members = {m.id: m for m in member_list}  # Cache guild members\n        total_seconds = 0\n\n        for index, i in enumerate(sorted_staff):\n            member = members.get(i[\"id\"])\n            if member:\n                if member.id == ctx.author.id:\n                    i[\"index\"] = index\n                    my_data = i\n                total_seconds += i[\"total_seconds\"]\n                time_str = td_format(datetime.timedelta(seconds=i[\"total_seconds\"]))\n\n                if buffer is None:\n                    buffer = f\"{member.name} • {time_str}\"\n                else:\n                    buffer += f\"\\n{member.name} • {time_str}\"\n\n                data.append(\n                    [\n                        index + 1,\n                        member.name,\n                        member.top_role.name,\n                        time_str,\n                        i[\"moderations\"],\n                    ]\n                )\n\n                line = f\"**{index + 1}.** {member.mention} • {time_str}\\n\"\n                if (\n                    len((embeds[-1].description or \"\")) + len(line) > 4096\n                    or len((embeds[-1].description or \"\").splitlines()) >= 16\n                ):\n                    new_embed = discord.Embed(\n                        color=BLANK_COLOR, title=\"Shift Leaderboard\"\n                    )\n                    new_embed.set_author(\n                        name=f\"{ctx.guild.name}\", icon_url=ctx.guild.icon\n                    )\n                    new_embed.description = f\"**Total Shifts**\\n{line}\"\n                    embeds.append(new_embed)\n                else:\n                    if embeds[-1].description is None:\n                        embeds[-1].description = f\"**Total Shifts**\\n{line}\"\n                    else:\n                        embeds[-1].description += line\n\n        staff_roles = []\n\n        if configItem[\"staff_management\"].get(\"role\"):\n            if isinstance(configItem[\"staff_management\"][\"role\"], int):\n                staff_roles.append(configItem[\"staff_management\"][\"role\"])\n            elif isinstance(configItem[\"staff_management\"][\"role\"], list):\n                for role in configItem[\"staff_management\"][\"role\"]:\n                    staff_roles.append(role)\n\n        if configItem[\"staff_management\"].get(\"management_role\"):\n            if isinstance(configItem[\"staff_management\"][\"management_role\"], int):\n                staff_roles.append(configItem[\"staff_management\"][\"management_role\"])\n            elif isinstance(configItem[\"staff_management\"][\"management_role\"], list):\n                for role in configItem[\"staff_management\"][\"management_role\"]:\n                    staff_roles.append(role)\n        staff_roles = [ctx.guild.get_role(role) for role in staff_roles]\n        added_staff = []\n\n        for role in staff_roles.copy():\n            if role is None:\n                staff_roles.remove(role)\n\n        for role in staff_roles:\n            if role.members:\n                for member in role.members:\n                    if member.id not in [item[\"id\"] for item in sorted_staff]:\n                        if member not in added_staff:\n                            index = index + 1\n\n                            if buffer is None:\n                                buffer = \"%s - %s\" % (\n                                    f\"{member.name}\",\n                                    \"0 seconds\",\n                                )\n                                data.append(\n                                    [\n                                        index,\n                                        f\"{member.name}\",\n                                        member.top_role.name,\n                                        \"0 seconds\",\n                                        0,\n                                    ]\n                                )\n                                added_staff.append(member)\n                            else:\n                                buffer = buffer + \"\\n%s - %s\" % (\n                                    f\"{member.name}\",\n                                    \"0 seconds\",\n                                )\n                                data.append(\n                                    [\n                                        index,\n                                        f\"{member.name}\",\n                                        member.top_role.name,\n                                        \"0 seconds\",\n                                        0,\n                                    ]\n                                )\n                                added_staff.append(member)\n\n                            if len((embeds[-1].description or \"\").splitlines()) < 16:\n                                if embeds[-1].description is None:\n                                    embeds[-1].description = (\n                                        f\"**Total Shifts**\\n**{index + 1}.** {member.mention} • {td_format(datetime.timedelta(seconds=0))}\\n\"\n                                    )\n                                else:\n                                    embeds[\n                                        -1\n                                    ].description += f\"**{index + 1}.** {member.mention} • {td_format(datetime.timedelta(seconds=0))}\\n\"\n\n                            else:\n                                new_embed = discord.Embed(\n                                    color=BLANK_COLOR, title=\"Shift Leaderboard\"\n                                )\n\n                                new_embed.set_author(\n                                    name=f\"{ctx.guild.name}\",\n                                    icon_url=ctx.guild.icon,\n                                )\n                                new_embed.description = \"\"\n                                new_embed.description += f\"**Total Shifts**\\n**{index + 1}.** {member.mention} - {td_format(datetime.timedelta(seconds=0))}\\n\"\n                                embeds.append(new_embed)\n        perm_staff = list(\n            filter(\n                lambda m: (\n                    m.guild_permissions.manage_messages\n                    or m.guild_permissions.manage_guild\n                )\n                and not m.bot,\n                member_list,\n            )\n        )\n        for member in perm_staff:\n            if member.id not in [item[\"id\"] for item in sorted_staff]:\n                if member not in added_staff:\n                    index = index + 1\n\n                    if buffer is None:\n                        buffer = \"%s - %s\" % (\n                            f\"{member.name}\",\n                            \"0 seconds\",\n                        )\n                        data.append(\n                            [\n                                index + 1,\n                                f\"{member.name}\",\n                                member.top_role.name,\n                                \"0 seconds\",\n                                0,\n                            ]\n                        )\n                        added_staff.append(member)\n\n                    else:\n                        buffer = buffer + \"\\n%s - %s\" % (\n                            f\"{member.name}\",\n                            \"0 seconds\",\n                        )\n                        data.append(\n                            [\n                                index + 1,\n                                f\"{member.name}\",\n                                member.top_role.name,\n                                \"0 seconds\",\n                                0,\n                            ]\n                        )\n                        added_staff.append(member)\n\n                    if len((embeds[-1].description or \"\").splitlines()) < 16:\n                        if embeds[-1].description is None:\n                            embeds[-1].description = (\n                                f\"**Total Shifts**\\n**{index + 1}.** {member.mention} • {td_format(datetime.timedelta(seconds=0))}\\n\"\n                            )\n                        else:\n                            embeds[\n                                -1\n                            ].description += f\"**{index + 1}.** {member.mention} • {td_format(datetime.timedelta(seconds=0))}\\n\"\n\n                    else:\n                        new_embed = discord.Embed(\n                            color=BLANK_COLOR, title=\"Shift Leaderboard\"\n                        )\n\n                        new_embed.set_author(\n                            name=f\"{ctx.guild.name}\",\n                            icon_url=ctx.guild.icon,\n                        )\n                        new_embed.description = \"\"\n                        new_embed.description += f\"**Total Shifts**\\n**{index + 1}.** {member.mention} • {td_format(datetime.timedelta(seconds=0))}\\n\"\n                        embeds.append(new_embed)\n\n        combined = []\n        for list_item in data:\n            for item in list_item:\n                combined.append(item)\n        if buffer == \"\":\n            buffer += \"No data to display.\"\n\n        bbytes = buffer.encode(\"utf-8\", \"ignore\")\n\n        if len(embeds) == 1:\n            new_embeds = []\n            for i in embeds:\n                new_embeds.append(i)\n            if await management_predicate(ctx):\n                view = RequestGoogleSpreadsheet(\n                    self.bot,\n                    ctx.author.id,\n                    credentials_dict,\n                    scope,\n                    combined,\n                    config(\"DUTY_LEADERBOARD_ID\"),\n                    total_seconds,\n                )\n            else:\n                view = None\n            await ctx.reply(\n                embeds=new_embeds,\n                file=discord.File(fp=BytesIO(bbytes), filename=\"shift_leaderboard.txt\"),\n                view=view,\n            )\n        else:\n            if await management_predicate(ctx):\n                view = RequestGoogleSpreadsheet(\n                    self.bot,\n                    ctx.author.id,\n                    credentials_dict,\n                    scope,\n                    combined,\n                    config(\"DUTY_LEADERBOARD_ID\"),\n                    total_seconds,\n                )\n            else:\n                view = None\n\n            async def response_func(\n                interaction: discord.Interaction, button: discord.Button\n            ):\n                file = discord.File(\n                    fp=BytesIO(bbytes), filename=\"shift_leaderboard.txt\"\n                )\n                await interaction.response.send_message(file=file, ephemeral=True)\n\n            if view:\n                view.add_item(\n                    CustomExecutionButton(\n                        ctx.author.id,\n                        \"Download Shift Leaderboard\",\n                        discord.ButtonStyle.gray,\n                        emoji=None,\n                        func=response_func,\n                    )\n                )\n\n            pages = [\n                CustomPage(embeds=[embed], view=view, identifier=str(index + 1))\n                for index, embed in enumerate(embeds)\n            ]\n            menu = SelectPagination(self.bot, ctx.author.id, pages)\n\n            if len(menu.pages) == 1:\n                try:\n                    return await msg.edit(embed=embed, view=view)\n                except (UnboundLocalError, AttributeError, ValueError):\n                    return await ctx.reply(embed=embed, view=view)\n\n            view_page = menu.get_current_view()\n            try:\n                menu.message = await msg.edit(embed=embeds[0], view=view_page)\n            except (UnboundLocalError, AttributeError, ValueError):\n                menu.message = await ctx.reply(embed=embeds[0], view=view_page)\n\n    @commands.guild_only()\n    @duty.command(\n        name=\"history\",\n        description=\"Show all past shifts of user by shift type\",\n        extras={\"category\": \"Shift Management\"},\n        aliases=[\"h\"],\n    )\n    @require_settings()\n    @app_commands.autocomplete(type=shift_type_autocomplete)\n    @is_management()\n    async def duty_shifts(\n        self, ctx: commands.Context, user: discord.User, type: str = \"Default\"\n    ):\n        if self.bot.shift_management_disabled is True:\n            return await new_failure_embed(\n                ctx,\n                \"Maintenance\",\n                \"This command is currently disabled as ERM is currently undergoing maintenance updates. This command will be turned off briefly to ensure that no data is lost during the maintenance.\",\n            )\n\n        bot = self.bot\n        configItem = await bot.settings.find_by_id(ctx.guild.id)\n        if not configItem.get(\"shift_management\", {}).get(\"enabled\", False):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Enabled\",\n                    description=\"Shift Logging is not enabled on this server.\",\n                )\n            )\n\n        shift_types = configItem.get(\"shift_types\", {}).get(\"types\", [])\n        msg = None\n        shift_type_item = None\n        if shift_types:\n            if type.lower() not in [t[\"name\"].lower() for t in shift_types]:\n                msg = await ctx.send(\n                    embed=discord.Embed(\n                        title=\"Incorrect Shift Type\",\n                        description=\"The shift type provided is not valid.\",\n                        color=BLANK_COLOR,\n                    ),\n                    view=(\n                        view := CustomSelectMenu(\n                            ctx.author.id,\n                            [\n                                discord.SelectOption(\n                                    label=i[\"name\"],\n                                    value=i[\"name\"],\n                                    description=i[\"name\"],\n                                )\n                                for i in shift_types\n                            ],\n                        )\n                    ),\n                )\n                timeout = await view.wait()\n                if timeout:\n                    return\n\n                if view.value:\n                    type = view.value\n\n            for item in shift_types:\n                if item[\"name\"].lower() == type.lower():\n                    shift_type_item = item\n\n        if not shift_type_item:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Incorrect Shift Type\",\n                    description=\"The shift type provided is not valid.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        shift_cursor = self.bot.shift_management.shifts.db.find(\n            {\"UserID\": user.id, \"Guild\": ctx.guild.id, \"Type\": shift_type_item[\"name\"]}\n        )\n        shifts = await shift_cursor.to_list(length=None)\n        if not shifts:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"No Shifts\",\n                    description=\"No shifts have been found for this user.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        embeds = []\n        for shift in shifts:\n            embed = discord.Embed(title=f\"{user.name}'s Shifts\", color=BLANK_COLOR)\n            embed.add_field(\n                name=\"Shift Information\",\n                value=(\n                    f\"> **Started:** <t:{int(shift['StartEpoch'])}:R>\\n\"\n                    f\"> **Ended:** <t:{int(shift['EndEpoch'])}:R>\\n\"\n                    f\"> **Total Time:** {td_format(datetime.timedelta(seconds=get_elapsed_time(shift)))}\\n\"\n                    f\"> **Moderations:** {len(shift.get('Moderations', []))}\\n\"\n                    f\"> **Breaks:** {len(shift.get('Breaks', []))}\"\n                ),\n                inline=False,\n            ).set_author(\n                name=f\"{ctx.guild.name}\",\n                icon_url=ctx.guild.icon,\n            ).set_footer(\n                text=f\"Shift Type: {shift_type_item['name']}\"\n            ).set_thumbnail(\n                url=user.display_avatar.url\n            )\n            embeds.append(embed)\n\n        paginator = SelectPagination(\n            self.bot,\n            ctx.author.id,\n            [\n                CustomPage(embeds=[embed], identifier=str(index + 1))\n                for index, embed in enumerate(embeds)\n            ],\n        )\n        await ctx.reply(embed=embeds[0], view=paginator.get_current_view())\n\n\nasync def setup(bot):\n    await bot.add_cog(ShiftLogging(bot))\n"}
{"type": "source_file", "path": "cogs/Punishments.py", "content": "import datetime\r\nimport json\r\n\r\nimport aiohttp\r\nimport discord\r\nimport pytz\r\nimport reactionmenu\r\nimport roblox\r\nfrom decouple import config\r\nfrom discord import app_commands\r\nfrom discord.ext import commands\r\nfrom reactionmenu import ViewButton, ViewMenu\r\nfrom reactionmenu.abc import _PageController\r\nimport pytz\r\nfrom datamodels.Settings import Settings\r\nfrom datamodels.Warnings import WarningItem\r\nfrom erm import (\r\n    admin_predicate,\r\n    generator,\r\n    is_management,\r\n    is_staff,\r\n    management_predicate,\r\n)\r\nfrom menus import (\r\n    ChannelSelect,\r\n    CustomisePunishmentType,\r\n    CustomModalView,\r\n    CustomSelectMenu,\r\n    EditWarning,\r\n    RemoveWarning,\r\n    RequestDataView,\r\n    CustomExecutionButton,\r\n    UserSelect,\r\n    YesNoMenu,\r\n    ManagementOptions,\r\n    ManageTypesView,\r\n    PunishmentTypeCreator,\r\n    PunishmentModifier,\r\n    CustomModal,\r\n)\r\nfrom utils.AI import AI\r\nfrom utils.autocompletes import punishment_autocomplete, user_autocomplete\r\nfrom utils.constants import BLANK_COLOR, GREEN_COLOR\r\nfrom utils.paginators import SelectPagination, CustomPage\r\nfrom utils.utils import (\r\n    failure_embed,\r\n    removesuffix,\r\n    get_roblox_by_username,\r\n    failure_embed,\r\n    require_settings,\r\n    new_failure_embed,\r\n    time_converter,\r\n)\r\nfrom utils.timestamp import td_format\r\n\r\n\r\nclass Punishments(commands.Cog):\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n\r\n    @commands.guild_only()\r\n    @commands.hybrid_command(\r\n        name=\"punish\",\r\n        aliases=[\"p\"],\r\n        description=\"Punish a user\",\r\n        extras={\"category\": \"Punishments\"},\r\n        usage=\"punish <user> <type> <reason>\",\r\n    )\r\n    @is_staff()\r\n    @require_settings()\r\n    @app_commands.autocomplete(type=punishment_autocomplete)\r\n    @app_commands.autocomplete(user=user_autocomplete)\r\n    @app_commands.describe(type=\"The type of punishment to give.\")\r\n    @app_commands.describe(\r\n        user=\"What's their username? You can mention a Discord user, or provide a ROBLOX username.\"\r\n    )\r\n    @app_commands.describe(reason=\"What is your reason for punishing this user?\")\r\n    async def punish(self, ctx, user: str, type: str, *, reason: str):\r\n        if type.lower() == \"warn\":\r\n            type = \"Warning\"\r\n\r\n        settings = await self.bot.settings.find_by_id(ctx.guild.id) or {}\r\n        if not settings:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Setup\",\r\n                    description=\"Your server is not setup.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        if not (settings.get(\"punishments\") or {}).get(\"enabled\", False):\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Enabled\",\r\n                    description=\"Your server has punishments disabled.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n        flags = []\r\n        if \"--kick\" in reason.lower():\r\n            flags.append(\"autokick\")\r\n            reason = reason.replace(\"--kick\", \"\")\r\n        elif \"--ban\" in reason.lower():\r\n            flags.append(\"autoban\")\r\n            reason = reason.replace(\"--ban\", \"\")\r\n\r\n        if self.bot.punishments_disabled is True:\r\n            return await new_failure_embed(\r\n                ctx,\r\n                \"Maintenance\",\r\n                \"This command is currently disabled as ERM is currently undergoing maintenance updates. This command will be turned off briefly to ensure that no data is lost during the maintenance.\",\r\n            )\r\n\r\n        roblox_user = await get_roblox_by_username(user, self.bot, ctx)\r\n        roblox_client = roblox.client.Client()\r\n        if not roblox_user or roblox_user.get(\"errors\") is not None:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Could not find player\",\r\n                    description=\"I could not find a Roblox player with that username.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        roblox_player = await roblox_client.get_user(roblox_user[\"id\"])\r\n        thumbnails = await roblox_client.thumbnails.get_user_avatar_thumbnails(\r\n            [roblox_player], type=roblox.thumbnails.AvatarThumbnailType.headshot\r\n        )\r\n        thumbnail = thumbnails[0].image_url\r\n\r\n        # Get and verify punishment type\r\n        punishment_types = await self.bot.punishment_types.get_punishment_types(\r\n            ctx.guild.id\r\n        )\r\n        types = (punishment_types or {}).get(\"types\", [])\r\n        preset_types = [\"Warning\", \"Kick\", \"Ban\", \"BOLO\"]\r\n        actual_types = []\r\n        for item in preset_types + types:\r\n            if isinstance(item, str):\r\n                actual_types.append(item)\r\n            else:\r\n                actual_types.append(item[\"name\"])\r\n\r\n        if type.lower().strip() not in [i.lower().strip() for i in actual_types]:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Incorrect Type\",\r\n                    description=\"The punishment type you provided is invalid.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        # agent = AI(config('AI_API_URL'), config('AI_API_AUTH'))\r\n        # punishment = await agent.recommended_punishment(reason, None)\r\n        msg = None\r\n        # consent_item = await self.bot.consent.find(ctx.author.id) or {}\r\n        # ai_predictions = consent_item.get('ai_predictions', True)\r\n        # if type.lower() in [\"warning\", \"kick\", \"ban\", \"bolo\"]:\r\n        # if punishment.prediction.lower() !=  type.lower():\r\n        # if ai_predictions:\r\n        # msg = await ctx.send(\r\n        # embed=discord.Embed(\r\n        # title=\"Recommended Punishment\",\r\n        # description=\"ERM AI thinks that the punishment associated with this reason is not preferable. It suggests that you should **{}** for this punishment, rather than {}. Do you want to change the punishment type?\".format(punishment.prediction, type),\r\n        # color=BLANK_COLOR\r\n        # ),\r\n        # view=(view := YesNoMenu(ctx.author.id))\r\n        # )\r\n        # await view.wait()\r\n        # if view.value is True:\r\n        # type = punishment.prediction\r\n\r\n        for item in actual_types:\r\n            safe_item = item.lower().split()\r\n            if safe_item == type.lower().split():\r\n                actual_type = item\r\n                break\r\n        else:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Incorrect Type\",\r\n                    description=\"The punishment type you provided is invalid.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        if type.lower() in [\"tempban\", \"temporary ban\"]:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Supported\",\r\n                    description=\"Temporary Bans are not supported.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        oid = await self.bot.punishments.insert_warning(\r\n            ctx.author.id,\r\n            ctx.author.name,\r\n            roblox_player.id,\r\n            roblox_player.name,\r\n            ctx.guild.id,\r\n            reason,\r\n            actual_type,\r\n            datetime.datetime.now(tz=pytz.UTC).timestamp(),\r\n        )\r\n\r\n        current_shift = await self.bot.shift_management.get_current_shift(\r\n            ctx.author, ctx.guild.id\r\n        )\r\n        is_online = bool(current_shift)\r\n        if is_online:\r\n            await self.bot.shift_management.shifts.db.update_one(\r\n                {\"_id\": current_shift[\"_id\"]}, {\"$push\": {\"Moderations\": oid}}\r\n            )\r\n\r\n        self.bot.dispatch(\"punishment\", oid)\r\n\r\n        warning: WarningItem = await self.bot.punishments.fetch_warning(oid)\r\n        newline = \"\\n\"\r\n        if msg is not None:\r\n            if \"autoban\" in flags:\r\n                try:\r\n                    await self.bot.prc_api.run_command(\r\n                        ctx.guild.id, \":ban {}\".format(warning.username)\r\n                    )\r\n                except:\r\n                    pass\r\n            elif \"autokick\" in flags:\r\n                try:\r\n                    await self.bot.prc_api.run_command(\r\n                        ctx.guild.id, \":kick {}\".format(warning.username)\r\n                    )\r\n                except:\r\n                    pass\r\n            return await msg.edit(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Logged Punishment\",\r\n                    description=(\r\n                        \"I have successfully logged the following punishment!\"\r\n                    ),\r\n                    color=GREEN_COLOR,\r\n                )\r\n                .add_field(\r\n                    name=\"Punishment\",\r\n                    value=(\r\n                        f\"> **Player:** {warning.username}\\n\"\r\n                        f\"> **Type:** {warning.warning_type}\\n\"\r\n                        f\"> **Moderator:** <@{warning.moderator_id}>\\n\"\r\n                        f\"> **Reason:** {warning.reason}\\n\"\r\n                        f\"> **At:** <t:{int(warning.time_epoch)}>\\n\"\r\n                        f'{\"> **Until:** <t:{}>{}\".format(int(warning.until_epoch), newline) if warning.until_epoch is not None else \"\"}'\r\n                        f\"> **ID:** `{warning.snowflake}`\"\r\n                        f\"> **Custom Flags:** {'`N/A`' if len(flags) == 0 else '`{}`'.format(', '.join(flags))}\"\r\n                    ),\r\n                    inline=False,\r\n                )\r\n                .set_thumbnail(url=thumbnail),\r\n                view=None,\r\n            )\r\n        await ctx.send(\r\n            embed=discord.Embed(\r\n                title=f\"{self.bot.emoji_controller.get_emoji('success')} Logged Punishment\",\r\n                description=(\"I have successfully logged the following punishment!\"),\r\n                color=GREEN_COLOR,\r\n            )\r\n            .add_field(\r\n                name=\"Punishment\",\r\n                value=(\r\n                    f\"> **Player:** {warning.username}\\n\"\r\n                    f\"> **Type:** {warning.warning_type}\\n\"\r\n                    f\"> **Moderator:** <@{warning.moderator_id}>\\n\"\r\n                    f\"> **Reason:** {warning.reason}\\n\"\r\n                    f\"> **At:** <t:{int(warning.time_epoch)}>\\n\"\r\n                    f'{\"> **Until:** <t:{}>{}\".format(int(warning.until_epoch), newline) if warning.until_epoch is not None else \"\"}'\r\n                    f\"> **ID:** `{warning.snowflake}`\\n\"\r\n                    f\"> **Custom Flags:** {'`N/A`' if len(flags) == 0 else '{}'.format(', '.join(flags))}\"\r\n                ),\r\n                inline=False,\r\n            )\r\n            .set_thumbnail(url=thumbnail)\r\n        )\r\n\r\n        if \"autoban\" in flags:\r\n            try:\r\n                await self.bot.prc_api.run_command(\r\n                    ctx.guild.id, \":ban {}\".format(warning.user_id)\r\n                )\r\n            except:\r\n                pass\r\n        elif \"autokick\" in flags:\r\n            try:\r\n                await self.bot.prc_api.run_command(\r\n                    ctx.guild.id, \":kick {}\".format(warning.username)\r\n                )\r\n            except:\r\n                pass\r\n\r\n    @commands.hybrid_group(\r\n        name=\"punishment\",\r\n        description=\"Punishment commands\",\r\n        extras={\"category\": \"Punishments\"},\r\n        aliases=[\"pm\"],\r\n    )\r\n    async def punishments(self, ctx: commands.Context):\r\n        await ctx.invoke(self.bot.get_command(\"punishment manage\"))\r\n\r\n    # Punishment Manage command, containing `types`, `void` and `modify`\r\n    @commands.guild_only()\r\n    @punishments.command(\r\n        name=\"manage\",\r\n        description=\"Manage punishments\",\r\n        extras={\"category\": \"Punishments\"},\r\n    )\r\n    @require_settings()\r\n    # @is_management()\r\n    @is_staff()\r\n    async def punishment_manage(self, ctx: commands.Context):\r\n        embed = discord.Embed(\r\n            title=\"Staff Options\",\r\n            description=\"Using this menu, you can **Manage Punishment Types** as well as **Modify Punishment**.\",\r\n            color=BLANK_COLOR,\r\n        )\r\n        embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n        view = ManagementOptions(ctx.author.id)\r\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\r\n\r\n        msg = await ctx.send(embed=embed, view=view)\r\n        await view.wait()\r\n\r\n        if view.value == \"modify\":\r\n            try:\r\n                punishment_id = int(view.modal.punishment_id.value.strip())\r\n            except ValueError:\r\n                return await msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Invalid Punishment ID\",\r\n                        description=\"This punishment ID is invalid.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    view=None,\r\n                )\r\n\r\n            punishment = await self.bot.punishments.find_warning_by_spec(\r\n                snowflake=punishment_id, guild_id=ctx.guild.id\r\n            )\r\n            if not punishment:\r\n                return await msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Invalid Punishment ID\",\r\n                        description=\"This punishment ID is invalid.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    view=None,\r\n                )\r\n\r\n            if (\r\n                punishment[\"ModeratorID\"] != ctx.author.id\r\n                and not await management_predicate(ctx)\r\n                and not await admin_predicate(ctx)\r\n            ):\r\n                return await msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Access Denied\",\r\n                        description=\"You are unable to edit other people's punishments as you only have the Staff permission.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            view = PunishmentModifier(self.bot, ctx.author.id, punishment)\r\n            await view.refresh_ui(msg)\r\n            await view.wait()\r\n            await msg.edit(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Modified!\",\r\n                    description=\"Successfully modified this punishment!\",\r\n                    color=GREEN_COLOR,\r\n                ),\r\n                view=None,\r\n            )\r\n\r\n        elif view.value == \"types\":\r\n            if not await management_predicate(ctx):\r\n                return await msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Not Permitted\",\r\n                        description=\"You are not permitted to access this panel.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    view=None,\r\n                )\r\n            punishment_types = await self.bot.punishment_types.get_punishment_types(\r\n                ctx.guild.id\r\n            )\r\n            if not punishment_types:\r\n                punishment_types = {\"types\": []}\r\n\r\n            punishment_types = punishment_types[\"types\"]\r\n\r\n            def setup_embed() -> discord.Embed:\r\n                embed = discord.Embed(title=\"Punishment Types\", color=BLANK_COLOR)\r\n                embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n                return embed\r\n\r\n            filtered = list(filter(lambda x: isinstance(x, dict), punishment_types))\r\n            embeds = []\r\n            associations = {}\r\n            if len(embeds) == 0:\r\n                embeds.append(setup_embed())\r\n\r\n            for item in filtered:\r\n\r\n                if len(embeds[-1].fields) > 15:\r\n                    embeds[-1].add_field(\r\n                        name=\"Limitation\",\r\n                        value=\"You cannot have more than 15 custom punishment types.\",\r\n                        inline=False,\r\n                    )\r\n                    break\r\n\r\n                embeds[-1].add_field(\r\n                    name=item[\"name\"],\r\n                    value=(\r\n                        f\"> **Name:** {item['name']}\\n\"\r\n                        f\"> **ID:** {item.get('id', (temporary_id := next(generator)))}\\n\"\r\n                        f\"> **Channel:** <#{item['channel']}>\"\r\n                    ),\r\n                    inline=False,\r\n                )\r\n                associations[temporary_id] = item\r\n            if len(embeds[0].fields) == 0:\r\n                embeds[0].add_field(\r\n                    name=\"No Punishment Types\",\r\n                    value=\"There are no custom punishment types in this server.\",\r\n                    inline=False,\r\n                )\r\n            manage_types_view = ManageTypesView(self.bot, ctx.author.id)\r\n            await msg.edit(embed=embeds[0], view=manage_types_view)\r\n            await manage_types_view.wait()\r\n            if manage_types_view.value == \"create\":\r\n                data = {\r\n                    \"id\": next(generator),\r\n                    \"name\": manage_types_view.name_for_creation,\r\n                    \"channel\": None,\r\n                }\r\n                embed = discord.Embed(\r\n                    title=\"Punishment Type Creation\",\r\n                    description=(\r\n                        f\"> **Name:** {data['name']}\\n\"\r\n                        f\"> **ID:** {data['id']}\\n\"\r\n                        f\"> **Punishment Channel:** {'<#{}>'.format(data.get('channel', None)) if data.get('channel', None) is not None else 'Not set'}\\n\"\r\n                    ),\r\n                    color=BLANK_COLOR,\r\n                )\r\n\r\n                view = PunishmentTypeCreator(ctx.author.id, data)\r\n                await msg.edit(view=view, embed=embed)\r\n                await view.wait()\r\n                if view.cancelled is True:\r\n                    return\r\n\r\n                punishment_types.append(view.dataset)\r\n\r\n                await self.bot.punishment_types.upsert(\r\n                    {\"_id\": ctx.guild.id, \"types\": punishment_types}\r\n                )\r\n                await msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=f\"{self.bot.emoji_controller.get_emoji('success')} Type Created\",\r\n                        description=\"Your punishment type has been created!\",\r\n                        color=GREEN_COLOR,\r\n                    ),\r\n                    view=None,\r\n                )\r\n            elif manage_types_view.value == \"delete\":\r\n                if not await management_predicate(ctx):\r\n                    return await msg.edit(\r\n                        embed=discord.Embed(\r\n                            title=\"Not Permitted\",\r\n                            description=\"You are not permitted to access this panel.\",\r\n                            color=BLANK_COLOR,\r\n                        )\r\n                    )\r\n                try:\r\n                    type_id = int(manage_types_view.selected_for_deletion.strip())\r\n                except ValueError:\r\n                    return await msg.edit(\r\n                        embed=discord.Embed(\r\n                            title=\"Invalid Punishment Type\",\r\n                            description=\"The ID you have provided is not associated with a punishment type.\",\r\n                            color=BLANK_COLOR,\r\n                        ),\r\n                        view=None,\r\n                    )\r\n                if len(punishment_types) == 0:\r\n                    return await msg.edit(\r\n                        embed=discord.Embed(\r\n                            title=\"Invalid Punishment Type\",\r\n                            description=\"The ID you have provided is not associated with a punishment type.\",\r\n                            color=BLANK_COLOR,\r\n                        ),\r\n                        view=None,\r\n                    )\r\n                if type_id not in [t.get(\"id\") for t in list(filtered)]:\r\n                    if not associations.get(type_id):\r\n                        return await msg.edit(\r\n                            embed=discord.Embed(\r\n                                title=\"Invalid Punishment Type\",\r\n                                description=\"The ID you have provided is not associated with a punishment type.\",\r\n                                color=BLANK_COLOR,\r\n                            ),\r\n                            view=None,\r\n                        )\r\n                for item in filtered:\r\n                    if item.get(\"id\") == type_id or item == associations.get(type_id):\r\n                        punishment_types.remove(item)\r\n                        break\r\n\r\n                await self.bot.punishment_types.upsert(\r\n                    {\"_id\": ctx.guild.id, \"types\": punishment_types}\r\n                )\r\n                await msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=f\"{self.bot.emoji_controller.get_emoji('success')} Type Deleted\",\r\n                        description=\"Your Punishment Type has been deleted!\",\r\n                        color=GREEN_COLOR,\r\n                    ),\r\n                    view=None,\r\n                )\r\n\r\n    @commands.hybrid_group(\r\n        name=\"bolo\",\r\n        description=\"Manage the server's BOLO list.\",\r\n        extras={\"category\": \"Punishments\"},\r\n    )\r\n    async def bolo(self, ctx):\r\n        pass\r\n\r\n    @commands.guild_only()\r\n    @bolo.command(\r\n        name=\"active\",\r\n        description=\"View the server's active BOLOs.\",\r\n        extras={\"category\": \"Punishments\", \"ignoreDefer\": True},\r\n        aliases=[\"search\", \"lookup\"],\r\n    )\r\n    @app_commands.autocomplete(user=user_autocomplete)\r\n    @app_commands.describe(user=\"The user to search for.\")\r\n    @is_staff()\r\n    @require_settings()\r\n    async def active(self, ctx, user: str = None):\r\n\r\n        async def task(interaction: discord.Interaction, _):\r\n            modal = CustomModal(\r\n                \"Mark as Complete\",\r\n                [\r\n                    (\r\n                        \"bolo\",\r\n                        discord.ui.TextInput(\r\n                            placeholder=\"The ID for the BOLO you are marking as complete\",\r\n                            label=\"BOLO ID\",\r\n                        ),\r\n                    )\r\n                ],\r\n                {\"ephemeral\": True, \"thinking\": True},\r\n            )\r\n\r\n            await interaction.response.send_modal(modal)\r\n            timeout = await modal.wait()\r\n            if timeout:\r\n                return\r\n            try:\r\n                id = int(modal.bolo.value)\r\n            except ValueError:\r\n                return await modal.interaction.followup.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Invalid Identifier\",\r\n                        description=\"I could not find a BOLO associating with that ID. Please ensure you have entered the correct ID.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            matching_docs = list(\r\n                filter(\r\n                    lambda x: x is not None,\r\n                    [\r\n                        await bot.punishments.find_warning_by_spec(\r\n                            snowflake=id,\r\n                            warning_type=\"BOLO\",\r\n                            guild_id=interaction.guild.id,\r\n                        )\r\n                    ],\r\n                )\r\n            )\r\n\r\n            if len(matching_docs) == 0:\r\n                return await modal.interaction.followup.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Invalid Identifier\",\r\n                        description=\"I could not find a BOLO associating with that ID. Please ensure you have entered the correct ID.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            doc = matching_docs[0]\r\n\r\n            await bot.punishments.insert_warning(\r\n                ctx.author.id,\r\n                ctx.author.name,\r\n                doc[\"UserID\"],\r\n                doc[\"Username\"],\r\n                ctx.guild.id,\r\n                f\"BOLO marked as complete by {ctx.author} ({ctx.author.id}). Original BOLO Reason was {doc['Reason']} made by {doc['Moderator']} ({doc['ModeratorID']})\",\r\n                \"Ban\",\r\n                datetime.datetime.now(tz=pytz.UTC).timestamp(),\r\n            )\r\n\r\n            await bot.punishments.remove_warning_by_snowflake(id)\r\n\r\n            await modal.interaction.followup.send(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Completed BOLO\",\r\n                    description=\"This BOLO has been marked as complete successfully.\",\r\n                    color=GREEN_COLOR,\r\n                )\r\n            )\r\n            return\r\n\r\n        async def deny_task(interaction: discord.Interaction, _):\r\n            modal = CustomModal(\r\n                \"Mark as Denied\",\r\n                [\r\n                    (\r\n                        \"bolo\",\r\n                        discord.ui.TextInput(\r\n                            placeholder=\"The ID for the BOLO you are marking as denied\",\r\n                            label=\"BOLO ID\",\r\n                        ),\r\n                    )\r\n                ],\r\n                {\"ephemeral\": True, \"thinking\": True},\r\n            )\r\n\r\n            await interaction.response.send_modal(modal)\r\n            timeout = await modal.wait()\r\n            if timeout:\r\n                return\r\n            try:\r\n                id = int(modal.bolo.value)\r\n            except ValueError:\r\n                return await modal.interaction.followup.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Invalid Identifier\",\r\n                        description=\"I could not find a BOLO associating with that ID. Please ensure you have entered the correct ID.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            # bro i just realised someone could use this to erase a non-bolo...\r\n            matching_docs = list(\r\n                filter(\r\n                    lambda x: x is not None,\r\n                    [\r\n                        await bot.punishments.find_warning_by_spec(\r\n                            snowflake=id,\r\n                            warning_type=\"BOLO\",\r\n                            guild_id=interaction.guild.id,\r\n                        )\r\n                    ],\r\n                )\r\n            )\r\n\r\n            if len(matching_docs) == 0:\r\n                return await modal.interaction.followup.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Invalid Identifier\",\r\n                        description=\"I could not find a BOLO associating with that ID. Please ensure you have entered the correct ID.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            doc = matching_docs[0]\r\n\r\n            await bot.punishments.remove_warning_by_snowflake(id)\r\n\r\n            await modal.interaction.followup.send(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Denied BOLO\",\r\n                    description=\"This BOLO has been marked as denied successfully.\\nIt has been erased from the active BOLO list.\",\r\n                    color=GREEN_COLOR,\r\n                )\r\n            )\r\n            return\r\n\r\n        if self.bot.punishments_disabled is True:\r\n            return await failure_embed(\r\n                ctx,\r\n                \"This command is currently disabled as ERM is currently undergoing maintenance updates. This command will be turned off briefly to ensure that no data is lost during the maintenance. It will be returned shortly.\",\r\n            )\r\n\r\n        bot = self.bot\r\n        if user is None:\r\n            bolos = await bot.punishments.get_guild_bolos(ctx.guild.id)\r\n            msg = None\r\n            if len(bolos) == 0:\r\n                return await ctx.reply(\r\n                    embed=discord.Embed(\r\n                        title=\"No Entries\",\r\n                        description=\"There are no active BOLOs in this server.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n            embeds = []\r\n\r\n            embed = discord.Embed(\r\n                title=\"Active Ban BOLOs\",\r\n                color=BLANK_COLOR,\r\n            )\r\n\r\n            embed.set_author(\r\n                name=ctx.guild.name,\r\n                icon_url=ctx.guild.icon,\r\n            )\r\n\r\n            embed.set_footer(\r\n                text=\"Click 'Mark as Complete' or 'Deny BOLO' and enter the BOLO ID.\"\r\n            )\r\n\r\n            embeds.append(embed)\r\n\r\n            for entry in bolos:\r\n                if len(embeds[-1].fields) == 4:\r\n                    new_embed = discord.Embed(\r\n                        title=\"Active Ban BOLOs\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n\r\n                    new_embed.set_author(\r\n                        name=ctx.guild.name,\r\n                        icon_url=ctx.guild.icon,\r\n                    )\r\n\r\n                    embeds.append(new_embed)\r\n\r\n                warning: WarningItem = await bot.punishments.fetch_warning(entry[\"_id\"])\r\n\r\n                embeds[-1].add_field(\r\n                    name=f\"{warning.username} ({warning.user_id})\",\r\n                    inline=False,\r\n                    value=(\r\n                        f\"> **Moderator:** <@{warning.moderator_id}>\\n\"\r\n                        f\"> **Reason:** {warning.reason}\\n\"\r\n                        f\"> **At:** <t:{int(warning.time_epoch)}>\\n\"\r\n                        f\"> **ID:** `{warning.snowflake}`\"\r\n                    ),\r\n                )\r\n\r\n            for embed in embeds:\r\n                embed.title += \" [{}]\".format(len(bolos))\r\n\r\n            view = discord.ui.View()\r\n            view.add_item(\r\n                CustomExecutionButton(\r\n                    ctx.author.id,\r\n                    \"Mark as Complete\",\r\n                    discord.ButtonStyle.secondary,\r\n                    func=task,\r\n                )\r\n            )\r\n            view.add_item(\r\n                CustomExecutionButton(\r\n                    ctx.author.id,\r\n                    \"Deny BOLO\",\r\n                    discord.ButtonStyle.danger,\r\n                    func=deny_task,\r\n                )\r\n            )\r\n\r\n            paginator = SelectPagination(\r\n                self.bot,\r\n                ctx.author.id,\r\n                [\r\n                    CustomPage(embeds=[embed], view=view, identifier=str(index + 1))\r\n                    for index, embed in enumerate(embeds)\r\n                ],\r\n            )\r\n            current_page = paginator.get_current_view()\r\n\r\n            msg = await ctx.reply(embed=embeds[0], view=current_page)\r\n\r\n        else:\r\n            roblox_user = await get_roblox_by_username(user, bot, ctx)\r\n            if roblox_user is None:\r\n                return await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Could not find player\",\r\n                        description=\"I could not find a Roblox player with that username.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            if roblox_user.get(\"errors\") is not None:\r\n                return await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Could not find player\",\r\n                        description=\"I could not find a Roblox player with that username.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            user = [\r\n                i\r\n                async for i in bot.punishments.find_warnings_by_spec(\r\n                    ctx.guild.id, user_id=roblox_user[\"id\"], bolo=True\r\n                )\r\n            ]\r\n            bolos = user\r\n\r\n            if user is None:\r\n                return await ctx.reply(\r\n                    embed=discord.Embed(\r\n                        title=\"No Entries\",\r\n                        description=\"There are no active BOLOs for this user in this server.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            if len(bolos) == 0:\r\n                return await ctx.reply(\r\n                    embed=discord.Embed(\r\n                        title=\"No Entries\",\r\n                        description=\"There are no active BOLOs for this user in this server.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            embeds = []\r\n\r\n            embed = discord.Embed(\r\n                title=\"Active Ban BOLOs\",\r\n                color=BLANK_COLOR,\r\n            )\r\n\r\n            embed.set_author(\r\n                name=ctx.guild.name,\r\n                icon_url=ctx.guild.icon,\r\n            )\r\n\r\n            embed.set_footer(\r\n                text=\"Click 'Mark as Complete' or 'Deny BOLO' and enter the BOLO ID.\"\r\n            )\r\n\r\n            embeds.append(embed)\r\n\r\n            for entry in bolos:\r\n                if len(embeds[-1].fields) == 4:\r\n                    new_embed = discord.Embed(\r\n                        title=\"Active Ban BOLOs\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n\r\n                    new_embed.set_author(\r\n                        name=ctx.guild.name,\r\n                        icon_url=ctx.guild.icon,\r\n                    )\r\n\r\n                    embeds.append(new_embed)\r\n\r\n                warning: WarningItem = await bot.punishments.fetch_warning(entry[\"_id\"])\r\n\r\n                embeds[-1].add_field(\r\n                    name=f\"{warning.username} ({warning.user_id})\",\r\n                    inline=False,\r\n                    value=(\r\n                        f\"> **Moderator:** <@{warning.moderator_id}>\\n\"\r\n                        f\"> **Reason:** {warning.reason}\\n\"\r\n                        f\"> **At:** <t:{int(warning.time_epoch)}>\\n\"\r\n                        f\"> **ID:** `{warning.snowflake}`\"\r\n                    ),\r\n                )\r\n\r\n            for embed in embeds:\r\n                embed.title += \" [{}]\".format(len(bolos))\r\n\r\n            view = discord.ui.View()\r\n            view.add_item(\r\n                CustomExecutionButton(\r\n                    ctx.author.id,\r\n                    \"Mark as Complete\",\r\n                    discord.ButtonStyle.secondary,\r\n                    func=task,\r\n                )\r\n            )\r\n            view.add_item(\r\n                CustomExecutionButton(\r\n                    ctx.author.id,\r\n                    \"Deny BOLO\",\r\n                    discord.ButtonStyle.danger,\r\n                    func=deny_task,\r\n                )\r\n            )\r\n\r\n            paginator = SelectPagination(\r\n                self.bot,\r\n                ctx.author.id,\r\n                [\r\n                    CustomPage(embeds=[embed], view=view, identifier=str(index + 1))\r\n                    for index, embed in enumerate(embeds)\r\n                ],\r\n            )\r\n            current_page = paginator.get_current_view()\r\n\r\n            msg = await ctx.reply(embed=embeds[0], view=current_page)\r\n\r\n    @commands.guild_only()\r\n    @commands.hybrid_command(\r\n        name=\"tempban\",\r\n        aliases=[\"tb\", \"tba\"],\r\n        description=\"Tempbans a user.\",\r\n        extras={\"category\": \"Punishments\"},\r\n        with_app_command=True,\r\n    )\r\n    @is_staff()\r\n    @app_commands.autocomplete(user=user_autocomplete)\r\n    @app_commands.describe(user=\"What's their ROBLOX username?\")\r\n    @app_commands.describe(time=\"How long are you banning them for? (s/m/h/d)\")\r\n    @app_commands.describe(reason=\"What is your reason for punishing this user?\")\r\n    async def tempban(self, ctx, user, time: str, *, reason):\r\n        if self.bot.punishments_disabled is True:\r\n            return await new_failure_embed(\r\n                ctx,\r\n                \"Maintenance\",\r\n                \"This command is currently disabled as ERM is currently undergoing maintenance updates. This command will be turned off briefly to ensure that no data is lost during the maintenance.\",\r\n            )\r\n\r\n        try:\r\n            amount = time_converter(time)\r\n        except ValueError:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Invalid Time\",\r\n                    description=\"The time provided is invalid.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        roblox_user = await get_roblox_by_username(user, self.bot, ctx)\r\n        roblox_client = roblox.client.Client()\r\n        if not roblox_user or roblox_user.get(\"errors\") is not None:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Could not find player\",\r\n                    description=\"I could not find a Roblox player with that username.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        roblox_player = await roblox_client.get_user(roblox_user[\"id\"])\r\n        thumbnails = await roblox_client.thumbnails.get_user_avatar_thumbnails(\r\n            [roblox_player], type=roblox.thumbnails.AvatarThumbnailType.headshot\r\n        )\r\n        thumbnail = thumbnails[0].image_url\r\n\r\n        oid = await self.bot.punishments.insert_warning(\r\n            ctx.author.id,\r\n            ctx.author.name,\r\n            roblox_player.id,\r\n            roblox_player.name,\r\n            ctx.guild.id,\r\n            reason,\r\n            \"Temporary Ban\",\r\n            datetime.datetime.now(tz=pytz.UTC).timestamp(),\r\n            datetime.datetime.now(tz=pytz.UTC).timestamp() + amount,\r\n        )\r\n\r\n        self.bot.dispatch(\"punishment\", oid)\r\n\r\n        warning: WarningItem = await self.bot.punishments.fetch_warning(oid)\r\n        newline = \"\\n\"\r\n        await ctx.send(\r\n            embed=discord.Embed(\r\n                title=f\"{self.bot.emoji_controller.get_emoji('success')} Logged Punishment\",\r\n                description=(\"I have successfully logged the following punishment!\"),\r\n                color=GREEN_COLOR,\r\n            )\r\n            .add_field(\r\n                name=\"Punishment\",\r\n                value=(\r\n                    f\"> **Player:** {warning.username}\\n\"\r\n                    f\"> **Moderator:** <@{warning.moderator_id}>\\n\"\r\n                    f\"> **Reason:** {warning.reason}\\n\"\r\n                    f\"> **At:** <t:{int(warning.time_epoch)}>\\n\"\r\n                    f'{\"> **Until:** <t:{}>{}\".format(int(warning.until_epoch), newline) if warning.until_epoch is not None else \"\"}'\r\n                    f\"> **ID:** `{warning.snowflake}`\"\r\n                ),\r\n                inline=False,\r\n            )\r\n            .set_thumbnail(url=thumbnail)\r\n        )\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(Punishments(bot))\r\n"}
{"type": "source_file", "path": "cogs/Reminders.py", "content": "import datetime\r\nimport discord\r\nfrom discord.ext import commands\r\nfrom erm import is_management, is_admin\r\nfrom menus import (\r\n    ManageReminders,\r\n    YesNoColourMenu,\r\n    ReminderCreationToolkit,\r\n)\r\nfrom utils.constants import BLANK_COLOR, GREEN_COLOR\r\nfrom utils.timestamp import td_format\r\nfrom utils.utils import generator, time_converter, require_settings, log_command_usage\r\n\r\n\r\nclass Reminders(commands.Cog):\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n\r\n    @commands.hybrid_group(name=\"reminders\")\r\n    @is_management()\r\n    async def reminders(self, ctx):\r\n        pass\r\n\r\n    @commands.guild_only()\r\n    @reminders.command(\r\n        name=\"manage\",\r\n        description=\"Manage your reminders\",\r\n        extras={\"category\": \"Reminders\"},\r\n    )\r\n    @is_admin()\r\n    @require_settings()\r\n    async def manage_reminders(self, ctx):\r\n        bot = self.bot\r\n        await log_command_usage(self.bot, ctx.guild, ctx.author, f\"Reminders Manage\")\r\n        reminder_data = await bot.reminders.find_by_id(ctx.guild.id)\r\n        if reminder_data is None:\r\n            reminder_data = {\"_id\": ctx.guild.id, \"reminders\": []}\r\n\r\n        embed = discord.Embed(title=\"Reminders\", color=BLANK_COLOR)\r\n        embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n        [\r\n            embed.add_field(\r\n                name=f\"{reminder['name']}\",\r\n                value=(\r\n                    f\"> **Name:** {reminder['name']}\\n\"\r\n                    f\"> **ID:** {reminder['id']}\\n\"\r\n                    f\"> **Interval:** {td_format(datetime.timedelta(seconds=reminder['interval']))}\\n\"\r\n                    f\"> **ER:LC Integration:** {self.bot.emoji_controller.get_emoji('check') if reminder.get('integration') is not None else self.bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                    f\"> **Paused:** {self.bot.emoji_controller.get_emoji('check') if reminder.get('paused') is True else self.bot.emoji_controller.get_emoji('xmark')}\"\r\n                ),\r\n                inline=False,\r\n            )\r\n            for reminder in reminder_data[\"reminders\"]\r\n        ]\r\n        embed.set_thumbnail(url=ctx.guild.icon)\r\n\r\n        if len(embed.fields) == 0:\r\n            embed.add_field(name=\"No Reminders\", value=\"This server has no reminders.\")\r\n\r\n        view = ManageReminders(ctx.author.id)\r\n\r\n        msg = await ctx.reply(\r\n            embed=embed,\r\n            view=view,\r\n        )\r\n        await view.wait()\r\n        if view.value == \"pause\":\r\n            reminder = view.modal.id_value.value\r\n\r\n            for index, item in enumerate(reminder_data[\"reminders\"]):\r\n                if item[\"id\"] == int(\r\n                    reminder if all(n for n in reminder if n.isdigit()) else 0\r\n                ):\r\n                    if item.get(\"paused\") is True:\r\n                        item[\"paused\"] = False\r\n                        reminder_data[\"reminders\"][index] = item\r\n                        await bot.reminders.upsert(reminder_data)\r\n                        return await msg.edit(\r\n                            embed=discord.Embed(\r\n                                title=f\"{self.bot.emoji_controller.get_emoji('success')} Reminder Resumed\",\r\n                                description=\"Your reminder has been resumed!\",\r\n                                color=GREEN_COLOR,\r\n                            ),\r\n                            view=None,\r\n                        )\r\n                    else:\r\n                        item[\"paused\"] = True\r\n                        reminder_data[\"reminders\"][index] = item\r\n                        await bot.reminders.upsert(reminder_data)\r\n                        return await msg.edit(\r\n                            embed=discord.Embed(\r\n                                title=f\"{self.bot.emoji_controller.get_emoji('success')} Reminder Paused\",\r\n                                description=\"Your reminder has been paused!\",\r\n                                color=GREEN_COLOR,\r\n                            ),\r\n                            view=None,\r\n                        )\r\n\r\n            return await msg.edit(\r\n                embed=discord.Embed(\r\n                    title=\"Invalid Reminder\",\r\n                    description=\"We could not find the reminder associated with that ID.\",\r\n                    color=BLANK_COLOR,\r\n                ),\r\n                view=None,\r\n            )\r\n\r\n        if view.value == \"edit\":\r\n            id = view.modal.identifier.value\r\n            dataset = None\r\n            for item in reminder_data[\"reminders\"]:\r\n                if item[\"id\"] == int(id if all(n for n in id if n.isdigit()) else 0):\r\n                    dataset = item\r\n                    break\r\n            if not dataset:\r\n                return await msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Could not find reminder\",\r\n                        description=\"I could not find the reminder with the ID you specified.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    view=None,\r\n                )\r\n\r\n            completion_ability = dataset.get(\"completion_ability\", False)\r\n            if completion_ability:\r\n                completion_styling = {\r\n                    \"label\": \"Completion Ability: Enabled\",\r\n                    \"style\": discord.ButtonStyle.green,\r\n                }\r\n            else:\r\n                completion_styling = {\r\n                    \"label\": \"Completion Ability: Disabled\",\r\n                    \"style\": discord.ButtonStyle.danger,\r\n                }\r\n\r\n            view = ReminderCreationToolkit(\r\n                ctx.author.id,\r\n                dataset,\r\n                \"edit\",\r\n                {\r\n                    \"Reminder Channel\": list(\r\n                        filter(\r\n                            lambda x: x is not None,\r\n                            [\r\n                                discord.utils.get(\r\n                                    ctx.guild.channels, id=dataset.get(\"channel\", None)\r\n                                )\r\n                            ],\r\n                        )\r\n                    ),\r\n                    \"Mentioned Roles\": list(\r\n                        filter(\r\n                            lambda x: x is not None,\r\n                            [\r\n                                discord.utils.get(ctx.guild.roles, id=i)\r\n                                for i in dataset.get(\"role\") or []\r\n                            ],\r\n                        )\r\n                    ),\r\n                    \"Completion Ability: Disabled\": completion_styling,\r\n                },\r\n            )\r\n            await msg.edit(\r\n                embed=discord.Embed(\r\n                    title=\"Edit a Reminder\",\r\n                    description=(\r\n                        f\"> **Name:** {dataset['name']}\\n\"\r\n                        f\"> **ID:** {dataset['id']}\\n\"\r\n                        f\"> **Channel:** {'<#{}>'.format(dataset.get('channel', None)) if dataset.get('channel', None) is not None else 'Not set'}\\n\"\r\n                        f\"> **Completion Ability:** {dataset.get('completion_ability') or 'Not set'}\\n\"\r\n                        f\"> **Mentioned Roles:** {', '.join(['<@&{}>'.format(r) for r in (dataset.get('role') or [])]) or 'Not set'}\\n\"\r\n                        f\"> **Interval:** {td_format(datetime.timedelta(seconds=dataset.get('interval', 0))) or 'Not set'}\\n\"\r\n                        f\"> **ER:LC Integration Enabled:** {dataset.get('integration') is not None}\"\r\n                        f\"\\n\\n**Content:**\\n{dataset['message']}\"\r\n                    ),\r\n                    color=BLANK_COLOR,\r\n                ),\r\n                view=view,\r\n            )\r\n            await view.wait()\r\n            if view.cancelled is True:\r\n                return\r\n\r\n            # Update the reminder\r\n            for index, item in enumerate(reminder_data[\"reminders\"]):\r\n                if item[\"id\"] == dataset[\"id\"]:\r\n                    reminder_data[\"reminders\"][index] = dataset\r\n\r\n            await bot.reminders.upsert(reminder_data)\r\n            await msg.edit(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Reminder Edited\",\r\n                    description=\"Your reminder has been edited!\",\r\n                    color=GREEN_COLOR,\r\n                ),\r\n                view=None,\r\n            )\r\n            return\r\n        if view.value == \"create\":\r\n            time_arg = view.modal.time.value\r\n            message = view.modal.content.value\r\n            name = view.modal.name.value\r\n            try:\r\n                new_time = time_converter(time_arg)\r\n            except ValueError:\r\n                return await msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Invalid Time\",\r\n                        description=\"You did not enter a valid time.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    view=None,\r\n                )\r\n\r\n            dataset = {\r\n                \"id\": next(generator),\r\n                \"name\": name,\r\n                \"interval\": new_time,\r\n                \"completion_ability\": None,\r\n                \"message\": message,\r\n                \"channel\": None,\r\n                \"role\": [],\r\n                \"lastTriggered\": 0,\r\n                \"paused\": False,\r\n            }\r\n\r\n            view = ReminderCreationToolkit(ctx.author.id, dataset, \"create\")\r\n            await msg.edit(\r\n                embed=discord.Embed(\r\n                    title=\"Reminder Creation\",\r\n                    description=(\r\n                        f\"> **Name:** {dataset['name']}\\n\"\r\n                        f\"> **ID:** {dataset['id']}\\n\"\r\n                        f\"> **Channel:** {'<#{}>'.format(dataset.get('channel', None)) if dataset.get('channel', None) is not None else 'Not set'}\\n\"\r\n                        f\"> **Completion Ability:** {dataset.get('completion_ability') or 'Not set'}\\n\"\r\n                        f\"> **Mentioned Roles:** {', '.join(['<@&{}>'.format(r) for r in dataset.get('role', [])]) or 'Not set'}\\n\"\r\n                        f\"> **Interval:** {td_format(datetime.timedelta(seconds=dataset.get('interval', 0))) or 'Not set'}\\n\"\r\n                        f\"> **ER:LC Integration Enabled:** {dataset.get('integration') is not None}\"\r\n                        f\"\\n\\n**Content:**\\n{dataset['message']}\"\r\n                    ),\r\n                    color=BLANK_COLOR,\r\n                ),\r\n                view=view,\r\n            )\r\n            await view.wait()\r\n            if view.cancelled is True:\r\n                return\r\n\r\n            reminder_data[\"reminders\"].append(view.dataset)\r\n\r\n            await bot.reminders.upsert(reminder_data)\r\n            await msg.edit(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Reminder Created\",\r\n                    description=\"Your reminder has been created!\",\r\n                    color=GREEN_COLOR,\r\n                ),\r\n                view=None,\r\n            )\r\n\r\n        elif view.value == \"delete\":\r\n            name = view.modal.id_value.value\r\n            for item in reminder_data[\"reminders\"]:\r\n                if item[\"id\"] == int(\r\n                    name if all(n for n in name if n.isdigit()) else 0\r\n                ):\r\n                    reminder_data[\"reminders\"].remove(item)\r\n                    await bot.reminders.upsert(reminder_data)\r\n                    return await msg.edit(\r\n                        embed=discord.Embed(\r\n                            title=f\"{self.bot.emoji_controller.get_emoji('success')} Reminder Deleted\",\r\n                            description=\"Your reminder has been deleted!\",\r\n                            color=GREEN_COLOR,\r\n                        ),\r\n                        view=None,\r\n                    )\r\n            else:\r\n                return await msg.edit(\r\n                    embed=discord.Embed(\r\n                        title=\"Invalid Reminder\",\r\n                        description=\"We could not find the reminder associated with that ID.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    view=None,\r\n                )\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(Reminders(bot))\r\n"}
{"type": "source_file", "path": "datamodels/ServerKeys.py", "content": "from discord.ext import commands\nimport discord\nfrom utils.mongo import Document\n\n\nclass BaseDataClass:\n    def __init__(self, *args, **kwargs):\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\n\nclass ServerKey(BaseDataClass):\n    guild_id: int\n    key: str\n\n\nclass ServerKeys(Document):\n    async def get_server_key(self, guild_id: int):\n        doc = await self.find_by_id(guild_id)\n        if not doc:\n            return None\n        return ServerKey(guild_id=doc[\"_id\"], key=doc[\"key\"])\n\n    async def insert_server_key(self, guild_id: int, key: str):\n        await self.upsert({\"_id\": guild_id, \"key\": key})\n"}
{"type": "source_file", "path": "cogs/Search.py", "content": "import datetime\r\nimport logging\r\n\r\nimport aiohttp\r\nimport discord\r\nimport pytz\r\nfrom discord import app_commands\r\nfrom discord.ext import commands\r\nfrom reactionmenu import ViewButton, ViewMenu, Page\r\nfrom reactionmenu.abc import _PageController\r\nfrom roblox import client as roblox\r\nimport roblox as rbx_api\r\n\r\nfrom datamodels.StaffConnections import StaffConnection\r\nfrom datamodels.Warnings import WarningItem\r\nfrom erm import check_privacy, is_staff, staff_predicate\r\nfrom utils.autocompletes import user_autocomplete\r\nfrom copy import copy\r\nfrom utils.constants import BLANK_COLOR\r\nfrom utils.utils import (\r\n    invis_embed,\r\n    failure_embed,\r\n    get_roblox_by_username,\r\n    require_settings,\r\n)\r\nfrom utils.paginators import SelectPagination, CustomPage\r\n\r\nclient = roblox.Client()\r\n\r\n\r\nclass Search(commands.Cog):\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n\r\n    @commands.guild_only()\r\n    @commands.hybrid_command(\r\n        name=\"mywarnings\",\r\n        aliases=[\"mymoderations\", \"mypunishments\", \"moderations\"],\r\n        description=\"Lookup your punishments with ERM.\",\r\n        extras={\"category\": \"Search\"},\r\n        with_app_command=True,\r\n    )\r\n    @require_settings()\r\n    async def mywarnings(\r\n        self, ctx: commands.Context, user: discord.Member = None\r\n    ):  # changing this to discord.Member, change back to discord.User in the event of error\r\n        if user is None:\r\n            user = ctx.author\r\n        guild_id = ctx.guild.id\r\n        if guild_id == 823606319529066548:\r\n            guild_id = 1015622817452138606\r\n        if self.bot.punishments_disabled is True:\r\n            return await failure_embed(\r\n                ctx,\r\n                \"This command is currently disabled as ERM is currently undergoing maintenance updates. This command will be turned off briefly to ensure that no data is lost during the maintenance. It will be returned shortly.\",\r\n            )\r\n\r\n        bot = self.bot\r\n        roblox_user = await bot.bloxlink.find_roblox(user.id)\r\n        if not roblox_user or not (roblox_user or {}).get(\"robloxID\"):\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Could not find user\",\r\n                    description=\"I could not find this user's ROBLOX account. Ensure that they are linked with Bloxlink and try again.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n        roblox_user = roblox_user[\"robloxID\"]\r\n\r\n        client = roblox.Client()\r\n        roblox_player = await client.get_user(roblox_user)\r\n\r\n        warnings: list[WarningItem] = (\r\n            await bot.punishments.get_warnings(roblox_player.id, guild_id) or []\r\n        )\r\n\r\n        player_information_embed = discord.Embed(\r\n            title=f\"{roblox_player.name}\",\r\n            color=BLANK_COLOR,\r\n        )\r\n        punishments_embed = discord.Embed(\r\n            title=player_information_embed.title,\r\n            color=BLANK_COLOR,\r\n        )\r\n        embed_list = [player_information_embed, punishments_embed]\r\n\r\n        magic_flags = {\r\n            \"ERM Team\": 1001972346661384302,\r\n            \"ERM Developer\": 1046204873496068176,\r\n            \"ERM Management\": 1038597868023447552,\r\n            \"ERM Senior Support\": 1028848687927013396,\r\n            \"ERM Support\": 1053417531278364713,\r\n            \"ERM Staff\": 988055417907200010,\r\n            \"ERM Quality Assurance\": 1306431506914218067,\r\n        }\r\n\r\n        magic_flags_reverse = {\r\n            v: k for k, v in magic_flags.items()\r\n        }  # this is reverse mapping for quick lookup\r\n\r\n        g_id = 987798554972143728\r\n        guild: discord.Guild = bot.get_guild(g_id)\r\n        applied_flags = set()  # use set to automatically remove duplicates\r\n        member: None | StaffConnection = await bot.staff_connections.fetch_by_spec(\r\n            roblox_id=roblox_player.id\r\n        )\r\n\r\n        if member:\r\n            try:\r\n                discord_member = await guild.fetch_member(member.discord_id)\r\n            except discord.NotFound:\r\n                discord_member = None\r\n\r\n            if discord_member:\r\n                applied_flags.update(\r\n                    magic_flags_reverse.get(role.id)\r\n                    for role in discord_member.roles\r\n                    if role.id in magic_flags_reverse\r\n                )\r\n\r\n        applied_flags = list(applied_flags)\r\n        if (\r\n            await bot.custom_flags.db.count_documents({\"roblox_id\": roblox_player.id})\r\n        ) > 0:\r\n            custom_flags = await bot.custom_flags.get_flags_by_roblox(roblox_player.id)\r\n            for item in custom_flags:\r\n                applied_flags.insert(0, f\"{item.name} {item.emoji or ''}\")\r\n\r\n        if applied_flags:\r\n            embed_list[0].add_field(\r\n                name=\"Player Flags\",\r\n                inline=False,\r\n                value=\"\".join([f\"{item}\\n\" for item in applied_flags]),\r\n            )\r\n\r\n        embed_list[0].add_field(\r\n            name=\"Player Information\",\r\n            value=(\r\n                f\"> **Username:** {roblox_player.name}\\n\"\r\n                f\"> **Display Name:** {roblox_player.display_name}\\n\"\r\n                f\"> **User ID:** `{roblox_player.id}`\\n\"\r\n                f\"> **Friend Count:** {await roblox_player.get_friend_count()}\\n\"\r\n                f\"> **Created At:** <t:{int(roblox_player.created.timestamp())}>\"\r\n            ),\r\n            inline=False,\r\n        )\r\n\r\n        if ctx.author == user:\r\n            embed_list[0].add_field(\r\n                name=\"Punishments\",\r\n                value=(\r\n                    f\"> **Total Punishments:** {len(warnings)}\\n\"\r\n                    f\"> **Warnings:** {len(list(filter(lambda x: x.warning_type == 'Warning', warnings)))}\\n\"\r\n                    f\"> **Kicks:** {len(list(filter(lambda x: x.warning_type == 'Kick', warnings)))}\\n\"\r\n                    f\"> **Bans:** {len(list(filter(lambda x: x.warning_type == 'Ban', warnings)))}\\n\"\r\n                    f\"> **BOLOs:** {len(list(filter(lambda x: x.warning_type.upper() == 'BOLO', warnings)))}\\n\"\r\n                    f\"> **Other:** {len(list(filter(lambda x: x.warning_type.upper() not in ['WARNING', 'KICK', 'BAN', 'BOLO'], warnings)))}\"\r\n                ),\r\n                inline=False,\r\n            )\r\n\r\n        new_ctx = copy(ctx)\r\n        new_ctx.author = user or ctx.author\r\n\r\n        if await staff_predicate(new_ctx):\r\n\r\n            moderator_id = user.id if user else ctx.author.id\r\n\r\n            moderations = list(\r\n                filter(\r\n                    lambda x: x is not None,\r\n                    [\r\n                        await bot.punishments.fetch_warning(i[\"_id\"])\r\n                        async for i in bot.punishments.db.find(\r\n                            {\"ModeratorID\": moderator_id, \"Guild\": guild_id}\r\n                        )\r\n                    ],\r\n                )\r\n            )\r\n\r\n            embed_list[0].add_field(\r\n                name=\"Staff Information\",\r\n                value=(\r\n                    f\"> **Total Moderations:** {len(moderations)}\\n\"\r\n                    f\"> **Warnings:** {len(list(filter(lambda x: x.warning_type == 'Warning', moderations)))}\\n\"\r\n                    f\"> **Kicks:** {len(list(filter(lambda x: x.warning_type == 'Kick', moderations)))}\\n\"\r\n                    f\"> **Bans:** {len(list(filter(lambda x: x.warning_type == 'Ban', moderations)))}\\n\"\r\n                    f\"> **BOLOs:** {len(list(filter(lambda x: x.warning_type.upper() == 'BOLO', moderations)))}\\n\"\r\n                    f\"> **Other:** {len(list(filter(lambda x: x.warning_type.upper() not in ['WARNING', 'KICK', 'BAN', 'BOLO'], moderations)))}\"\r\n                ),\r\n                inline=False,\r\n            )\r\n        else:\r\n            if user != ctx.author:\r\n                return await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=\"No Staff Moderations\",\r\n                        description=\"This user has no moderations that they've handed out, so they cannot be viewed for privacy reasons.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n        def add_warning_field(warning):\r\n            new_line = \"\\n\"\r\n            embed_list[-1].add_field(\r\n                name=f\"{warning['Type']}\",\r\n                inline=False,\r\n                value=(\r\n                    f\"> **Reason:** {warning.reason}\\n\"\r\n                    f\"> **At:** <t:{int(warning.time_epoch)}>\\n\"\r\n                    f'{\"> **Until:** <t:{}>{}\".format(int(warning.until_epoch), new_line) if warning.until_epoch is not None else \"\"}'\r\n                    f\"> **ID:** `{warning.snowflake}`\"\r\n                ),\r\n            )\r\n\r\n        for warning in warnings:\r\n            if ctx.author != user:\r\n                break\r\n            if len(embed_list[-1].fields) <= 2:\r\n                add_warning_field(warning)\r\n            else:\r\n                new_embed = discord.Embed(title=embed_list[0].title, color=BLANK_COLOR)\r\n                embed_list.append(new_embed)\r\n                add_warning_field(warning)\r\n\r\n        thumbnails = await client.thumbnails.get_user_avatar_thumbnails(\r\n            [roblox_player], type=rbx_api.thumbnails.AvatarThumbnailType.headshot\r\n        )\r\n        thumbnail_url = thumbnails[0].image_url\r\n        for embed in embed_list:\r\n            if len(embed.fields or []) == 0:\r\n                embed_list.remove(embed)\r\n            embed.set_thumbnail(url=thumbnail_url)\r\n            embed.set_author(\r\n                name=ctx.author.name, icon_url=ctx.author.display_avatar.url\r\n            )\r\n\r\n        pages = [\r\n            (\r\n                CustomPage(\r\n                    embeds=[embed],\r\n                    identifier=str(index + 1) if index != 0 else \"Player Information\",\r\n                )\r\n                if len(embed.fields) > 0\r\n                else None\r\n            )\r\n            for index, embed in enumerate(embed_list)\r\n        ]\r\n        paginator = SelectPagination(\r\n            self.bot, ctx.author.id, list(filter(lambda x: x is not None, pages))\r\n        )\r\n\r\n        # # print(embed_list)\r\n        # [# print(obj) for obj in [embed.to_dict() for embed in embed_list]]\r\n        if len(embed_list) == 1:\r\n            return await ctx.send(embeds=pages[0].embeds)\r\n\r\n        paginator.message = await ctx.send(embeds=pages[0].embeds, view=paginator)\r\n\r\n    @commands.guild_only()\r\n    @commands.hybrid_command(\r\n        name=\"search\",\r\n        aliases=[\"s\"],\r\n        description=\"Searches for a user in the warning database.\",\r\n        extras={\"category\": \"Search\"},\r\n        usage=\"<user>\",\r\n        with_app_command=True,\r\n    )\r\n    @is_staff()\r\n    @app_commands.autocomplete(query=user_autocomplete)\r\n    @app_commands.describe(\r\n        query=\"What is the user you want to search for? This can be a Discord mention or a ROBLOX username.\"\r\n    )\r\n    @require_settings()\r\n    async def search(self, ctx, *, query):\r\n        if self.bot.punishments_disabled is True:\r\n            return await failure_embed(\r\n                ctx,\r\n                \"This command is currently disabled as ERM is currently undergoing maintenance updates. This command will be turned off briefly to ensure that no data is lost during the maintenance. It will be returned shortly.\",\r\n            )\r\n\r\n        bot = self.bot\r\n        alerts = {\r\n            \"NoAlerts\": \"No alerts found for this account!\",\r\n            \"AccountAge\": \"The account age of the user is less than 100 days.\",\r\n            \"NotManyFriends\": \"This user has less than 30 friends.\",\r\n            # \"NotManyGroups\": \"This user has less than 5 groups.\", - Flag has been removed for rate-limiting purposes\r\n            \"HasBOLO\": \"This user has a BOLO active.\",\r\n            \"IsBanned\": \"This user is banned from Roblox.\",\r\n        }\r\n\r\n        user = query\r\n        roblox_user = await get_roblox_by_username(user, bot, ctx)\r\n        if roblox_user.get(\"errors\"):\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Could not find player\",\r\n                    description=\"I could not find a ROBLOX player with that corresponding username.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        client = roblox.Client()\r\n        roblox_player = await client.get_user_by_username(roblox_user[\"name\"])\r\n\r\n        warnings: list[WarningItem] = (\r\n            await bot.punishments.get_warnings(roblox_player.id, ctx.guild.id) or []\r\n        )\r\n\r\n        player_information_embed = discord.Embed(\r\n            title=f\"{roblox_player.name}\",\r\n            color=BLANK_COLOR,\r\n        )\r\n        punishments_embed = discord.Embed(\r\n            title=player_information_embed.title,\r\n            color=BLANK_COLOR,\r\n        )\r\n        embed_list = [player_information_embed, punishments_embed]\r\n\r\n        alert_maps = {\r\n            \"IsBanned\": roblox_player.is_banned,\r\n            \"AccountAge\": (\r\n                datetime.datetime.now(tz=pytz.UTC) - roblox_player.created\r\n            ).days\r\n            < 100,\r\n            \"NotManyFriends\": (await roblox_player.get_friend_count()) < 30,\r\n            # \"NotManyGroups\": len(await roblox_player.get_group_roles()) < 5, - This flag has been removed for ratelimiting purposes\r\n            \"HasBOLO\": \"BOLO\" in [warning.warning_type.upper() for warning in warnings],\r\n        }\r\n        triggered_alerts = [\r\n            item[0] for item in list(filter(lambda x: x[1] is True, alert_maps.items()))\r\n        ] or [\"NoAlerts\"]\r\n\r\n        magic_flags = {\r\n            \"ERM Team\": 1001972346661384302,\r\n            \"ERM Developer\": 1046204873496068176,\r\n            \"ERM Management\": 1038597868023447552,\r\n            \"ERM Senior Support\": 1028848687927013396,\r\n            \"ERM Support\": 1053417531278364713,\r\n            \"ERM Staff\": 988055417907200010,\r\n            \"ERM Quality Assurance\": 1306431506914218067,\r\n        }\r\n\r\n        magic_flags_reverse = {\r\n            v: k for k, v in magic_flags.items()\r\n        }  # this is reverse mapping for quick lookup\r\n\r\n        guild_id = 987798554972143728\r\n        guild: discord.Guild = bot.get_guild(guild_id)\r\n        applied_flags = set()  # use set to automatically remove duplicates\r\n        member: None | StaffConnection = await bot.staff_connections.fetch_by_spec(\r\n            roblox_id=roblox_player.id\r\n        )\r\n\r\n        if member:\r\n            try:\r\n                discord_member = await guild.fetch_member(member.discord_id)\r\n            except discord.NotFound:\r\n                discord_member = None\r\n\r\n            if discord_member:\r\n                applied_flags.update(\r\n                    magic_flags_reverse.get(role.id)\r\n                    for role in discord_member.roles\r\n                    if role.id in magic_flags_reverse\r\n                )\r\n\r\n        applied_flags = list(applied_flags)\r\n        if (\r\n            await bot.custom_flags.db.count_documents({\"roblox_id\": roblox_player.id})\r\n        ) > 0:\r\n            custom_flags = await bot.custom_flags.get_flags_by_roblox(roblox_player.id)\r\n            for item in custom_flags:\r\n                applied_flags.insert(0, f\"{item.name} {item.emoji or ''}\")\r\n\r\n        if applied_flags:\r\n            embed_list[0].add_field(\r\n                name=\"Player Flags\",\r\n                inline=False,\r\n                value=\"\".join([f\"{item}\\n\" for item in applied_flags]),\r\n            )\r\n\r\n        # TODO: Flag Interpretation\r\n\r\n        embed_list[0].add_field(\r\n            name=\"Player Information\",\r\n            value=(\r\n                f\"> **Username:** {roblox_player.name}\\n\"\r\n                f\"> **Display Name:** {roblox_player.display_name}\\n\"\r\n                f\"> **User ID:** `{roblox_player.id}`\\n\"\r\n                f\"> **Friend Count:** {await roblox_player.get_friend_count()}\\n\"\r\n                f\"> **Created At:** <t:{int(roblox_player.created.timestamp())}>\"\r\n            ),\r\n            inline=False,\r\n        )\r\n\r\n        embed_list[0].add_field(\r\n            name=\"Punishments\",\r\n            value=(\r\n                f\"> **Total Punishments:** {len(warnings)}\\n\"\r\n                f\"> **Warnings:** {len(list(filter(lambda x: x.warning_type == 'Warning', warnings)))}\\n\"\r\n                f\"> **Kicks:** {len(list(filter(lambda x: x.warning_type == 'Kick', warnings)))}\\n\"\r\n                f\"> **Bans:** {len(list(filter(lambda x: x.warning_type == 'Ban', warnings)))}\\n\"\r\n                f\"> **BOLOs:** {len(list(filter(lambda x: x.warning_type.upper() == 'BOLO', warnings)))}\\n\"\r\n                f\"> **Other:** {len(list(filter(lambda x: x.warning_type.upper() not in ['WARNING', 'KICK', 'BAN', 'BOLO'], warnings)))}\"\r\n            ),\r\n            inline=False,\r\n        )\r\n\r\n        string = \"\\n\".join([f\"{alerts[i]}\" for i in triggered_alerts])\r\n\r\n        embed_list[0].add_field(\r\n            name=\"Player Alerts\",\r\n            value=f\"{string}\",\r\n            inline=False,\r\n        )\r\n\r\n        # # # print(result)\r\n        def add_warning_field(warning):\r\n            new_line = \"\\n\"\r\n            embed_list[-1].add_field(\r\n                name=f\"{warning['Type']}\",\r\n                inline=False,\r\n                value=(\r\n                    f\"> **Moderator:** <@{warning.moderator_id}>\\n\"\r\n                    f\"> **Reason:** {warning.reason}\\n\"\r\n                    f\"> **At:** <t:{int(warning.time_epoch)}>\\n\"\r\n                    f'{\"> **Until:** <t:{}>{}\".format(int(warning.until_epoch), new_line) if warning.until_epoch is not None else \"\"}'\r\n                    f\"> **ID:** `{warning.snowflake}`\"\r\n                ),\r\n            )\r\n\r\n        for warning in warnings:\r\n            if len(embed_list[-1].fields) <= 2:\r\n                add_warning_field(warning)\r\n            else:\r\n                new_embed = discord.Embed(title=embed_list[0].title, color=BLANK_COLOR)\r\n                embed_list.append(new_embed)\r\n                add_warning_field(warning)\r\n\r\n        thumbnails = await client.thumbnails.get_user_avatar_thumbnails(\r\n            [roblox_player], type=rbx_api.thumbnails.AvatarThumbnailType.headshot\r\n        )\r\n        thumbnail_url = thumbnails[0].image_url\r\n        for embed in embed_list:\r\n            if len(embed.fields or []) == 0:\r\n                embed_list.remove(embed)\r\n            embed.set_thumbnail(url=thumbnail_url)\r\n            embed.set_author(\r\n                name=ctx.author.name, icon_url=ctx.author.display_avatar.url\r\n            )\r\n\r\n        pages = [\r\n            (\r\n                CustomPage(embeds=[embed], identifier=str(index + 1))\r\n                if len(embed.fields) > 0\r\n                else None\r\n            )\r\n            for index, embed in enumerate(embed_list)\r\n        ]\r\n        paginator = SelectPagination(\r\n            self.bot, ctx.author.id, list(filter(lambda x: x is not None, pages))\r\n        )\r\n\r\n        # # print(embed_list)\r\n        # [# print(obj) for obj in [embed.to_dict() for embed in embed_list]]\r\n        if len(embed_list) == 1:\r\n            return await ctx.send(embeds=pages[0].embeds)\r\n\r\n        paginator.message = await ctx.send(embeds=pages[0].embeds, view=paginator)\r\n\r\n    @commands.hybrid_command(\r\n        name=\"userid\",\r\n        aliases=[\"u\"],\r\n        description=\"Returns the User Id of a searched user.\",\r\n        extras={\"category\": \"Search\"},\r\n        usage=\"<user>\",\r\n        with_app_command=True,\r\n    )\r\n    @app_commands.autocomplete(query=user_autocomplete)\r\n    @app_commands.describe(\r\n        query=\"What is the user you want to search for? This can be a Discord mention or a ROBLOX username.\"\r\n    )\r\n    async def userid(self, ctx, *, query):\r\n        bot = self.bot\r\n        user = query\r\n\r\n        user = query\r\n        roblox_user = await get_roblox_by_username(user, bot, ctx)\r\n        if roblox_user.get(\"errors\"):\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Could not find player\",\r\n                    description=\"I could not find a ROBLOX player with that corresponding username.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        client = roblox.Client()\r\n        roblox_player = await client.get_user_by_username(roblox_user[\"name\"])\r\n        thumbnails = await client.thumbnails.get_user_avatar_thumbnails(\r\n            [roblox_player], type=rbx_api.thumbnails.AvatarThumbnailType.headshot\r\n        )\r\n        thumbnail = thumbnails[0].image_url\r\n        embed = discord.Embed(title=roblox_player.name, color=BLANK_COLOR)\r\n\r\n        embed.set_author(name=ctx.author.name, icon_url=ctx.author.display_avatar.url)\r\n\r\n        embed.add_field(\r\n            name=\"Player Information\",\r\n            value=(\r\n                f\"> **Username:** {roblox_player.name}\\n\"\r\n                f\"> **Display Name:** {roblox_player.display_name}\\n\"\r\n                f\"> **User ID:** `{roblox_player.id}`\\n\"\r\n                f\"> **Created At:** <t:{int(roblox_player.created.timestamp())}>\"\r\n            ),\r\n            inline=False,\r\n        )\r\n\r\n        embed.add_field(\r\n            name=\"Player Counts\",\r\n            value=(\r\n                f\"> **Friends:** {await roblox_player.get_friend_count()}\\n\"\r\n                f\"> **Followers:** {await roblox_player.get_follower_count()}\\n\"\r\n                f\"> **Following:** {await roblox_player.get_following_count()}\\n\"\r\n                f\"> **Groups:** {len(await roblox_player.get_group_roles())}\\n\"\r\n            ),\r\n        )\r\n\r\n        embed.set_thumbnail(url=thumbnail)\r\n        embed.set_footer(text=\"Search Module\")\r\n        await ctx.send(embed=embed)\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(Search(bot))\r\n"}
{"type": "source_file", "path": "datamodels/ProhibitedUseKeys.py", "content": "from discord.ext import commands\nimport discord\nfrom utils.mongo import Document\n\n\nclass ProhibitedUseKeys(Document):\n    pass\n"}
{"type": "source_file", "path": "datamodels/Actions.py", "content": "from discord.ext import commands\nimport discord\nfrom utils.mongo import Document\n\n\nclass Actions(Document):\n    pass\n"}
{"type": "source_file", "path": "datamodels/CustomFlags.py", "content": "from discord.ext import commands\nimport discord\nfrom utils.mongo import Document\n\n\nclass FlagItem:\n    emoji: str\n    name: str\n\n    def __init__(self, **kwargs):\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\n\nclass CustomFlags(Document):\n    async def get_flags_by_roblox(self, roblox_id: int):\n        document = await self.db.find_one({\"roblox_id\": roblox_id})\n        flags = []\n        for item in document[\"flags\"]:\n            flags.append(FlagItem(name=item[\"name\"], emoji=item[\"emoji\"]))\n        return flags\n"}
{"type": "source_file", "path": "cogs/Actions.py", "content": "import discord\nfrom discord.ext import commands\nimport asyncio\nimport datetime\nimport pytz\nfrom erm import is_management, is_staff, is_admin\nfrom utils.constants import BLANK_COLOR, GREEN_COLOR\nfrom menus import ManageActions, CounterButton, ViewVotersButton\nfrom discord import app_commands\nfrom utils.autocompletes import action_autocomplete\nfrom utils.utils import interpret_content, interpret_embed, log_command_usage\n\n\nclass Actions(commands.Cog):\n    def __init__(self, bot: commands.Bot):\n        self.bot: commands.Bot = bot\n\n    @commands.hybrid_group(\n        name=\"actions\", description=\"Manage your ERM Actions easily.\"\n    )\n    async def actions(self, ctx: commands.Context):\n        pass\n\n    @actions.command(name=\"manage\", description=\"Manage your ERM Actions easily.\")\n    @is_admin()\n    async def actions_manage(self, ctx: commands.Context):\n        await log_command_usage(self.bot, ctx.guild, ctx.author, f\"Actions Manage\")\n        actions = [i async for i in self.bot.db.actions.find({\"Guild\": ctx.guild.id})]\n\n        embeds = []\n        current_embed = discord.Embed(title=\"Actions\", color=BLANK_COLOR).set_author(\n            name=ctx.guild.name, icon_url=ctx.guild.icon\n        )\n\n        for item in actions:\n            if len(current_embed.fields) >= 5:\n                embeds.append(current_embed)\n                current_embed = discord.Embed(\n                    title=\"Actions (cont.)\", color=BLANK_COLOR\n                )\n\n            current_embed.add_field(\n                name=item[\"ActionName\"],\n                value=(\n                    f\"> **Name:** {item['ActionName']}\\n\"\n                    f\"> **ID:** `{item['ActionID']}`\\n\"\n                    f\"> **Triggered:** {item['Triggers']}\"\n                ),\n                inline=False,\n            )\n\n        if len(current_embed.fields) == 0:\n            current_embed.add_field(\n                name=\"No Actions\",\n                value=\"> There are no actions in this server.\",\n                inline=False,\n            )\n\n        embeds.append(current_embed)\n\n        view = ManageActions(self.bot, ctx.author.id)\n        await ctx.send(embeds=embeds, view=view)\n        timeout = await view.wait()\n        if timeout:\n            return\n\n    @actions.command(name=\"execute\", description=\"Execute an ERM Action in your server\")\n    @is_staff()\n    @app_commands.autocomplete(action=action_autocomplete)\n    async def action_execute(self, ctx: commands.Context, *, action: str):\n\n        verbose = False\n        dnr = False\n        if \"--verbose\" in action:\n            action = action.replace(\" --verbose\", \"\")\n            verbose = True\n        try:\n            dnr = getattr(ctx, \"dnr\")  # prevent privilege bypassing! no black hats\n        except Exception as _:\n            dnr = False\n\n        ctx.verbose = verbose\n\n        actions = [\n            i async for i in self.bot.actions.db.find({\"Guild\": ctx.guild.id})\n        ] or []\n        action_obj = None\n        for item in actions:\n            if item[\"ActionName\"] == action:\n                action_obj = item\n                break\n        if not action_obj and not dnr:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Invalid Action Name\",\n                    description=\"The name you provided does not correspond with an action on this server. Run `/actions manage` for details.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        if action_obj.get(\"AccessRoles\"):\n            if (\n                not any(\n                    [discord.utils.get(ctx.guild.roles, id=i) in ctx.author.roles]\n                    for i in action_obj.get(\"AccessRoles\")\n                )\n                and not dnr\n            ):\n                return await ctx.send(\n                    embed=discord.Embed(\n                        title=\"Access Denied\",\n                        description=\"You do not hold the roles required to use this action. Contact your Server Administrator for details.\",\n                        color=BLANK_COLOR,\n                    )\n                )\n        #   actions = [\n        #     'Execute Custom Command',\n        #     'Pause Reminder',\n        #     'Force All Staff Off Duty',\n        #     'Send ER:LC Command',\n        #     'Send ER:LC Message',\n        #     'Send ER:LC Hint',\n        #     'Delay'\n        # ]\n\n        funcs = [\n            self.execute_custom_command,\n            self.pause_reminder,\n            self.force_off_duty,\n            self.send_erlc_command,\n            self.send_erlc_message,\n            self.send_erlc_hint,\n            self.delay,\n            self.add_role,\n            self.remove_role,\n        ]\n\n        if not dnr:\n            msg = await ctx.send(\n                embed=discord.Embed(\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Running Action\",\n                    description=f\"**(0/{len(action_obj['Integrations'])})** I am currently running your action!\",\n                    color=GREEN_COLOR,\n                )\n            )\n\n        chosen_funcs = []\n        for item in action_obj[\"Integrations\"]:\n            chosen_funcs.append(\n                [funcs[item[\"IntegrationID\"]], item[\"ExtraInformation\"]]\n            )\n\n        returns = []\n        if dnr:\n            chosen_funcs = list(\n                filter(\n                    lambda x: x not in [self.add_role, self.remove_role], chosen_funcs\n                )\n            )\n\n        for func, param in chosen_funcs:\n            if param is None:\n                returns.append(await func(self.bot, ctx.guild.id, ctx))\n            else:\n                returns.append(await func(self.bot, ctx.guild.id, ctx, param))\n            if not dnr:\n                await msg.edit(\n                    embed=discord.Embed(\n                        title=f\"{self.bot.emoji_controller.get_emoji('success')} Running Action\",\n                        description=f\"**({len(list(filter(lambda x: x == 0, returns)))}/{len(action_obj['Integrations'])})** I am currently running your action!{' `{}`'.format(returns) if verbose else ''}\",\n                        color=GREEN_COLOR,\n                    )\n                )\n\n    @staticmethod\n    async def add_role(bot: commands.Bot, guild_id: int, context, role_id: int):\n        try:\n            guild = await bot.fetch_guild(guild_id)\n            role = guild.get_role(role_id)\n        except discord.HTTPException:\n            return 1\n\n        if not role:\n            return 1\n\n        try:\n            await context.author.add_roles(role)\n        except discord.HTTPException:\n            return 1\n\n    @staticmethod\n    async def remove_role(bot: commands.Bot, guild_id: int, context, role_id: int):\n        try:\n            guild = await bot.fetch_guild(guild_id)\n            role = guild.get_role(role_id)\n        except discord.HTTPException:\n            return 1\n\n        if not role:\n            return 1\n\n        try:\n            await context.author.remove_roles(role)\n        except discord.HTTPException:\n            return 1\n\n    @staticmethod\n    async def execute_custom_command(\n        bot, guild_id: int, context, custom_command_name: str\n    ):\n        Data = await bot.custom_commands.find_by_id(guild_id)\n        guild = context.guild\n        if Data is None:\n            return 1\n\n        is_command = False\n        selected = None\n        if \"commands\" in Data.keys():\n            if isinstance(Data[\"commands\"], list):\n                for cmd in Data[\"commands\"]:\n                    if cmd[\"name\"].lower().replace(\n                        \" \", \"\"\n                    ) == custom_command_name.lower().replace(\" \", \"\"):\n                        is_command = True\n                        selected = cmd\n\n        if not is_command:\n            return 1\n\n        channel = None\n        if not channel:\n            if selected.get(\"channel\") is None:\n                channel = context.channel\n            else:\n                channel = (\n                    discord.utils.get(guild.text_channels, id=selected[\"channel\"])\n                    if discord.utils.get(guild.text_channels, id=selected[\"channel\"])\n                    is not None\n                    else context.channel\n                )\n        embeds = []\n        for embed in selected[\"message\"][\"embeds\"]:\n            embeds.append(\n                await interpret_embed(bot, context, channel, embed, selected[\"id\"])\n            )\n\n        view = discord.ui.View()\n        for item in selected.get(\"buttons\", []):\n            if item[\"label\"] == \"0\" and \"row\" in item:\n                counter_button = CounterButton(row=item[\"row\"])\n                view_voters_button = ViewVotersButton(\n                    row=item[\"row\"], counter_button=counter_button\n                )\n                view.add_item(counter_button)\n                view.add_item(view_voters_button)\n            else:\n                view.add_item(\n                    discord.ui.Button(\n                        label=item[\"label\"],\n                        url=item[\"url\"],\n                        row=item[\"row\"],\n                        style=discord.ButtonStyle.url,\n                    )\n                )\n\n        if (\n            selected[\"message\"][\"content\"] in [None, \"\"]\n            and len(selected[\"message\"][\"embeds\"]) == 0\n        ):\n            return 1\n\n        msg = await channel.send(\n            await interpret_content(\n                bot, context, channel, selected[\"message\"][\"content\"], selected[\"id\"]\n            ),\n            embeds=embeds,\n            view=view,\n            allowed_mentions=discord.AllowedMentions(\n                everyone=True, users=True, roles=True, replied_user=True\n            ),\n        )\n\n        # Fetch ICS entry\n        doc = await bot.ics.find_by_id(selected[\"id\"]) or {}\n        if doc in [None, {}]:\n            return 0  # This is still successful, just means it doesn't use ICS\n        doc[\"associated_messages\"] = (\n            [(channel.id, msg.id)]\n            if not doc.get(\"associated_messages\")\n            else doc[\"associated_messages\"] + [(channel.id, msg.id)]\n        )\n        await bot.ics.update_by_id(doc)\n        return 0\n\n    @staticmethod\n    async def pause_reminder(bot, guild_id: int, context, reminder_name: str):\n        reminder_data = await bot.reminders.find_by_id(guild_id) or []\n\n        for index, item in enumerate(reminder_data[\"reminders\"]):\n            if item[\"name\"] == reminder_name:\n                if item.get(\"paused\") is True:\n                    item[\"paused\"] = False\n                    reminder_data[\"reminders\"][index] = item\n                    await bot.reminders.upsert(reminder_data)\n                    return 0\n                else:\n                    item[\"paused\"] = True\n                    reminder_data[\"reminders\"][index] = item\n                    await bot.reminders.upsert(reminder_data)\n                    return 0\n\n        return 1\n\n    @staticmethod\n    async def force_off_duty(bot, guild_id: int, context):\n        docs = [\n            i\n            async for i in bot.shift_management.shifts.db.find(\n                {\"Guild\": guild_id, \"EndEpoch\": 0}\n            )\n        ]\n        for item in docs:\n            id = item[\"_id\"]\n            await bot.shift_management.shifts.db.update_one(\n                {\"_id\": id},\n                {\n                    \"$set\": {\n                        \"EndEpoch\": int(datetime.datetime.now(tz=pytz.UTC).timestamp())\n                    }\n                },\n            )\n            bot.dispatch(\"shift_end\", id)\n            if context.verbose:\n                await context.send(item)\n        return 0\n\n    @staticmethod\n    async def send_erlc_command(bot, guild_id: int, context, command: str):\n        if command[0] != \":\":\n            command = \":\" + command\n\n        command_response = await bot.prc_api.run_command(guild_id, f\"{command}\")\n        if command_response[0] == 200:\n            return 0\n\n        if command_response[0] != 429:\n            return 1\n\n        wait_time = command_response[1][\"retry_after\"]\n        await asyncio.sleep(wait_time + 1)\n        command_response = await bot.prc_api.run_command(guild_id, f\"{command}\")\n        if command_response[0] == 200:\n            return 0\n\n        if command_response[0] != 429:\n            return 1\n\n    @staticmethod\n    async def send_erlc_message(bot, guild_id: int, context, message: str):\n        if message[:3] == \":m \":\n            message = message[3:]\n        elif message[:2] == \"m \":\n            message = message[2:]\n\n        command_response = await bot.prc_api.run_command(guild_id, f\":m {message}\")\n        if command_response[0] == 200:\n            return 0\n\n        if command_response[0] != 429:\n            return 1\n\n        wait_time = command_response[1][\"retry_after\"]\n        await asyncio.sleep(wait_time + 1)\n        command_response = await bot.prc_api.run_command(guild_id, f\":m {message}\")\n        if command_response[0] == 200:\n            return 0\n\n        if command_response[0] != 429:\n            return 1\n\n    @staticmethod\n    async def send_erlc_hint(bot, guild_id: int, context, hint: str):\n        if hint[:3] == \":h \":\n            hint = hint[3:]\n\n        command_response = await bot.prc_api.run_command(guild_id, f\":h {hint}\")\n        if command_response[0] == 200:\n            return 0\n\n        if command_response[0] != 429:\n            return 1\n\n        wait_time = command_response[1][\"retry_after\"]\n        await asyncio.sleep(wait_time + 1)\n        command_response = await bot.prc_api.run_command(guild_id, f\":h {hint}\")\n        if command_response[0] == 200:\n            return 0\n\n        if command_response[0] != 429:\n            return 1\n\n    @staticmethod\n    async def delay(bot, guild_id, context, timer: int):\n        ## FOR THIS EXAMPLE, WE DO NOT NEED BOT AND GUILD ID\n        del bot\n        del guild_id\n        del context\n\n        try:\n            await asyncio.sleep(int(timer))\n        except:\n            return 1\n        return 0\n\n\nasync def setup(bot: commands.Bot):\n    await bot.add_cog(Actions(bot))\n"}
{"type": "source_file", "path": "cogs/StaffConduct.py", "content": "import datetime\nimport discord\nimport pytz\nfrom discord.ext import commands\nfrom erm import is_management\nfrom menus import (\n    YesNoMenu,\n    AcknowledgeMenu,\n    YesNoExpandedMenu,\n    CustomModalView,\n    CustomSelectMenu,\n    MultiSelectMenu,\n    RoleSelect,\n    ExpandedRoleSelect,\n    MessageCustomisation,\n    EmbedCustomisation,\n    ChannelSelect,\n)\n\nsuccessEmoji = \"<:ERMCheck:1111089850720976906>\"\npendingEmoji = \"<:ERMPending:1111097561588183121>\"\nerrorEmoji = \"<:ERMClose:1111101633389146223>\"\nembedColour = 0xED4348\n\n\nclass StaffConduct(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n\n    async def check_settings(self, ctx: commands.Context):\n        error_text = \"<:ERMClose:1111101633389146223> **{},** this server isn't setup with ERM! Please run `/setup` to setup the bot before trying to manage infractions\".format(\n            ctx.author.name\n        )\n        guild_settings = await self.bot.settings.find_by_id(ctx.guild.id)\n        # print(guild_settings)\n        # print(guild_settings.get('staff_conduct'))\n        if not guild_settings:\n            await ctx.reply(error_text)\n            return -1\n\n        if guild_settings.get(\"staff_conduct\") is not None:\n            return 1\n        else:\n            return 0\n\n    @commands.hybrid_group(\n        name=\"infraction\",\n        description=\"Manage infractions with ease!\",\n        extras={\"category\": \"Staff Conduct\"},\n    )\n    @is_management()\n    async def infraction(self, ctx: commands.Context):\n        pass\n\n    @infraction.command(\n        name=\"manage\",\n        description=\"Manage staff infractions, staff conduct, and custom integrations!\",\n        extras={\"category\": \"Staff Conduct\"},\n    )\n    @is_management()\n    async def manage(self, ctx: commands.Context):\n        bot = self.bot\n        guild_settings = await bot.settings.find_by_id(ctx.guild.id)\n        result = await self.check_settings(ctx)\n        if result == -1:\n            return\n        first_time_setup = bool(not result)\n\n        if first_time_setup:\n            view = YesNoExpandedMenu(ctx.author.id)\n            message = await ctx.reply(\n                f\"{pendingEmoji} **{ctx.author.name},** it looks like your server hasn't setup **Staff Conduct**! Do you want to run the **First-time Setup** wizard?\",\n                view=view,\n            )\n            timeout = await view.wait()\n            if timeout:\n                return\n            if not view.value:\n                await message.edit(\n                    content=f\"{errorEmoji} **{ctx.author.name},** I have cancelled the setup wizard for **Staff Conduct.**\",\n                    view=None,\n                )\n                return\n\n            embed = discord.Embed(\n                title=\"<:ERMAlert:1113237478892130324> Information\", color=embedColour\n            )\n            embed.set_thumbnail(\n                url=\"https://cdn.discordapp.com/emojis/1113210855891423302.webp?size=96&quality=lossless\"\n            )\n            embed.add_field(\n                name=\"<:ERMList:1111099396990435428> What is Staff Conduct?\",\n                value=\">>> Staff Conduct is a module within ERM which allows for infractions on your Staff team. Not only does it allow for manual punishments and infractions to others to be expanded and customised, it also allows for automatic punishments for those that don't meet activity requirements, integrating with other ERM modules.\",\n                inline=False,\n            )\n            embed.add_field(\n                name=\"<:ERMList:1111099396990435428> How does this module work?\",\n                value=\">>> For manual punishment assignment, you make your own Infraction Types, as dictated throughout this setup wizard. You can then infract staff members by using `/infract`, which will assign that Infraction Type to the staff individual. You will be able to see all infractions that individual has received, as well as any notes or changes that have been made over the course of their staff career.\",\n                inline=False,\n            )\n            embed.add_field(\n                name=\"<:ERMList:1111099396990435428> If I have a Strike 1/2/3 system, do I have them as separate types?\",\n                value=\">>> In the case where you have a counting infraction system, you can tell ERM to count the strikes automatically! It will then take the according actions that correspond with that infraction amount.\",\n                inline=False,\n            )\n            embed.set_footer(\n                text=\"This module is in beta, and bugs are to be expected. If you notice a problem with this module, report it via our Support server.\"\n            )\n            embed.timestamp = datetime.datetime.now()\n            embed.set_author(name=ctx.author.name, icon_url=ctx.author.display_avatar)\n\n            view = AcknowledgeMenu(\n                ctx.author.id, \"Read the information in full before acknowledging.\"\n            )\n            await message.edit(\n                content=f\"{pendingEmoji} **{ctx.author.name},** please read all the information below before continuing.\",\n                embed=embed,\n                view=view,\n            )\n            timeout = await view.wait()\n            if timeout or not view.value:\n                return\n\n            await message.edit(\n                content=f\"{pendingEmoji} **{ctx.author.name},** let's begin!\",\n                embed=None,\n                view=(\n                    view := CustomModalView(\n                        ctx.author.id,\n                        \"Add an Infraction Type\",\n                        \"Add Infraction Type\",\n                        [\n                            (\n                                \"type_name\",\n                                discord.ui.TextInput(\n                                    placeholder=\"e.g. Strike, Termination, Suspension, Blacklist\",\n                                    label=\"Name of Infraction Type\",\n                                ),\n                            )\n                        ],\n                    )\n                ),\n            )\n            timeout = await view.wait()\n            if timeout:\n                return\n\n            try:\n                infraction_type_name = view.modal.type_name.value\n            except AttributeError:\n                return\n\n            await message.edit(\n                content=f\"{pendingEmoji} **{ctx.author.name},** what actions do you want to add to **{infraction_type_name}**?\",\n                view=(\n                    view := CustomSelectMenu(\n                        ctx.author.id,\n                        [\n                            discord.SelectOption(\n                                label=\"Add Role\",\n                                description='Add a role, such as a \"Strike\" role to the individual',\n                                emoji=\"<:ERMAdd:1113207792854106173>\",\n                                value=\"add_role\",\n                            ),\n                            discord.SelectOption(\n                                label=\"Remove Role\",\n                                description='Remove an individual role, such as \"Trained\", from an individual.',\n                                emoji=\"<:ERMRemove:1113207777662345387>\",\n                                value=\"remove_role\",\n                            ),\n                            discord.SelectOption(\n                                label=\"Remove Staff Roles\",\n                                description=\"Remove all designated staff roles from an individual.\",\n                                emoji=\"<:ERMWarn:1113236697702989905>\",\n                                value=\"remove_staff_roles\",\n                            ),\n                            discord.SelectOption(\n                                label=\"Send Direct Message\",\n                                description=\"Send a Direct Message to the individual involved.\",\n                                emoji=\"<:ERMUser:1111098647485108315>\",\n                                value=\"send_dm\",\n                            ),\n                            discord.SelectOption(\n                                label=\"Send Message in Channel\",\n                                description=\"Send a Custom Message in a Channel\",\n                                emoji=\"<:ERMLog:1113210855891423302>\",\n                                value=\"send_message\",\n                            ),\n                            discord.SelectOption(\n                                label=\"Send Escalation Request\",\n                                description=\"Request for a Management member to complete extra actions\",\n                                emoji=\"<:ERMHelp:1111318459305951262>\",\n                                value=\"send_escalation\",\n                            ),\n                        ],\n                        limit=6,\n                    )\n                ),\n            )\n\n            await view.wait()\n\n            value: list | None = None\n            if isinstance(view.value, str):\n                value = [view.value]\n            elif isinstance(view.value, list):\n                value = view.value\n            # WE NEED TO MAKE THESE MESSAGES MORE NOTICABLE FOR WHICH YOU PICKED\n            # noticeable* 🤓\n            for item in value:\n                if item == \"add_role\":  # Add to Database\n                    await message.edit(\n                        content=f\"{pendingEmoji} **{ctx.author.name},** what roles do you wish to be assigned when \\\n                    a user receives a **{infraction_type_name}**?\",\n                        view=(view := ExpandedRoleSelect(ctx.author.id, limit=25)),\n                    )\n                    await view.wait()\n                    addRoleList = view.value\n                elif item == \"remove_role\":  # Add to Database\n                    await message.edit(\n                        content=f\"{pendingEmoji} **{ctx.author.name},** what roles do you wish to be removed when \\\na user receives a **{infraction_type_name}**?\",\n                        view=(view := ExpandedRoleSelect(ctx.author.id, limit=25)),\n                    )\n                    await view.wait()\n                    removeRoleList = view.value\n                elif item == \"remove_staff_roles\":  # Add to Database\n                    await message.edit(\n                        content=f\"{pendingEmoji} **{ctx.author.name},** what staff roles do you wish to be affected \\\nwhen a user receives a **{infraction_type_name}**?\",\n                        view=(view := ExpandedRoleSelect(ctx.author.id, limit=25)),\n                    )\n                    await view.wait()\n                    staffRoleList = view.value\n                elif item == \"send_dm\":  # Add to Database\n                    constant_msg_data = None\n                    while True:\n                        if not constant_msg_data:\n                            view = MessageCustomisation(\n                                ctx.author.id, persist=True, external=True\n                            )\n                        else:\n                            if constant_msg_data.get(\"embeds\"):\n                                view = EmbedCustomisation(\n                                    ctx.author.id,\n                                    MessageCustomisation(\n                                        ctx.author.id,\n                                        {\"message\": constant_msg_data},\n                                        persist=True,\n                                        external=True,\n                                    ),\n                                    external=True,\n                                )\n                            else:\n                                view = MessageCustomisation(\n                                    ctx.author.id,\n                                    {\"message\": constant_msg_data},\n                                    persist=True,\n                                    external=True,\n                                )\n\n                        if not constant_msg_data:\n                            await message.edit(\n                                content=f\"{pendingEmoji} **{ctx.author.name},** please set the message you wish to send \\\na user upon receiving a **{infraction_type_name}**.\",\n                                view=view,\n                            )\n                        else:\n                            await message.edit(\n                                content=(\n                                    f\"{pendingEmoji} **{ctx.author.name},** please set the message you wish to send \\\na user upon receiving a **{infraction_type_name}**.\"\n                                    if not message_data.get(\"content\")\n                                    else message_data.get(\"content\")\n                                ),\n                                embeds=[\n                                    discord.Embed.from_dict(embed)\n                                    for embed in message_data.get(\"embeds\")\n                                ],\n                                view=view,\n                            )\n                        await view.wait()\n                        updated_message = await ctx.channel.fetch_message(message.id)\n                        message_data = {\n                            \"content\": (\n                                updated_message.content\n                                if updated_message.content\n                                != f\"{pendingEmoji} **{ctx.author.name},** please set the message you wish to send a user upon receiving a **{infraction_type_name}**.\"\n                                else \"\"\n                            ),\n                            \"embeds\": [i.to_dict() for i in updated_message.embeds],\n                        }\n                        yesNoValue = YesNoMenu(ctx.author.id)\n                        await message.edit(\n                            content=f\"{pendingEmoji} **{ctx.author.name},** please confirm below that you wish to use the content shown below.\\n\\n{message_data['content']}\",\n                            embeds=[\n                                discord.Embed.from_dict(i)\n                                for i in message_data[\"embeds\"]\n                            ],\n                            view=yesNoValue,\n                        )\n                        await yesNoValue.wait()\n                        if yesNoValue.value:\n                            break\n                        elif not yesNoValue.value:\n                            constant_msg_data = message_data\n                elif item == \"send_message\":  # Add to Database\n                    # Get Channel(s) to Send Message To\n                    await message.edit(\n                        content=f\"{pendingEmoji} **{ctx.author.name},** please select the channel(s) you wish to send a message to upon a user receiving a **{infraction_type_name}**.\",\n                        view=(view := ChannelSelect(ctx.author.id, limit=5)),\n                    )\n                    await view.wait()\n\n                    # Get Custom Message\n                    view = MessageCustomisation(\n                        ctx.author.id, persist=True, external=True\n                    )\n                    await message.edit(content=None, view=view)\n                    await view.wait()\n                elif item == \"send_escalation\":  # Add to Database\n                    await message.edit(\n                        content=f\"{pendingEmoji} **{ctx.author.name},** please select the channel you wish to send an escalation request to upon a user recieving a **{infraction_type_name}**.\",\n                        view=(view := ChannelSelect(ctx.author.id, limit=1)),\n                    )\n                    await view.wait()\n                    # print(view.value)\n                    await message.edit(\n                        content=f\"{pendingEmoji} **{ctx.author.name},** should the member responsible for issuing the infraction that triggers an escalation request also have the authority to approve the escalation request? **{infraction_type_name}**.\",\n                        view=(view := YesNoMenu(ctx.author.id)),\n                    )\n                    # print(view.value)\n            else:\n                await message.edit(\n                    content=f\"{successEmoji} **{infraction_type_name}** has been successfully submitted!\",\n                    view=None,\n                    embed=None,\n                )\n\n        else:\n            guild_settings[\"staff_conduct\"] = None\n            await self.bot.settings.update_by_id(guild_settings)\n            await ctx.reply(\n                f\"{successEmoji} **{ctx.author.name},** I deleted your Staff Conduct configuration.\"\n            )\n\n\nasync def setup(bot):\n    await bot.add_cog(StaffConduct(bot))\n"}
{"type": "source_file", "path": "datamodels/LinkStrings.py", "content": "from discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass LinkStrings(Document):\r\n    pass\r\n"}
{"type": "source_file", "path": "cogs/GameLogging.py", "content": "import datetime\r\n\r\nimport discord\r\nimport pytz\r\nfrom bson import ObjectId\r\nfrom discord import app_commands\r\nfrom discord.ext import commands\r\n\r\nfrom erm import is_staff, admin_predicate, management_predicate, staff_predicate\r\nfrom menus import CustomModalView, UserSelect\r\nfrom utils.constants import BLANK_COLOR, GREEN_COLOR\r\nfrom utils.timestamp import td_format\r\nfrom utils.utils import invis_embed, require_settings, time_converter\r\n\r\n\r\nclass GameLogging(commands.Cog):\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n\r\n    def check_missing(self, settings, section):\r\n        if not settings:\r\n            return False\r\n\r\n        if not settings.get(\"game_logging\"):\r\n            return False\r\n\r\n        if not settings.get(\"game_logging\").get(section):\r\n            return False\r\n\r\n        if not settings.get(\"game_logging\").get(section).get(\"enabled\"):\r\n            return False\r\n        if not settings.get(\"game_logging\").get(section).get(\"channel\"):\r\n            return False\r\n\r\n        return True\r\n\r\n    @commands.guild_only()\r\n    @commands.hybrid_group(\r\n        name=\"staff\",\r\n        description=\"Request more staff to be in-game!\",\r\n        extras={\"category\": \"Game Logging\"},\r\n    )\r\n    async def staff(self, ctx: commands.Context):\r\n        pass\r\n\r\n    @staff.command(\r\n        name=\"request\",\r\n        description=\"Send a Staff Request to get more staff in-game!\",\r\n        extras={\"category\": \"Game Logging\"},\r\n    )\r\n    @app_commands.describe(reason=\"Reason for your Staff Request!\")\r\n    @require_settings()\r\n    async def staff_request(self, ctx: commands.Context, *, reason: str):\r\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\r\n        game_logging = settings.get(\"game_logging\", {})\r\n        if game_logging == {}:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Configured\",\r\n                    description=\"Game Logging is not configured within this server.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        staff_requests = game_logging.get(\"staff_requests\", {})\r\n        if staff_requests == {}:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Configured\",\r\n                    description=\"Staff Requests is not configured within this server.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n        enabled = staff_requests.get(\"enabled\", False)\r\n        if not enabled:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Enabled\",\r\n                    description=\"Staff Requests are not enabled within this server.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        permission_level = staff_requests.get(\"permission_level\", 4)\r\n        has_permission = True\r\n        if permission_level == 3:\r\n            if not await admin_predicate(ctx):\r\n                has_permission = False\r\n            else:\r\n                has_permission = True\r\n        if permission_level == 2:\r\n            if not await management_predicate(ctx):\r\n                has_permission = False\r\n            else:\r\n                has_permission = True\r\n        if permission_level == 1:\r\n            if not await staff_predicate(ctx):\r\n                has_permission = False\r\n            else:\r\n                has_permission = True\r\n        if not has_permission:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Permitted\",\r\n                    description=f\"You are missing the **{ {1: 'Staff', 2: 'Management', 3: 'Admin'}.get(permission_level) }** permission to make a Staff Request.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        last_submitted_staff_request = [\r\n            i\r\n            async for i in self.bot.staff_requests.db.find(\r\n                {\"user_id\": ctx.author.id, \"guild_id\": ctx.guild.id}\r\n            )\r\n            .sort({\"_id\": -1})\r\n            .limit(1)\r\n        ]\r\n        if len(last_submitted_staff_request) != 0:\r\n            last_submitted_staff_request = last_submitted_staff_request[0]\r\n            document_id: ObjectId = last_submitted_staff_request[\"_id\"]\r\n            timestamp = document_id.generation_time.timestamp()\r\n            if (\r\n                timestamp + staff_requests.get(\"cooldown\", 0)\r\n                > datetime.datetime.now(tz=pytz.UTC).timestamp()\r\n            ):\r\n                return await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Cooldown\",\r\n                        description=\"You are on cooldown from making Staff Requests.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n        staff_clocked_in = await self.bot.shift_management.shifts.db.count_documents(\r\n            {\"EndEpoch\": 0, \"Guild\": ctx.guild.id}\r\n        )\r\n        if (\r\n            staff_requests.get(\"min_staff\") is not None\r\n            and staff_requests.get(\"min_staff\") > 0\r\n        ):\r\n            if staff_clocked_in <= staff_requests.get(\"min_staff\", 0):\r\n                return await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Minimum Staff\",\r\n                        description=f\"**{staff_requests.get('min_staff')}** members of staff are required to be in-game for a Staff Request!\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n        if (\r\n            staff_requests.get(\"max_staff\") is not None\r\n            and staff_requests.get(\"max_staff\") > 0\r\n        ):\r\n            if staff_clocked_in > staff_requests.get(\"max_staff\", 0):\r\n                return await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Maximum Staff\",\r\n                        description=\"There are more than the maximum number of staff online for a Staff Request!\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n        document = {\r\n            \"user_id\": ctx.author.id,\r\n            \"guild_id\": ctx.guild.id,\r\n            \"username\": ctx.author.name,\r\n            \"avatar\": ctx.author.display_avatar.url.split(\"/\")[-1].split(\".\")[0],\r\n            \"reason\": reason,\r\n            \"active\": True,\r\n            \"created_at\": datetime.datetime.now(tz=pytz.UTC),\r\n            \"acked\": [],\r\n        }\r\n        result = await self.bot.staff_requests.db.insert_one(document)\r\n        o_id = result.inserted_id\r\n        self.bot.dispatch(\"staff_request_send\", o_id)\r\n        await ctx.send(\r\n            embed=discord.Embed(\r\n                title=f\"{self.bot.emoji_controller.get_emoji('success')} Sent Staff Request\",\r\n                description=\"Your Staff Request has been sent successfully.\",\r\n                color=GREEN_COLOR,\r\n            )\r\n        )\r\n\r\n    @commands.guild_only()\r\n    @commands.hybrid_group(\r\n        name=\"game\",\r\n        description=\"Manage your game with logging such as messages, and events\",\r\n        extras={\"category\": \"Game Logging\"},\r\n    )\r\n    async def game(self, ctx):\r\n        pass\r\n\r\n    @commands.guild_only()\r\n    @game.command(\r\n        name=\"message\",\r\n        description=\"Log all announcements and messages in your game\",\r\n        extras={\"category\": \"Game Logging\"},\r\n    )\r\n    @app_commands.describe(announcement=\"The game message you are going to log.\")\r\n    @is_staff()\r\n    @require_settings()\r\n    async def game_message(self, ctx: commands.Context, *, announcement: str):\r\n        bot = self.bot\r\n        configItem = await bot.settings.find_by_id(ctx.guild.id)\r\n\r\n        check_settings = self.check_missing(configItem, \"message\")\r\n        if check_settings is False:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Configured\",\r\n                    description=\"Game Announcement Logging is not configured.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        channel = ctx.guild.get_channel(\r\n            configItem[\"game_logging\"][\"message\"][\"channel\"]\r\n        )\r\n        if not channel:\r\n            return await ctx.reply(\r\n                embed=discord.Embed(\r\n                    title=\"Invalid Channel\",\r\n                    description=\"The Game Announcement logging channel is invalid.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        embed = discord.Embed(\r\n            title=\"Message Logged\",\r\n            color=BLANK_COLOR,\r\n        )\r\n\r\n        embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n\r\n        embed.add_field(\r\n            name=\"Announcement Information\",\r\n            value=(\r\n                f\"> **Staff:** {ctx.author.mention}\\n\"\r\n                f\"> **Announcement:** {announcement}\\n\"\r\n                f\"> **At:** <t:{int(datetime.datetime.now(tz=pytz.UTC).timestamp())}>\"\r\n            ),\r\n            inline=False,\r\n        )\r\n        if channel is None:\r\n            return\r\n        await channel.send(embed=embed)\r\n        await ctx.send(\r\n            embed=discord.Embed(\r\n                title=f\"{self.bot.emoji_controller.get_emoji('success')} Logged Announcement\",\r\n                description=\"Your Game Announcement has been successfully logged!\",\r\n                color=GREEN_COLOR,\r\n            )\r\n        )\r\n\r\n    @commands.guild_only()\r\n    @game.command(\r\n        name=\"sts\",\r\n        description=\"Log a Shoulder-to-Shoulder in your game\",\r\n        extras={\"category\": \"Game Logging\"},\r\n    )\r\n    async def game_sts(self, ctx: commands.Context, duration: str, *, reason: str):\r\n        bot = self.bot\r\n        configItem = await bot.settings.find_by_id(ctx.guild.id)\r\n\r\n        settings_value = self.check_missing(configItem, \"sts\")\r\n        if not settings_value:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Configured\",\r\n                    description=\"Game STS Logging is not configured.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        channel = ctx.guild.get_channel(configItem[\"game_logging\"][\"sts\"][\"channel\"])\r\n        if not channel:\r\n            return await ctx.reply(\r\n                embed=discord.Embed(\r\n                    title=\"Invalid Channel\",\r\n                    description=\"The Game STS logging channel is invalid.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n        view = UserSelect(ctx.author.id)\r\n\r\n        sts_msg = await ctx.reply(\r\n            embed=discord.Embed(\r\n                title=\"Participants\",\r\n                description=\"What staff members took part in this STS?\",\r\n                color=BLANK_COLOR,\r\n            ),\r\n            view=view,\r\n        )\r\n        timeout = await view.wait()\r\n        if timeout:\r\n            return\r\n\r\n        if view.value:\r\n            members = view.value\r\n        else:\r\n            return\r\n\r\n        embed = discord.Embed(\r\n            title=\"STS Logged\",\r\n            color=BLANK_COLOR,\r\n        )\r\n\r\n        embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n\r\n        embed.add_field(\r\n            name=\"Staff Members\",\r\n            value=\"\\n\".join(\r\n                [\r\n                    (f\"**{index+1}.** \" + member.mention)\r\n                    for index, member in enumerate(members)\r\n                ]\r\n            ),\r\n            inline=False,\r\n        )\r\n\r\n        try:\r\n            duration = time_converter(duration)\r\n        except ValueError:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Invalid Time\",\r\n                    description=\"This is an invalid duration format.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        embed.add_field(\r\n            name=\"STS Information\",\r\n            value=(\r\n                f\"> **Host:** {ctx.author.mention}\\n\"\r\n                f\"> **Duration:** {td_format(datetime.timedelta(seconds=duration))}\\n\"\r\n                f\"> **Hosted At:** <t:{int(ctx.message.created_at.timestamp())}>\\n\"\r\n                f\"> **Reason:** {reason}\"\r\n            ),\r\n            inline=False,\r\n        )\r\n\r\n        if channel is None:\r\n            return\r\n        await channel.send(embed=embed)\r\n\r\n        await sts_msg.edit(\r\n            embed=discord.Embed(\r\n                title=f\"{self.bot.emoji_controller.get_emoji('success')} Logged STS\",\r\n                description=\"I have successfully logged your STS!\",\r\n                color=GREEN_COLOR,\r\n            ),\r\n            view=None,\r\n        )\r\n\r\n    @commands.guild_only()\r\n    @game.command(\r\n        name=\"priority\",\r\n        description=\"Log Roleplay Permissions and Priorities in your game\",\r\n        extras={\"category\": \"Game Logging\"},\r\n    )\r\n    @is_staff()\r\n    async def game_priority(self, ctx: commands.Context, duration: str, *, reason):\r\n        bot = self.bot\r\n        configItem = await bot.settings.find_by_id(ctx.guild.id)\r\n\r\n        check_settings = self.check_missing(configItem, \"priority\")\r\n        if not check_settings:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Configured\",\r\n                    description=\"Game Priority Logging is not configured.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        channel = ctx.guild.get_channel(\r\n            configItem[\"game_logging\"][\"priority\"][\"channel\"]\r\n        )\r\n        if not channel:\r\n            return await ctx.reply(\r\n                embed=discord.Embed(\r\n                    title=\"Invalid Channel\",\r\n                    description=\"The Game Priority logging channel is invalid.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        view = CustomModalView(\r\n            ctx.author.id,\r\n            \"User List\",\r\n            \"User List\",\r\n            [\r\n                (\r\n                    \"users\",\r\n                    discord.ui.TextInput(\r\n                        placeholder=\"The users involved in the Priority. Separate by lines.\\n\\nExample:\\nRoyalCrests\\ni_iMikey\\nmbrinkley\",\r\n                        label=\"Players\",\r\n                        style=discord.TextStyle.long,\r\n                        min_length=1,\r\n                        max_length=600,\r\n                    ),\r\n                ),\r\n            ],\r\n        )\r\n\r\n        prio_msg = await ctx.reply(\r\n            embed=discord.Embed(\r\n                title=\"Users Involved\",\r\n                description=\"What users are going to be involved with this priority?\",\r\n                color=BLANK_COLOR,\r\n            ),\r\n            view=view,\r\n        )\r\n        timeout = await view.wait()\r\n        if timeout:\r\n            return\r\n\r\n        if view.modal.users:\r\n            users = view.modal.users.value\r\n        else:\r\n            return\r\n\r\n        users = users.split(\"\\n\")\r\n\r\n        embed = discord.Embed(\r\n            title=\"Priority Logged\",\r\n            color=BLANK_COLOR,\r\n        )\r\n\r\n        embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n\r\n        embed.add_field(\r\n            name=\"Players\",\r\n            value=\"\\n\".join(\r\n                [(f\"**{index+1}.** \" + player) for index, player in enumerate(users)]\r\n            ),\r\n            inline=False,\r\n        )\r\n\r\n        try:\r\n            duration = time_converter(duration)\r\n        except ValueError:\r\n            return await prio_msg.edit(\r\n                embed=discord.Embed(\r\n                    title=\"Invalid Time\",\r\n                    description=\"This time is not a valid duration.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        embed.add_field(\r\n            name=\"Priority Information\",\r\n            value=(\r\n                f\"> **Staff:** {ctx.author.mention}\\n\"\r\n                f\"> **Duration:** {td_format(datetime.timedelta(seconds=duration))}\\n\"\r\n                f\"> **Reason:** {reason}\\n\"\r\n                f\"> **At:** <t:{int(ctx.message.created_at.timestamp())}>\"\r\n            ),\r\n            inline=False,\r\n        )\r\n\r\n        if channel is None:\r\n            return\r\n\r\n        await channel.send(embed=embed)\r\n\r\n        await prio_msg.edit(\r\n            view=None,\r\n            embed=discord.Embed(\r\n                title=f\"{self.bot.emoji_controller.get_emoji('success')} Logged Priority\",\r\n                description=\"I have successfully logged the priority request.\",\r\n                color=GREEN_COLOR,\r\n            ),\r\n        )\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(GameLogging(bot))\r\n"}
{"type": "source_file", "path": "cogs/Jishaku.py", "content": "import discord\r\nimport jishaku\r\nfrom discord.ext import commands\r\nfrom jishaku.codeblocks import codeblock_converter, Codeblock\r\nfrom jishaku.cog import STANDARD_FEATURES, OPTIONAL_FEATURES\r\nfrom jishaku.features.baseclass import Feature\r\n\r\nOWNER = 1165311055728226444\r\nLOGGING_CHANNEL = 1084950208842039326\r\n\r\n\r\nclass CustomDebugCog(*OPTIONAL_FEATURES, *STANDARD_FEATURES):\r\n    \"\"\"\r\n    Custom Jishaku Cog for command logging\r\n    \"\"\"\r\n\r\n    @Feature.Command(parent=\"jsk\", name=\"creator\")\r\n    async def jsk_creator(self, ctx: commands.Context):\r\n        try:\r\n            owner = await ctx.guild.fetch_member(OWNER)\r\n        except discord.NotFound:\r\n            owner = None\r\n\r\n        if owner is None:\r\n            return await ctx.send(\r\n                f\"The creator of {self.bot.user.mention} is <@{OWNER}>\"\r\n            )\r\n\r\n        embed = discord.Embed(\r\n            title=f\"{owner.name}#{owner.discriminator}\", color=0x2A2D31\r\n        )\r\n        embed.add_field(\r\n            name=f\"Owner of {self.bot.user.name}\",\r\n            value=f\"{owner.mention}\",\r\n            inline=False,\r\n        )\r\n        embed.add_field(name=\"ID\", value=f\"{owner.id}\", inline=False)\r\n        embed.set_footer(\r\n            text=f\"{owner.name}#{owner.discriminator} is the owner of {self.bot.user.name}\",\r\n            icon_url=ctx.guild.icon,\r\n        )\r\n        embed.set_thumbnail(url=owner.display_avatar.url)\r\n        await ctx.send(embed=embed)\r\n\r\n    # async def cog_before_invoke(self, ctx: commands.Context):\r\n    #     try:\r\n    #         channel: discord.TextChannel = await self.bot.fetch_channel(LOGGING_CHANNEL)\r\n    #     except (discord.NotFound, discord.Forbidden):\r\n    #         pass\r\n    #     else:\r\n    #         selected_webhook = None\r\n    #         try:\r\n    #             for webhook in await channel.webhooks():\r\n    #                 if webhook.name == f\"{ctx.author.name}#{ctx.author.discriminator}\":\r\n    #                     selected_webhook = webhook\r\n    #         except discord.Forbidden:\r\n    #             return\r\n    #\r\n    #         if not selected_webhook:\r\n    #             selected_webhook = await channel.create_webhook(\r\n    #                 name=f\"{ctx.author.name}#{ctx.author.discriminator}\",\r\n    #                 avatar=(await ctx.author.display_avatar.read()),\r\n    #                 reason=\"Logs\",\r\n    #             )\r\n    #\r\n    #         embed = discord.Embed()\r\n    #         if \"`\" in ctx.message.content:\r\n    #             codeblock = codeblock_converter(\r\n    #                 ctx.message.content[ctx.message.content.index(\"`\") - 1 :]\r\n    #             )\r\n    #         else:\r\n    #             codeblock = None\r\n    #         if codeblock is not None:\r\n    #             if ctx.guild:\r\n    #                 embed.description = f\"```\\n{ctx.message.content[:ctx.message.content.index('`')-1]}```\\n{codeblock.content}\\n\\n```\\nServer Name: {ctx.guild.name}\\nChannel Name: {ctx.channel.name}\\nMember Count: {ctx.guild.member_count}\\nOwner: {f'{ctx.guild.owner.name}#{ctx.guild.owner.discriminator}'}```\"\r\n    #             else:\r\n    #                 embed.description = f\"```\\n{ctx.message.content[:ctx.message.content.index('`') - 1]}```\\n{codeblock.content}\"\r\n    #         else:\r\n    #             if ctx.guild:\r\n    #                 embed.description = f\"```\\n{ctx.message.content}```\\n\\n```\\nServer Name: {ctx.guild.name}\\nChannel Name: {ctx.channel.name}\\nMember Count: {ctx.guild.member_count}\\nOwner: {f'{ctx.guild.owner.name}#{ctx.guild.owner.discriminator}'}```\"\r\n    #             else:\r\n    #                 embed.description = f\"```\\n{ctx.message.content}```\"\r\n    #         embed.title = \"Jishaku Logging\"\r\n    #         embed.set_author(\r\n    #             name=f\"{ctx.author.name}#{ctx.author.discriminator}\",\r\n    #             icon_url=ctx.author.display_avatar.url,\r\n    #         )\r\n    #         embed.set_footer(text=\"️️©️ ERM Systems - Jishaku Logging Systems\")\r\n    #         try:\r\n    #             await selected_webhook.send(embed=embed)\r\n    #         except ValueError:\r\n    #             await selected_webhook.delete()\r\n    #             selected_webhook = await channel.create_webhook(\r\n    #                 name=f\"{ctx.author.name}#{ctx.author.discriminator}\",\r\n    #                 avatar=(await ctx.author.display_avatar.read()),\r\n    #                 reason=\"Logs\",\r\n    #             )\r\n    #             await selected_webhook.send(embed=embed)\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(CustomDebugCog(bot=bot))\r\n"}
{"type": "source_file", "path": "datamodels/ActivityNotice.py", "content": "from discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass ActivityNotices(Document):\r\n    pass\r\n"}
{"type": "source_file", "path": "cogs/Privacy.py", "content": "import datetime\r\nimport discord\r\nfrom discord.ext import commands\r\nfrom menus import CustomExecutionButton, CustomSelectMenu\r\nfrom utils.constants import BLANK_COLOR\r\n\r\n\r\nclass Privacy(commands.Cog):\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n\r\n    @commands.guild_only()\r\n    @commands.hybrid_command(\r\n        name=\"consent\",\r\n        description=\"Change your privacy settings.\",\r\n        extras={\"category\": \"Privacy\"},\r\n    )\r\n    async def consent(self, ctx: commands.Context):\r\n        bot = self.bot\r\n        punishments_enabled = True\r\n        ai_enabled = True\r\n        selected = None\r\n        shift_reports_enabled = True\r\n        automatic_shifts_enabled = True\r\n\r\n        async for document in bot.consent.db.find({\"_id\": ctx.author.id}):\r\n            punishments_enabled = (\r\n                document.get(\"punishments\")\r\n                if document.get(\"punishments\") is not None\r\n                else True\r\n            )\r\n            shift_reports_enabled = (\r\n                document.get(\"shift_reports\")\r\n                if document.get(\"shift_reports\") is not None\r\n                else True\r\n            )\r\n            automatic_shifts_enabled = (\r\n                document.get(\"automatic_shifts\")\r\n                if document.get(\"automatic_shifts\") is not None\r\n                else True\r\n            )\r\n            selected = document\r\n        embed = discord.Embed(title=\"User Settings\", color=BLANK_COLOR)\r\n        embed.add_field(\r\n            name=\"Configurations\",\r\n            value=(\r\n                f\"> **Punishment Alerts:** {bot.emoji_controller.get_emoji('check') if punishments_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                f\"> **Shift Reports:** {bot.emoji_controller.get_emoji('check') if shift_reports_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                f\"> **Automatic Shifts:** {bot.emoji_controller.get_emoji('check') if automatic_shifts_enabled is True else bot.emoji_controller.get_emoji('xmark')}\"\r\n            ),\r\n            inline=False,\r\n        )\r\n        embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n        embed.set_thumbnail(url=ctx.author.display_avatar.url)\r\n        embed.set_footer(text=\"User Settings\")\r\n        embed.timestamp = datetime.datetime.now()\r\n\r\n        custom_view = discord.ui.View()\r\n\r\n        async def punishment_alerts(\r\n            interaction: discord.Interaction, button: discord.ui.Button\r\n        ):\r\n            nonlocal selected\r\n            nonlocal punishments_enabled\r\n            if interaction.user.id == ctx.author.id:\r\n                await interaction.response.defer()\r\n                view = CustomSelectMenu(\r\n                    ctx.author.id,\r\n                    [\r\n                        discord.SelectOption(\r\n                            label=\"Enable\",\r\n                            value=\"enable\",\r\n                            description=\"Enable punishment alerts.\",\r\n                        ),\r\n                        discord.SelectOption(\r\n                            label=\"Disable\",\r\n                            value=\"disable\",\r\n                            description=\"Disable punishment alerts.\",\r\n                        ),\r\n                    ],\r\n                )\r\n\r\n                await interaction.message.edit(view=view)\r\n                await view.wait()\r\n                if view.value == \"enable\":\r\n                    if selected is None:\r\n                        await bot.consent.insert(\r\n                            {\"_id\": ctx.author.id, \"punishments\": True}\r\n                        )\r\n                    else:\r\n                        selected[\"punishments\"] = True\r\n                        if not selected.get(\"_id\"):\r\n                            selected[\"_id\"] = ctx.author.id\r\n                        await bot.consent.update_by_id(selected)\r\n                    punishments_enabled = True\r\n                    embed = discord.Embed(title=\"User Settings\", color=BLANK_COLOR)\r\n                    embed.add_field(\r\n                        name=\"Configurations\",\r\n                        value=(\r\n                            f\"> **Punishment Alerts:** {bot.emoji_controller.get_emoji('check') if punishments_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                            f\"> **Shift Reports:** {bot.emoji_controller.get_emoji('check') if shift_reports_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                            f\"> **Automatic Shifts:** {bot.emoji_controller.get_emoji('check') if automatic_shifts_enabled is True else bot.emoji_controller.get_emoji('xmark')}\"\r\n                        ),\r\n                        inline=False,\r\n                    )\r\n                    embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n                    embed.set_thumbnail(url=ctx.author.display_avatar.url)\r\n                    embed.set_footer(text=\"User Settings\")\r\n                    embed.timestamp = datetime.datetime.now()\r\n                    button.style = discord.ButtonStyle.success\r\n                    await interaction.message.edit(\r\n                        content=\"\",\r\n                        embed=embed,\r\n                        view=button.view,\r\n                    )\r\n                elif view.value == \"disable\":\r\n                    if selected is None:\r\n                        selected = {\"_id\": ctx.author.id, \"punishments\": False}\r\n                        await bot.consent.insert(\r\n                            {\"_id\": ctx.author.id, \"punishments\": False}\r\n                        )\r\n                    else:\r\n                        selected[\"punishments\"] = False\r\n                        if not selected.get(\"_id\"):\r\n                            selected[\"_id\"] = ctx.author.id\r\n                        await bot.consent.update_by_id(selected)\r\n                    punishments_enabled = False\r\n                    embed = discord.Embed(title=\"User Settings\", color=BLANK_COLOR)\r\n                    embed.add_field(\r\n                        name=\"Configurations\",\r\n                        value=(\r\n                            f\"> **Punishment Alerts:** {bot.emoji_controller.get_emoji('check') if punishments_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                            f\"> **Shift Reports:** {bot.emoji_controller.get_emoji('check') if shift_reports_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                            f\"> **Automatic Shifts:** {bot.emoji_controller.get_emoji('check') if automatic_shifts_enabled is True else bot.emoji_controller.get_emoji('xmark')}\"\r\n                        ),\r\n                        inline=False,\r\n                    )\r\n                    embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n                    embed.set_thumbnail(url=ctx.author.display_avatar.url)\r\n                    embed.set_footer(text=\"User Settings\")\r\n                    embed.timestamp = datetime.datetime.now()\r\n                    button.style = discord.ButtonStyle.danger\r\n\r\n                    await interaction.message.edit(\r\n                        content=\"\",\r\n                        embed=embed,\r\n                        view=button.view,\r\n                    )\r\n            else:\r\n                await interaction.response.send_message(\r\n                    embed=discord.Embed(\r\n                        title=\"Not Permitted\",\r\n                        description=\"You are not permitted to interact with these buttons.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    ephemeral=True,\r\n                )\r\n\r\n        async def shift_reports(\r\n            interaction: discord.Interaction, button: discord.ui.Button\r\n        ):\r\n            if interaction.user.id == ctx.author.id:\r\n                nonlocal selected\r\n                nonlocal shift_reports_enabled\r\n                await interaction.response.defer()\r\n                view = CustomSelectMenu(\r\n                    ctx.author.id,\r\n                    [\r\n                        discord.SelectOption(\r\n                            label=\"Enable\",\r\n                            value=\"enable\",\r\n                            description=\"Enable shift reports.\",\r\n                        ),\r\n                        discord.SelectOption(\r\n                            label=\"Disable\",\r\n                            value=\"disable\",\r\n                            description=\"Disable shift reports.\",\r\n                        ),\r\n                    ],\r\n                )\r\n\r\n                await interaction.message.edit(view=view)\r\n                await view.wait()\r\n                if view.value == \"enable\":\r\n                    if selected is None:\r\n                        selected = {\"_id\": ctx.author.id, \"shift_reports\": True}\r\n                        await bot.consent.insert(selected)\r\n                    else:\r\n                        selected[\"shift_reports\"] = True\r\n                        if not selected.get(\"_id\"):\r\n                            selected[\"_id\"] = ctx.author.id\r\n                        await bot.consent.update_by_id(selected)\r\n                    shift_reports_enabled = True\r\n                    embed = discord.Embed(title=\"User Settings\", color=BLANK_COLOR)\r\n                    embed.add_field(\r\n                        name=\"Configurations\",\r\n                        value=(\r\n                            f\"> **Punishment Alerts:** {bot.emoji_controller.get_emoji('check') if punishments_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                            f\"> **Shift Reports:** {bot.emoji_controller.get_emoji('check') if shift_reports_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                            f\"> **Automatic Shifts:** {bot.emoji_controller.get_emoji('check') if automatic_shifts_enabled is True else bot.emoji_controller.get_emoji('xmark')}\"\r\n                        ),\r\n                        inline=False,\r\n                    )\r\n                    embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n                    embed.set_thumbnail(url=ctx.author.display_avatar.url)\r\n                    embed.set_footer(text=\"User Settings\")\r\n                    embed.timestamp = datetime.datetime.now()\r\n                    button.style = discord.ButtonStyle.success\r\n\r\n                    await interaction.edit_original_response(\r\n                        content=\"\",\r\n                        embed=embed,\r\n                        view=button.view,\r\n                    )\r\n\r\n                elif view.value == \"disable\":\r\n                    if selected is None:\r\n                        selected = {\"_id\": ctx.author.id, \"shift_reports\": False}\r\n                        await bot.consent.insert(selected)\r\n                    else:\r\n                        selected[\"shift_reports\"] = False\r\n                        if not selected.get(\"_id\"):\r\n                            selected[\"_id\"] = ctx.author.id\r\n\r\n                        await bot.consent.update_by_id(selected)\r\n                    shift_reports_enabled = False\r\n                    embed = discord.Embed(title=\"User Settings\", color=BLANK_COLOR)\r\n                    embed.add_field(\r\n                        name=\"Configurations\",\r\n                        value=(\r\n                            f\"> **Punishment Alerts:** {bot.emoji_controller.get_emoji('check') if punishments_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                            f\"> **Shift Reports:** {bot.emoji_controller.get_emoji('check') if shift_reports_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                            f\"> **Automatic Shifts:** {bot.emoji_controller.get_emoji('check') if automatic_shifts_enabled is True else bot.emoji_controller.get_emoji('xmark')}\"\r\n                        ),\r\n                        inline=False,\r\n                    )\r\n                    embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n                    embed.set_thumbnail(url=ctx.author.display_avatar.url)\r\n                    embed.set_footer(text=\"User Settings\")\r\n                    embed.timestamp = datetime.datetime.now()\r\n                    button.style = discord.ButtonStyle.danger\r\n                    await interaction.message.edit(\r\n                        content=\"\",\r\n                        embed=embed,\r\n                        view=button.view,\r\n                    )\r\n            else:\r\n                await interaction.response.send_message(\r\n                    embed=discord.Embed(\r\n                        title=\"Not Permitted\",\r\n                        description=\"You are not permitted to interact with these buttons.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    ephemeral=True,\r\n                )\r\n\r\n        async def automatic_shifts(\r\n            interaction: discord.Interaction, button: discord.ui.Button\r\n        ):\r\n            if interaction.user.id == ctx.author.id:\r\n                nonlocal selected\r\n                nonlocal automatic_shifts_enabled\r\n                await interaction.response.defer()\r\n                view = CustomSelectMenu(\r\n                    ctx.author.id,\r\n                    [\r\n                        discord.SelectOption(\r\n                            label=\"Enable\",\r\n                            value=\"enable\",\r\n                            description=\"Enable Automatic Shifts.\",\r\n                        ),\r\n                        discord.SelectOption(\r\n                            label=\"Disable\",\r\n                            value=\"disable\",\r\n                            description=\"Disable Automatic Shifts.\",\r\n                        ),\r\n                    ],\r\n                )\r\n\r\n                await interaction.message.edit(view=view)\r\n                await view.wait()\r\n                if view.value == \"enable\":\r\n                    if selected is None:\r\n                        selected = {\"_id\": ctx.author.id, \"automatic_shifts\": True}\r\n                        await bot.consent.insert(selected)\r\n                    else:\r\n                        selected[\"automatic_shifts\"] = True\r\n                        if not selected.get(\"_id\"):\r\n                            selected[\"_id\"] = ctx.author.id\r\n                        await bot.consent.update_by_id(selected)\r\n                    automatic_shifts_enabled = True\r\n                    embed = discord.Embed(title=\"User Settings\", color=BLANK_COLOR)\r\n                    embed.add_field(\r\n                        name=\"Configurations\",\r\n                        value=(\r\n                            f\"> **Punishment Alerts:** {bot.emoji_controller.get_emoji('check') if punishments_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                            f\"> **Shift Reports:** {bot.emoji_controller.get_emoji('check') if shift_reports_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                            f\"> **Automatic Shifts:** {bot.emoji_controller.get_emoji('check') if automatic_shifts_enabled is True else bot.emoji_controller.get_emoji('xmark')}\"\r\n                        ),\r\n                        inline=False,\r\n                    )\r\n                    embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n                    embed.set_thumbnail(url=ctx.author.display_avatar.url)\r\n                    embed.set_footer(text=\"User Settings\")\r\n                    embed.timestamp = datetime.datetime.now()\r\n                    button.style = discord.ButtonStyle.success\r\n\r\n                    await interaction.edit_original_response(\r\n                        content=\"\",\r\n                        embed=embed,\r\n                        view=button.view,\r\n                    )\r\n\r\n                elif view.value == \"disable\":\r\n                    if selected is None:\r\n                        selected = {\"_id\": ctx.author.id, \"automatic_shifts\": False}\r\n                        await bot.consent.insert(selected)\r\n                    else:\r\n                        selected[\"automatic_shifts\"] = False\r\n                        if not selected.get(\"_id\"):\r\n                            selected[\"_id\"] = ctx.author.id\r\n\r\n                        await bot.consent.update_by_id(selected)\r\n                    automatic_shifts_enabled = False\r\n                    embed = discord.Embed(title=\"User Settings\", color=BLANK_COLOR)\r\n                    embed.add_field(\r\n                        name=\"Configurations\",\r\n                        value=(\r\n                            f\"> **Punishment Alerts:** {bot.emoji_controller.get_emoji('check') if punishments_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                            f\"> **Shift Reports:** {bot.emoji_controller.get_emoji('check') if shift_reports_enabled is True else bot.emoji_controller.get_emoji('xmark')}\\n\"\r\n                            f\"> **Automatic Shifts:** {bot.emoji_controller.get_emoji('check') if automatic_shifts_enabled is True else bot.emoji_controller.get_emoji('xmark')}\"\r\n                        ),\r\n                        inline=False,\r\n                    )\r\n                    embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n                    embed.set_thumbnail(url=ctx.author.display_avatar.url)\r\n                    embed.set_footer(text=\"User Settings\")\r\n                    embed.timestamp = datetime.datetime.now()\r\n                    button.style = discord.ButtonStyle.danger\r\n                    await interaction.message.edit(\r\n                        content=\"\",\r\n                        embed=embed,\r\n                        view=button.view,\r\n                    )\r\n            else:\r\n                await interaction.response.send_message(\r\n                    embed=discord.Embed(\r\n                        title=\"Not Permitted\",\r\n                        description=\"You are not permitted to interact with these buttons.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    ephemeral=True,\r\n                )\r\n\r\n        buttons = [\r\n            CustomExecutionButton(\r\n                ctx.author.id,\r\n                label=\"Punishment Alerts\",\r\n                style=(\r\n                    discord.ButtonStyle.danger\r\n                    if not punishments_enabled\r\n                    else discord.ButtonStyle.success\r\n                ),\r\n                func=punishment_alerts,\r\n            ),\r\n            CustomExecutionButton(\r\n                ctx.author.id,\r\n                label=\"Shift Reports\",\r\n                style=(\r\n                    discord.ButtonStyle.danger\r\n                    if not shift_reports_enabled\r\n                    else discord.ButtonStyle.success\r\n                ),\r\n                func=shift_reports,\r\n            ),\r\n            CustomExecutionButton(\r\n                ctx.author.id,\r\n                label=\"Automatic Shifts\",\r\n                style=(\r\n                    discord.ButtonStyle.danger\r\n                    if not automatic_shifts_enabled\r\n                    else discord.ButtonStyle.success\r\n                ),\r\n                func=automatic_shifts,\r\n            ),\r\n        ]\r\n\r\n        for child in buttons:\r\n            custom_view.add_item(child)\r\n\r\n        await ctx.reply(embed=embed, view=custom_view)\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(Privacy(bot))\r\n"}
{"type": "source_file", "path": "datamodels/CustomCommands.py", "content": "from discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass CustomCommands(Document):\r\n    pass\r\n"}
{"type": "source_file", "path": "cogs/ActivityNotices.py", "content": "import datetime\r\n\r\nimport discord\r\nimport pytz\r\nfrom dateutil import parser\r\nfrom discord import app_commands\r\nfrom discord.ext import commands\r\nfrom reactionmenu import ViewButton, ViewMenu\r\n\r\nfrom erm import is_management, is_admin, system_code_gen, is_staff\r\nfrom menus import (\r\n    ActivityNoticeModification,\r\n    CustomModalView,\r\n    CustomSelectMenu,\r\n    LOAMenu,\r\n    YesNoColourMenu,\r\n    ActivityNoticeAdministration,\r\n)\r\nfrom utils.constants import BLANK_COLOR, GREEN_COLOR\r\nfrom utils.paginators import CustomPage, SelectPagination\r\nfrom utils.timestamp import td_format\r\nfrom utils.utils import (\r\n    invis_embed,\r\n    removesuffix,\r\n    require_settings,\r\n    time_converter,\r\n    get_elapsed_time,\r\n    log_command_usage,\r\n)\r\n\r\n\r\nclass ActivityCoreCommands:\r\n    \"\"\"\r\n    Basic class for core commands of the Activity Notices module.\r\n    This is used for utilising a similar command callback for a different command group, such as \"ra request\" and \"loa request\"\r\n    \"\"\"\r\n\r\n    def __init__(self, bot: commands.Bot):\r\n        self.bot = bot\r\n\r\n    async def upload_schema(self, schema: dict):\r\n        await self.bot.loas.insert(schema)\r\n\r\n    async def upload_to_views(self, code, message_id, *args):\r\n        await self.bot.views.insert(\r\n            {\r\n                \"_id\": code,\r\n                \"args\": [*args],\r\n                \"view_type\": \"LOAMenu\",\r\n                \"message_id\": message_id,\r\n            }\r\n        )\r\n\r\n    async def send_activity_request(\r\n        self,\r\n        guild: discord.Guild,\r\n        staff_channel: discord.TextChannel,\r\n        author: discord.Member,\r\n        schema,\r\n    ) -> dict:\r\n        request_type = schema[\"type\"]\r\n        settings = await self.bot.settings.find_by_id(guild.id)\r\n        management_roles = settings.get(\"staff_management\").get(\"management_role\")\r\n        loa_roles = settings.get(\"staff_management\").get(f\"{request_type.lower()}_role\")\r\n\r\n        embed = discord.Embed(title=f\"{request_type} Request\", color=BLANK_COLOR)\r\n        embed.set_author(name=guild.name, icon_url=guild.icon.url if guild.icon else \"\")\r\n\r\n        past_author_notices = [\r\n            item\r\n            async for item in self.bot.loas.db.find(\r\n                {\r\n                    \"guild_id\": guild.id,\r\n                    \"user_id\": author.id,\r\n                    \"accepted\": True,\r\n                    \"denied\": False,\r\n                    \"expired\": True,\r\n                    \"type\": request_type.upper(),\r\n                }\r\n            )\r\n        ]\r\n\r\n        shifts = []\r\n        storage_item = [\r\n            i\r\n            async for i in self.bot.shift_management.shifts.db.find(\r\n                {\"UserID\": author.id, \"Guild\": guild.id}\r\n            )\r\n        ]\r\n\r\n        for s in storage_item:\r\n            if s[\"EndEpoch\"] != 0:\r\n                shifts.append(s)\r\n\r\n        total_seconds = sum([get_elapsed_time(i) for i in shifts])\r\n\r\n        embed.add_field(\r\n            name=\"Staff Information\",\r\n            value=(\r\n                f\"> **Staff Member:** {author.mention}\\n\"\r\n                f\"> **Top Role:** {author.top_role.name}\\n\"\r\n                f\"> **Past {request_type}s:** {len(past_author_notices)}\\n\"\r\n                f\"> **Shift Time:** {td_format(datetime.timedelta(seconds=total_seconds))}\"\r\n            ),\r\n            inline=False,\r\n        )\r\n\r\n        embed.add_field(\r\n            name=\"Request Information\",\r\n            value=(\r\n                f\"> **Type:** {request_type}\\n\"\r\n                f\"> **Reason:** {schema['reason']}\\n\"\r\n                f\"> **Starts At:** <t:{schema.get('started_at', int(schema['_id'].split('_')[2]))}>\\n\"\r\n                f\"> **Ends At:** <t:{schema['expiry']}>\"\r\n            ),\r\n        )\r\n\r\n        view = LOAMenu(\r\n            self.bot,\r\n            management_roles,\r\n            loa_roles,\r\n            schema,\r\n            author.id,\r\n            (code := system_code_gen()),\r\n        )\r\n\r\n        msg = await staff_channel.send(embed=embed, view=view)\r\n        schema[\"message_id\"] = msg.id\r\n        await self.upload_to_views(\r\n            code, msg.id, \"SELF\", management_roles, loa_roles, schema, author.id, code\r\n        )\r\n        return schema\r\n\r\n    async def core_command_admin(\r\n        self, ctx: commands.Context, request_type_object: str, victim: discord.Member\r\n    ):\r\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\r\n        if not settings:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Setup\",\r\n                    description=\"Your server is not setup.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        if (\r\n            not settings.get(\"staff_management\")\r\n            or not settings.get(\"staff_management\", {}).get(\r\n                f\"{request_type_object.lower()}_role\", None\r\n            )\r\n            or not settings.get(\"staff_management\", {}).get(\"channel\")\r\n        ):\r\n            await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Enabled\",\r\n                    description=f\"{request_type_object.upper()} Requests are not enabled on this server.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n            return\r\n\r\n        try:\r\n            staff_channel = await ctx.guild.fetch_channel(\r\n                settings[\"staff_management\"][\"channel\"]\r\n            )\r\n        except Exception as _:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Channel Not Found\",\r\n                    description=f\"Activity Notice channel was not found.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        past_victim_notices = [\r\n            item\r\n            async for item in self.bot.loas.db.find(\r\n                {\r\n                    \"guild_id\": ctx.guild.id,\r\n                    \"user_id\": victim.id,\r\n                    \"accepted\": True,\r\n                    \"expired\": True,\r\n                    \"denied\": False,\r\n                    \"type\": request_type_object.upper(),\r\n                }\r\n            )\r\n        ]\r\n\r\n        current_notice = await self.bot.loas.db.find_one(\r\n            {\r\n                \"guild_id\": ctx.guild.id,\r\n                \"user_id\": victim.id,\r\n                \"accepted\": True,\r\n                \"denied\": False,\r\n                \"voided\": False,\r\n                \"expired\": False,\r\n                \"type\": request_type_object.upper(),\r\n            }\r\n        )\r\n\r\n        view = ActivityNoticeAdministration(\r\n            self.bot,\r\n            ctx.author.id,\r\n            victim=victim.id,\r\n            guild_id=ctx.guild.id,\r\n            request_type=request_type_object,\r\n            current_notice=current_notice,\r\n        )\r\n        embed = discord.Embed(title=\"Activity Notices\", color=BLANK_COLOR)\r\n        embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n        embed.add_field(\r\n            name=\"Staff Information\",\r\n            value=(\r\n                f\"> **Staff Member:** {victim.mention}\\n\"\r\n                f\"> **Top Role:** {victim.top_role.name}\\n\"\r\n                f\"> **Past {request_type_object.upper()}s:** {len(past_victim_notices)}\\n\"\r\n            ),\r\n            inline=False,\r\n        )\r\n\r\n        if current_notice is not None:\r\n            embed.add_field(\r\n                name=f\"Current {request_type_object.upper()} Information\",\r\n                value=(\r\n                    f\"> **Type:** {request_type_object.upper()}\\n\"\r\n                    f\"> **Reason:** {current_notice['reason']}\\n\"\r\n                    f\"> **Starts At:** <t:{current_notice.get('started_at', int(current_notice['_id'].split('_')[2]))}>\\n\"\r\n                    f\"> **Ends At:** <t:{current_notice['expiry']}>\"\r\n                ),\r\n                inline=False,\r\n            )\r\n\r\n        msg = await ctx.send(embed=embed, view=view)\r\n        await view.wait()\r\n\r\n        if view.value == \"create\":\r\n\r\n            async def respond(embed: discord.Embed):\r\n                if view.stored_interaction is not None:\r\n                    await view.stored_interaction.followup.send(\r\n                        embed=embed, ephemeral=True\r\n                    )\r\n                else:\r\n                    await msg.edit(embed=embed, view=None)\r\n\r\n            reason = view.modal.reason.value\r\n            duration = view.modal.duration.value\r\n            if not all([reason is not None, duration is not None]):\r\n                return await respond(\r\n                    embed=discord.Embed(\r\n                        title=\"Cancelled\",\r\n                        description=\"Not enough values were entered.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            try:\r\n                duration_seconds = time_converter(duration)\r\n            except ValueError:\r\n                return await respond(\r\n                    embed=discord.Embed(\r\n                        title=\"Invalid Time\",\r\n                        description=\"You did not provide a valid time format.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            if current_notice:\r\n                return await respond(\r\n                    embed=discord.Embed(\r\n                        title=\"Active Notice\",\r\n                        description=f\"This individual already has an active {request_type_object.upper()} notice.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n            else:\r\n                await self.core_command_request(\r\n                    ctx,\r\n                    request_type_object,\r\n                    duration,\r\n                    reason,\r\n                    return_bypass=True,\r\n                    override_victim=victim,\r\n                )\r\n                return await respond(\r\n                    embed=discord.Embed(\r\n                        title=f\"{self.bot.emoji_controller.get_emoji('success')} Request Sent\",\r\n                        description=f\"This {request_type_object.upper()} Request has been sent successfully.\",\r\n                        color=GREEN_COLOR,\r\n                    )\r\n                )\r\n        elif view.value == \"list\":\r\n\r\n            async def respond(\r\n                embed: discord.Embed, custom_view: discord.ui.View | None\r\n            ):\r\n                if view.stored_interaction is not None:\r\n                    if custom_view:\r\n                        await view.stored_interaction.followup.send(\r\n                            embed=embed,\r\n                            view=custom_view,\r\n                            # cant do ephemeral followup here.\r\n                            # since you cant edit an ephemeral followup of an interaction, since its both a followup (so edit_original_response doesnt work)\r\n                            # and ephemeral (message.edit doesnt work)\r\n                        )\r\n                    else:\r\n                        await view.stored_interaction.followup.send(embed=embed)\r\n                else:\r\n                    await msg.edit(embed=embed, view=custom_view)\r\n\r\n            def setup_embed() -> discord.Embed:\r\n                embed = discord.Embed(title=\"Activity Notices\", color=BLANK_COLOR)\r\n                embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n                return embed\r\n\r\n            embeds = []\r\n            for item in past_victim_notices:\r\n                if len(embeds) == 0:\r\n                    embeds.append(setup_embed())\r\n\r\n                if len(embeds[-1].fields) > 4:\r\n                    embeds.append(setup_embed())\r\n\r\n                embeds[-1].add_field(\r\n                    name=f\"{item['type']}\",\r\n                    value=(\r\n                        f\"> **Staff:** <@{item['user_id']}>\\n\"\r\n                        f\"> **Reason:** {item['reason']}\\n\"\r\n                        f\"> **Started At:** <t:{int(item.get('started_at', int(item['_id'].split('_')[2])))}>\\n\"\r\n                        f\"> **Ended At:** <t:{int(item['expiry'])}>\"\r\n                    ),\r\n                    inline=False,\r\n                )\r\n            pages = [\r\n                CustomPage(embeds=[embed], identifier=str(index + 1))\r\n                for index, embed in enumerate(embeds)\r\n            ]\r\n            if len(pages) == 0:\r\n                return await respond(\r\n                    embed=discord.Embed(\r\n                        title=\"No Activity Notices\",\r\n                        description=\"There were no active Activity Notices found.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    custom_view=None,\r\n                )\r\n\r\n            if len(pages) != 1:\r\n                paginator = SelectPagination(self.bot, ctx.author.id, pages=pages)\r\n                await respond(embed=embeds[0], custom_view=paginator)\r\n            else:\r\n                await respond(embed=embeds[0], custom_view=None)\r\n        elif view.value == \"delete\":\r\n\r\n            async def respond(embed: discord.Embed):\r\n                if view.stored_interaction is not None:\r\n                    await view.stored_interaction.followup.send(\r\n                        embed=embed, ephemeral=True\r\n                    )\r\n                else:\r\n                    await msg.edit(embed=embed, view=None)\r\n\r\n            if not current_notice:\r\n                return await respond(\r\n                    embed=discord.Embed(\r\n                        title=\"No Active Notice\",\r\n                        description=\"This staff member has no active notice.\",\r\n                    )\r\n                )\r\n\r\n            await self.bot.loas.delete_by_id(current_notice[\"_id\"])\r\n            return await respond(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Notice Deleted\",\r\n                    description=f\"This {request_type_object.upper()} Request has been deleted.\",\r\n                    color=GREEN_COLOR,\r\n                )\r\n            )\r\n\r\n        elif view.value == \"end\":\r\n\r\n            async def respond(embed: discord.Embed):\r\n                if view.stored_interaction is not None:\r\n                    await view.stored_interaction.followup.send(\r\n                        embed=embed, ephemeral=True\r\n                    )\r\n                else:\r\n                    await msg.edit(embed=embed, view=None)\r\n\r\n            if not current_notice:\r\n                return await respond(\r\n                    embed=discord.Embed(\r\n                        title=\"No Active Notice\",\r\n                        description=\"This staff member has no active notice.\",\r\n                    )\r\n                )\r\n\r\n            current_time = int(datetime.datetime.now().timestamp())\r\n            await self.bot.loas.db.update_one(\r\n                {\"_id\": current_notice[\"_id\"]},\r\n                {\"$set\": {\"expiry\": current_time, \"expired\": True}},\r\n            )\r\n\r\n            return await respond(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Notice Ended Early\",\r\n                    description=f\"{victim.mention}'s {request_type_object.upper()} has been ended early.\",\r\n                    color=GREEN_COLOR,\r\n                )\r\n            )\r\n\r\n        elif view.value == \"extend\":\r\n\r\n            async def respond(embed: discord.Embed):\r\n                if view.stored_interaction is not None:\r\n                    await view.stored_interaction.followup.send(\r\n                        embed=embed,\r\n                    )\r\n                else:\r\n                    await msg.edit(embed=embed, view=None)\r\n\r\n            if not current_notice:\r\n                return await respond(\r\n                    embed=discord.Embed(\r\n                        title=f\"{self.bot.emoji_controller.get_emoji('error')} No Active Notice\",\r\n                        description=\"This staff member has no active notice.\",\r\n                    )\r\n                )\r\n\r\n            duration = view.modal.duration.value\r\n            if duration is None:\r\n                return await respond(\r\n                    embed=discord.Embed(\r\n                        title=f\"{self.bot.emoji_controller.get_emoji('WarningIcon')} Cancelled\",\r\n                        description=\"You did not provide a duration.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            try:\r\n                duration_seconds = time_converter(duration)\r\n            except ValueError:\r\n                return await respond(\r\n                    embed=discord.Embed(\r\n                        title=f\"{self.bot.emoji_controller.get_emoji('WarningIcon')} Invalid Time\",\r\n                        description=\"You did not provide a valid time format.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n\r\n            new_expiry = current_notice[\"expiry\"] + duration_seconds\r\n            await self.bot.loas.db.update_one(\r\n                {\"_id\": current_notice[\"_id\"]}, {\"$set\": {\"expiry\": new_expiry}}\r\n            )\r\n\r\n            return await respond(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Notice Extended\",\r\n                    description=f\"{victim.mention}'s {request_type_object.upper()} has been extended by {duration}.\",\r\n                    color=GREEN_COLOR,\r\n                )\r\n            )\r\n\r\n    async def core_command_request(\r\n        self,\r\n        ctx: commands.Context,\r\n        request_type_object: str,\r\n        duration: str,\r\n        reason: str,\r\n        return_bypass=None,\r\n        override_victim=None,\r\n        starting: str = None,\r\n    ):\r\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\r\n        if (\r\n            not settings.get(\"staff_management\")\r\n            or not settings.get(\"staff_management\", {}).get(\r\n                f\"{request_type_object.lower()}_role\", None\r\n            )\r\n            or not settings.get(\"staff_management\", {}).get(\"enabled\")\r\n        ):\r\n            await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Enabled\",\r\n                    description=f\"{request_type_object.upper()} Requests are not enabled on this server.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n            return\r\n\r\n        if override_victim is not None:\r\n            member = override_victim\r\n        else:\r\n            member = ctx.author\r\n\r\n        try:\r\n            staff_channel = await ctx.guild.fetch_channel(\r\n                settings[\"staff_management\"][\"channel\"]\r\n            )\r\n        except discord.NotFound:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Channel Not Found\",\r\n                    description=f\"Activity Notice channel was not found.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        try:\r\n            duration_seconds = time_converter(duration)\r\n        except ValueError:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Incorrect Time\",\r\n                    description=f\"The time you provided was incorrect.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        active_author_notices = [\r\n            item\r\n            async for item in self.bot.loas.db.find(\r\n                {\r\n                    \"guild_id\": ctx.guild.id,\r\n                    \"user_id\": member.id,\r\n                    \"accepted\": True,\r\n                    \"denied\": False,\r\n                    \"expired\": False,\r\n                    \"voided\": False,\r\n                    \"type\": request_type_object.upper(),\r\n                }\r\n            )\r\n        ]\r\n\r\n        if len(active_author_notices) > 0:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Already Active\",\r\n                    description=f\"You already have a {request_type_object.upper()} request.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        current_timestamp = int(datetime.datetime.now().timestamp())\r\n        if starting:\r\n            start_after_seconds = time_converter(starting)\r\n            current_timestamp += start_after_seconds\r\n\r\n        expiry_timestamp = current_timestamp + duration_seconds\r\n\r\n        # print(current_timestamp)\r\n        # print(expiry_timestamp)\r\n\r\n        schema = {\r\n            \"_id\": f\"{member.id}_{ctx.guild.id}_{current_timestamp}_{expiry_timestamp}\",\r\n            \"user_id\": member.id,\r\n            \"guild_id\": ctx.guild.id,\r\n            \"message_id\": None,\r\n            \"type\": request_type_object.upper(),\r\n            \"started_at\": current_timestamp,\r\n            \"expiry\": expiry_timestamp,\r\n            \"expired\": False,\r\n            \"accepted\": False,\r\n            \"denied\": False,\r\n            \"voided\": False,\r\n            \"reason\": reason,\r\n        }\r\n\r\n        new_schema = await self.send_activity_request(\r\n            ctx.guild, staff_channel, member, schema\r\n        )\r\n\r\n        await self.upload_schema(new_schema)\r\n        if return_bypass is None:\r\n            await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Request Sent\",\r\n                    description=f\"Your {request_type_object.upper()} has been sent successfully.\",\r\n                    color=GREEN_COLOR,\r\n                )\r\n            )\r\n\r\n    async def core_command_active(\r\n        self, ctx: commands.Context, request_type_object: str\r\n    ):\r\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\r\n        if not settings.get(\"staff_management\") or not settings.get(\r\n            \"staff_management\", {}\r\n        ).get(f\"{request_type_object.lower()}_role\", None):\r\n            await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Enabled\",\r\n                    description=f\"{request_type_object.upper()} Requests are not enabled on this server.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n            return\r\n\r\n        request_upper = request_type_object.upper()\r\n        request_lower = request_type_object.lower()\r\n\r\n        active_requests = []\r\n        async for item in self.bot.loas.db.find(\r\n            {\r\n                \"guild_id\": ctx.guild.id,\r\n                \"accepted\": True,\r\n                \"denied\": False,\r\n                \"expired\": False,\r\n                \"type\": request_upper,\r\n            }\r\n        ):\r\n            item[\"started_at\"] = int(item[\"_id\"].split(\"_\")[2])\r\n            active_requests.append(item)\r\n\r\n        def setup_embed() -> discord.Embed:\r\n            embed = discord.Embed(title=\"Activity Notices\", color=BLANK_COLOR)\r\n            embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n            return embed\r\n\r\n        embeds = []\r\n        for item in active_requests:\r\n            if len(embeds) == 0:\r\n                embeds.append(setup_embed())\r\n\r\n            if len(embeds[-1].fields) > 4:\r\n                embeds.append(setup_embed())\r\n\r\n            embeds[-1].add_field(\r\n                name=f\"{item['type']}\",\r\n                value=(\r\n                    f\"> **Staff:** <@{item['user_id']}>\\n\"\r\n                    f\"> **Reason:** {item['reason']}\\n\"\r\n                    f\"> **Started At:** <t:{int(item.get('started_at', int(item['_id'].split('_')[2])))}>\\n\"\r\n                    f\"> **Ended At:** <t:{int(item['expiry'])}>\"\r\n                ),\r\n                inline=False,\r\n            )\r\n        pages = [\r\n            CustomPage(embeds=[embed], identifier=str(index + 1))\r\n            for index, embed in enumerate(embeds)\r\n        ]\r\n        if len(pages) == 0:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"No Activity Notices\",\r\n                    description=\"There were no active Activity Notices found.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        if len(pages) != 1:\r\n            paginator = SelectPagination(self.bot, ctx.author.id, pages=pages)\r\n            await ctx.send(embed=embeds[0], view=paginator)\r\n        else:\r\n            await ctx.send(embed=embeds[0])\r\n\r\n    async def core_command_view(self, ctx: commands.Context, request_type_object: str):\r\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\r\n        if not settings.get(\"staff_management\") or not settings.get(\r\n            \"staff_management\", {}\r\n        ).get(f\"{request_type_object.lower()}_role\", None):\r\n            await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"Not Enabled\",\r\n                    description=f\"{request_type_object.upper()} Requests are not enabled on this server.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n            return\r\n\r\n        request_upper = request_type_object.upper()\r\n\r\n        all_requests = []\r\n        async for item in self.bot.loas.db.find(\r\n            {\"guild_id\": ctx.guild.id, \"user_id\": ctx.author.id, \"type\": request_upper}\r\n        ):\r\n            all_requests.append(item)\r\n\r\n        def setup_embed() -> discord.Embed:\r\n            embed = discord.Embed(title=\"Activity Notices\", color=BLANK_COLOR)\r\n            embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\r\n            return embed\r\n\r\n        embeds = []\r\n        for item in all_requests:\r\n            if len(embeds) == 0:\r\n                embeds.append(setup_embed())\r\n            if len(embeds[-1].fields) > 4:\r\n                embeds.append(setup_embed())\r\n            embeds[-1].add_field(\r\n                name=f\"{item['type']}\",\r\n                value=(\r\n                    f\"> **Reason:** {item['reason']}\\n\"\r\n                    f\"> **Started At:** <t:{int(item.get('started_at', int(item['_id'].split('_')[2])))}>\\n\"\r\n                    f\"> **Ended At:** <t:{int(item['expiry'])}>\"\r\n                ),\r\n                inline=False,\r\n            )\r\n        pages = [\r\n            CustomPage(embeds=[embed], identifier=str(index + 1))\r\n            for index, embed in enumerate(embeds)\r\n        ]\r\n        if len(pages) == 0:\r\n            return await ctx.send(\r\n                embed=discord.Embed(\r\n                    title=\"No Activity Notices\",\r\n                    description=\"There were no active Activity Notices found.\",\r\n                    color=BLANK_COLOR,\r\n                )\r\n            )\r\n\r\n        if len(pages) != 1:\r\n            paginator = SelectPagination(self.bot, ctx.author.id, pages=pages)\r\n            await ctx.channel.send(embed=embeds[0], view=paginator)\r\n\r\n        else:\r\n            await ctx.channel.send(\r\n                embed=embeds[0],\r\n            )\r\n\r\n\r\nclass StaffManagement(commands.Cog):\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n        self.core_commands = ActivityCoreCommands(bot)\r\n\r\n    @commands.hybrid_group(\r\n        name=\"ra\",\r\n        description=\"File a Reduced Activity request\",\r\n        extras={\"category\": \"Staff Management\"},\r\n        with_app_command=True,\r\n    )\r\n    async def ra(self, ctx, time, *, reason):\r\n        pass\r\n\r\n    @commands.guild_only()\r\n    @ra.command(\r\n        name=\"active\",\r\n        description=\"View all active RAs\",\r\n        extras={\"category\": \"Staff Management\"},\r\n    )\r\n    @is_admin()\r\n    @require_settings()\r\n    async def ra_active(self, ctx):\r\n        await self.core_commands.core_command_active(ctx, \"ra\")\r\n\r\n    @commands.guild_only()\r\n    @ra.command(\r\n        name=\"request\",\r\n        description=\"File a Reduced Activity request\",\r\n        extras={\"category\": \"Staff Management\", \"ephemeral\": True},\r\n        with_app_command=True,\r\n    )\r\n    @is_staff()\r\n    @app_commands.describe(time=\"How long are you going to be on RA for? (s/m/h/d)\")\r\n    @app_commands.describe(reason=\"What is your reason for going on RA?\")\r\n    @app_commands.describe(starting=\"When would you like to start your RA? (s/m/h/d)\")\r\n    async def ra_request(self, ctx, time, *, reason, starting: str = None):\r\n        await self.core_commands.core_command_request(\r\n            ctx, \"ra\", time, reason, starting=starting\r\n        )\r\n\r\n    @commands.guild_only()\r\n    @ra.command(\r\n        name=\"admin\",\r\n        description=\"Administrate a Reduced Activity request\",\r\n        extras={\"category\": \"Staff Management\"},\r\n        with_app_command=True,\r\n    )\r\n    @is_admin()\r\n    @app_commands.describe(\r\n        member=\"Who's RA would you like to administrate? Specify a Discord user.\"\r\n    )\r\n    async def ra_admin(self, ctx, member: discord.Member):\r\n        await log_command_usage(self.bot, ctx.guild, ctx.author, f\"RA Admin: {member}\")\r\n        await self.core_commands.core_command_admin(ctx, \"ra\", member)\r\n\r\n    @commands.guild_only()\r\n    @ra.command(\r\n        name=\"view\",\r\n        description=\"View your active RA\",\r\n        extras={\"category\": \"Staff Management\"},\r\n        with_app_command=True,\r\n    )\r\n    @is_staff()\r\n    async def ra_view(self, ctx):\r\n        await self.core_commands.core_command_view(ctx, \"ra\")\r\n\r\n    @commands.hybrid_group(\r\n        name=\"loa\",\r\n        description=\"File a Leave of Absence request\",\r\n        extras={\"category\": \"Staff Management\"},\r\n        with_app_command=True,\r\n    )\r\n    @app_commands.describe(time=\"How long are you going to be on LoA for? (s/m/h/d)\")\r\n    @app_commands.describe(reason=\"What is your reason for going on LoA?\")\r\n    async def loa(self, ctx, time, *, reason):\r\n        await ctx.invoke(self.bot.get_command(\"loa request\"), time=time, reason=reason)\r\n\r\n    @commands.guild_only()\r\n    @loa.command(\r\n        name=\"view\",\r\n        description=\"View your active LOA\",\r\n        extras={\"category\": \"Staff Management\"},\r\n        with_app_command=True,\r\n    )\r\n    @is_staff()\r\n    async def loa_view(self, ctx):\r\n        await self.core_commands.core_command_view(ctx, \"loa\")\r\n\r\n    @loa.command(\r\n        name=\"active\",\r\n        description=\"View all active LOAs\",\r\n        extras={\"category\": \"Staff Management\"},\r\n    )\r\n    @is_admin()\r\n    async def loa_active(self, ctx):\r\n        await self.core_commands.core_command_active(ctx, \"loa\")\r\n\r\n    @commands.guild_only()\r\n    @loa.command(\r\n        name=\"request\",\r\n        description=\"File a Leave of Absence request\",\r\n        extras={\"category\": \"Staff Management\", \"ephemeral\": True},\r\n        with_app_command=True,\r\n    )\r\n    @is_staff()\r\n    @app_commands.describe(time=\"How long are you going to be on LoA for? (s/m/h/d)\")\r\n    @app_commands.describe(reason=\"What is your reason for going on LoA?\")\r\n    @app_commands.describe(starting=\"When would you like to start your LOA? (s/m/h/d)\")\r\n    async def loa_request(self, ctx, time, *, reason, starting: str = None):\r\n        await self.core_commands.core_command_request(\r\n            ctx, \"loa\", time, reason, starting=starting\r\n        )\r\n\r\n    @commands.guild_only()\r\n    @loa.command(\r\n        name=\"admin\",\r\n        description=\"Administrate a Leave of Absence request\",\r\n        extras={\"category\": \"Staff Management\"},\r\n        with_app_command=True,\r\n    )\r\n    @is_admin()\r\n    @app_commands.describe(\r\n        member=\"Who's LOA would you like to administrate? Specify a Discord user.\"\r\n    )\r\n    async def loa_admin(self, ctx, member: discord.Member):\r\n        await log_command_usage(self.bot, ctx.guild, ctx.author, f\"LOA Admin: {member}\")\r\n\r\n        return await self.core_commands.core_command_admin(ctx, \"loa\", member)\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(StaffManagement(bot))\r\n"}
{"type": "source_file", "path": "datamodels/SavedLogs.py", "content": "from discord.ext import commands\nimport discord\nfrom utils.mongo import Document\nfrom utils.basedataclass import BaseDataClass\n\n\nclass SavedLog(BaseDataClass):\n    guild_id: int\n    timestamp: int\n    logs: list[dict]\n\n\nclass SavedLogs(Document):\n    pass\n"}
{"type": "source_file", "path": "datamodels/StaffConductConfig.py", "content": "from discord.ext import commands\nimport discord\nfrom utils.mongo import Document\n\n\nclass StaffConductConfig(Document):\n    pass\n"}
{"type": "source_file", "path": "datamodels/Errors.py", "content": "from discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass Errors(Document):\r\n    pass\r\n"}
{"type": "source_file", "path": "datamodels/Consent.py", "content": "from discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass Consent(Document):\r\n    pass\r\n"}
{"type": "source_file", "path": "datamodels/OAuth2Users.py", "content": "from discord.ext import commands\nimport discord\nfrom utils.mongo import Document\n\n\nclass OAuth2Users(Document):\n    pass\n"}
{"type": "source_file", "path": "datamodels/ShiftManagement.py", "content": "import datetime\r\nimport asyncio\r\nimport logging\r\nfrom typing import Optional\r\n\r\nimport aiohttp\r\nfrom bson import ObjectId\r\nfrom discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\nfrom decouple import config\r\n\r\nfrom utils.basedataclass import BaseDataClass\r\n\r\n\r\nclass BreakItem(BaseDataClass):\r\n    start_epoch: int\r\n    end_epoch: int\r\n\r\n\r\nclass ShiftItem:\r\n    id: str\r\n    username: str\r\n    nickname: str\r\n    user_id: int\r\n    type: str\r\n    start_epoch: int\r\n    breaks: list\r\n    guild: int\r\n    moderations: list\r\n    end_epoch: int\r\n    added_time: int\r\n    removed_time: int\r\n\r\n    def __init__(self, **kwargs):\r\n        for key, value in kwargs.items():\r\n            setattr(self, key, value)\r\n\r\n\r\nclass ShiftManagement:\r\n    def __init__(self, connection, current_shifts):\r\n        self.shifts = Document(connection, current_shifts)\r\n        self.logger = logging.getLogger(__name__)\r\n\r\n    async def fetch_shift(self, object_id: ObjectId) -> Optional[ShiftItem]:\r\n        shift = await self.shifts.find_by_id(object_id)\r\n        if not shift:\r\n            return None\r\n        return ShiftItem(\r\n            id=shift[\"_id\"],\r\n            username=shift[\"Username\"],\r\n            nickname=shift[\"Nickname\"],\r\n            user_id=shift[\"UserID\"],\r\n            type=shift[\"Type\"],\r\n            start_epoch=shift[\"StartEpoch\"],\r\n            breaks=[\r\n                BreakItem(start_epoch=item[\"StartEpoch\"], end_epoch=item[\"EndEpoch\"])\r\n                for item in shift[\"Breaks\"]\r\n            ],\r\n            guild=shift[\"Guild\"],\r\n            moderations=shift[\"Moderations\"],\r\n            end_epoch=shift[\"EndEpoch\"],\r\n            added_time=shift[\"AddedTime\"],\r\n            removed_time=shift[\"RemovedTime\"],\r\n        )\r\n\r\n    async def add_shift_by_user(\r\n        self,\r\n        member: discord.Member,\r\n        shift_type: str,\r\n        breaks: list,\r\n        guild: int,\r\n        timestamp: int = 0,\r\n    ) -> ObjectId:\r\n        \"\"\"\r\n        Adds a shift for the specified user to the database and syncs with external APIs.\r\n\r\n        Args:\r\n            member: Discord member starting the shift\r\n            shift_type: Type of shift being started\r\n            breaks: List of break periods\r\n            guild: Guild ID where the shift is being started\r\n            timestamp: Optional custom start timestamp\r\n\r\n        Returns:\r\n            ObjectId of the created shift document\r\n\r\n        Raises:\r\n            aiohttp.ClientError: If API sync fails\r\n        \"\"\"\r\n        data = {\r\n            \"_id\": ObjectId(),\r\n            \"Username\": member.name,\r\n            \"Nickname\": member.display_name,\r\n            \"UserID\": member.id,\r\n            \"Type\": shift_type,\r\n            \"StartEpoch\": (\r\n                datetime.datetime.now().timestamp()\r\n                if timestamp in [0, None]\r\n                else timestamp\r\n            ),\r\n            \"Breaks\": breaks,\r\n            \"Guild\": guild,\r\n            \"Moderations\": [],\r\n            \"AddedTime\": 0,\r\n            \"RemovedTime\": 0,\r\n            \"EndEpoch\": 0,\r\n        }\r\n\r\n        await self.shifts.db.insert_one(data)\r\n\r\n        url_var = config(\"BASE_API_URL\")\r\n        panel_url_var = config(\"PANEL_API_URL\")\r\n\r\n        async def sync_with_apis():\r\n            async with aiohttp.ClientSession() as session:\r\n                tasks = []\r\n\r\n                if url_var not in [\"\", None]:\r\n                    tasks.append(\r\n                        session.get(\r\n                            f\"{url_var}/Internal/SyncStartShift/{data['_id']}\",\r\n                            headers={\"Authorization\": config(\"INTERNAL_API_AUTH\")},\r\n                            raise_for_status=True,\r\n                        )\r\n                    )\r\n\r\n                if panel_url_var not in [\"\", None]:\r\n                    tasks.append(\r\n                        session.post(\r\n                            f\"{panel_url_var}/{guild}/SyncStartShift?ID={data['_id']}\",\r\n                            headers={\"X-Static-Token\": config(\"PANEL_STATIC_AUTH\")},\r\n                            raise_for_status=True,\r\n                        )\r\n                    )\r\n\r\n                if tasks:\r\n                    responses = await asyncio.gather(*tasks, return_exceptions=True)\r\n                    for response in responses:\r\n                        if isinstance(response, Exception):\r\n                            self.logger.error(f\"API sync failed: {str(response)}\")\r\n\r\n        try:\r\n            await sync_with_apis()\r\n        except aiohttp.ClientError as e:\r\n            self.logger.error(f\"Failed to sync shift start with APIs: {str(e)}\")\r\n        except Exception as e:\r\n            self.logger.error(f\"Unexpected error during API sync: {str(e)}\")\r\n\r\n        return data[\"_id\"]\r\n\r\n    async def add_time_to_shift(self, identifier: str, seconds: int):\r\n        \"\"\"\r\n        Adds time to the specified user's shift.\r\n        \"\"\"\r\n        document = await self.shifts.db.find_one({\"_id\": ObjectId(identifier)})\r\n        document[\"AddedTime\"] += int(seconds)\r\n        await self.shifts.update_by_id(document)\r\n        return document\r\n\r\n    async def remove_time_from_shift(self, identifier: str, seconds: int):\r\n        \"\"\"\r\n        Removes time from the specified user's shift.\r\n        \"\"\"\r\n        document = await self.shifts.db.find_one({\"_id\": ObjectId(identifier)})\r\n        document[\"RemovedTime\"] += int(seconds)\r\n        await self.shifts.update_by_id(document)\r\n        return document\r\n\r\n    async def end_shift(\r\n        self, identifier: str, guild_id: int | None = None, timestamp: int | None = None\r\n    ):\r\n        \"\"\"\r\n        Ends the specified user's shift and syncs with external APIs.\r\n\r\n        Args:\r\n            identifier: Shift document ID\r\n            guild_id: Optional guild ID override\r\n            timestamp: Optional custom end timestamp\r\n\r\n        Returns:\r\n            Updated shift document\r\n\r\n        Raises:\r\n            ValueError: If shift not found or guild mismatch\r\n        \"\"\"\r\n        document = await self.shifts.db.find_one({\"_id\": ObjectId(identifier)})\r\n        if not document:\r\n            raise ValueError(\"Shift not found.\")\r\n\r\n        guild_id = guild_id if guild_id else document[\"Guild\"]\r\n\r\n        if document[\"Guild\"] != guild_id:\r\n            raise ValueError(\"Shift not found.\")\r\n\r\n        current_time = (\r\n            datetime.datetime.now().timestamp() if timestamp in [None, 0] else timestamp\r\n        )\r\n        document[\"EndEpoch\"] = current_time\r\n\r\n        # Close any open breaks\r\n        for breaks in document[\"Breaks\"]:\r\n            if breaks[\"EndEpoch\"] == 0:\r\n                breaks[\"EndEpoch\"] = int(current_time)\r\n\r\n        url_var = config(\"BASE_API_URL\")\r\n        panel_url_var = config(\"PANEL_API_URL\")\r\n\r\n        async def sync_end_with_apis():\r\n            async with aiohttp.ClientSession() as session:\r\n                tasks = []\r\n\r\n                if url_var not in [\"\", None]:\r\n                    tasks.append(\r\n                        session.get(\r\n                            f\"{url_var}/Internal/SyncEndShift/{document['UserID']}/{guild_id}\",\r\n                            headers={\"Authorization\": config(\"INTERNAL_API_AUTH\")},\r\n                            raise_for_status=True,\r\n                        )\r\n                    )\r\n\r\n                if panel_url_var not in [\"\", None]:\r\n                    tasks.append(\r\n                        session.delete(\r\n                            f\"{panel_url_var}/{guild_id}/SyncEndShift?ID={document['_id']}\",\r\n                            headers={\"X-Static-Token\": config(\"PANEL_STATIC_AUTH\")},\r\n                            raise_for_status=True,\r\n                        )\r\n                    )\r\n\r\n                if tasks:\r\n                    responses = await asyncio.gather(*tasks, return_exceptions=True)\r\n                    for response in responses:\r\n                        if isinstance(response, Exception):\r\n                            self.logger.error(\r\n                                f\"End shift API sync failed: {str(response)}\"\r\n                            )\r\n\r\n        try:\r\n            await sync_end_with_apis()\r\n        except aiohttp.ClientError as e:\r\n            self.logger.error(f\"Failed to sync shift end with APIs: {str(e)}\")\r\n        except Exception as e:\r\n            self.logger.error(f\"Unexpected error during end shift API sync: {str(e)}\")\r\n\r\n        await self.shifts.update_by_id(document)\r\n        return document\r\n\r\n    async def get_current_shift(self, member: discord.Member, guild_id: int):\r\n        \"\"\"\r\n        Gets the current shift for the specified user.\r\n\r\n        Args:\r\n            member: Discord member to check\r\n            guild_id: Guild ID to check\r\n\r\n        Returns:\r\n            Current shift document or None if no active shift\r\n        \"\"\"\r\n        return await self.shifts.db.find_one(\r\n            {\"UserID\": member.id, \"EndEpoch\": 0, \"Guild\": guild_id}\r\n        )\r\n"}
{"type": "source_file", "path": "datamodels/PunishmentTypes.py", "content": "from discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass PunishmentTypes(Document):\r\n    async def get_punishment_types(self, guild_id: int):\r\n        \"\"\"\r\n        Gets the punishment types for a guild.\r\n        \"\"\"\r\n        return await self.db.find_one({\"_id\": guild_id})\r\n"}
{"type": "source_file", "path": "datamodels/Settings.py", "content": "from discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass PunishmentType:\r\n    def __init__(self, generic: bool, custom: bool, name: str):\r\n        self.generic = generic\r\n        self.custom = custom\r\n        self.name = name\r\n\r\n    generic: bool\r\n    custom: bool\r\n    name: str\r\n\r\n\r\nclass Settings(Document):\r\n    async def get_settings(self, guild_id: int) -> dict:\r\n        \"\"\"\r\n        Gets the settings for a guild.\r\n        \"\"\"\r\n        return await self.db.find_one({\"_id\": guild_id})\r\n\r\n    pass\r\n"}
{"type": "source_file", "path": "cogs/Infractions.py", "content": "import datetime\nimport discord\nimport pytz\nfrom discord.ext import commands\nfrom discord import app_commands\n\nfrom erm import is_staff, management_predicate, is_management\nfrom utils.constants import BLANK_COLOR\nfrom utils.paginators import SelectPagination, CustomPage\nfrom utils.utils import require_settings, get_roblox_by_username\nfrom utils.autocompletes import user_autocomplete, infraction_type_autocomplete\n\n\nclass Infractions(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n\n    async def check_manager_role(self, ctx):\n        \"\"\"Helper method to check if user has manager role from settings\"\"\"\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\n        if not settings or \"infractions\" not in settings:\n            return False\n\n        manager_roles = settings[\"infractions\"].get(\"manager_roles\", [])\n        return any(role.id in manager_roles for role in ctx.author.roles)\n\n    @commands.hybrid_group(name=\"infractions\")\n    @is_staff()\n    async def infractions(self, ctx):\n        \"\"\"Base command for infractions\"\"\"\n        if ctx.invoked_subcommand is None:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Invalid Subcommand\",\n                    description=\"Please specify a valid subcommand.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n    @commands.guild_only()\n    @commands.hybrid_command(\n        name=\"myinfractions\",\n        description=\"View your infractions\",\n        extras={\"category\": \"Infractions\"},\n    )\n    @is_staff()\n    @require_settings()\n    async def myinfractions(self, ctx):\n        \"\"\"View your infractions\"\"\"\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\n        if not settings:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Setup\",\n                    description=\"Your server is not setup.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        if not settings.get(\"infractions\"):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Enabled\",\n                    description=\"Infractions are not enabled on this server.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        infractions = []\n        async for infraction in self.bot.db.infractions.find(\n            {\"guild_id\": ctx.guild.id, \"user_id\": ctx.author.id}\n        ).sort(\"timestamp\", -1):\n            infractions.append(infraction)\n\n        if len(infractions) == 0:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"No Infractions\",\n                    description=\"You have no infractions.\",\n                    color=BLANK_COLOR,\n                ),\n                ephemeral=True,\n            )\n\n        def setup_embed() -> discord.Embed:\n            embed = discord.Embed(title=\"Your Infractions\", color=BLANK_COLOR)\n            embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n            return embed\n\n        embeds = []\n        for infraction in infractions:\n            if len(embeds) == 0 or len(embeds[-1].fields) >= 4:\n                embeds.append(setup_embed())\n\n            embed = embeds[-1]\n            issuer = \"System\"\n            if infraction.get(\"issuer_id\"):\n                issuer = f\"<@{infraction['issuer_id']}>\"\n\n            embed.add_field(\n                name=f\"Infraction #{infraction.get('_id', 'Unknown')}\",\n                value=(\n                    f\"> **Type:** {infraction['type']}\\n\"\n                    f\"> **Reason:** {infraction['reason']}\\n\"\n                    f\"> **Issuer:** {issuer}\\n\"\n                    f\"> **Date:** <t:{int(infraction['timestamp'])}:F>\\n\"\n                    f\"> **Status:** {'Revoked' if infraction.get('revoked', False) else 'Active'}\"\n                ),\n                inline=False,\n            )\n\n        pages = [\n            CustomPage(embeds=[embed], identifier=str(index + 1))\n            for index, embed in enumerate(embeds)\n        ]\n\n        if len(pages) > 1:\n            paginator = SelectPagination(self.bot, ctx.author.id, pages=pages)\n            await ctx.send(embed=embeds[0], view=paginator)\n        else:\n            await ctx.send(embed=embeds[0])\n\n    @commands.guild_only()\n    @infractions.command(\n        name=\"view\",\n        description=\"View a user's infractions\",\n        extras={\"category\": \"Infractions\"},\n    )\n    @is_staff()\n    @require_settings()\n    @app_commands.describe(user=\"The user to check infractions for\")\n    async def infractions_view(self, ctx, user: discord.Member):\n        \"\"\"View a user's infractions\"\"\"\n        if user.id != ctx.author.id:\n            has_manager_role = await self.check_manager_role(ctx)\n            if not has_manager_role and not await management_predicate(ctx):\n                return await ctx.send(\n                    embed=discord.Embed(\n                        title=\"Permission Denied\",\n                        description=\"You need management permissions to view other users' infractions.\",\n                        color=BLANK_COLOR,\n                    )\n                )\n\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\n        if not settings:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Setup\",\n                    description=\"Your server is not setup.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        if not settings.get(\"infractions\"):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Enabled\",\n                    description=\"Infractions are not enabled on this server.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        target_id = user.id\n\n        infractions = []\n        async for infraction in self.bot.db.infractions.find(\n            {\"guild_id\": ctx.guild.id, \"user_id\": target_id}\n        ).sort(\"timestamp\", -1):\n            infractions.append(infraction)\n\n        if len(infractions) == 0:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"No Infractions\",\n                    description=f\"{'You have' if target_id == ctx.author.id else 'This user has'} no infractions.\",\n                    color=BLANK_COLOR,\n                ),\n                ephemeral=True,\n            )\n\n        def setup_embed() -> discord.Embed:\n            name = None\n            try:\n                if target_id:\n                    member = ctx.guild.get_member(target_id)\n                    if member:\n                        name = member.name\n                    else:\n                        user = self.bot.get_user(target_id)\n                        if user:\n                            name = user.name\n            except:\n                pass\n\n            if not name:\n                name = str(target_id)\n\n            embed = discord.Embed(title=f\"Infractions for {name}\", color=BLANK_COLOR)\n            embed.set_author(name=ctx.guild.name, icon_url=ctx.guild.icon)\n            return embed\n\n        embeds = []\n        for infraction in infractions:\n            if len(embeds) == 0 or len(embeds[-1].fields) >= 4:\n                embeds.append(setup_embed())\n\n            embed = embeds[-1]\n            issuer = \"System\"\n            if infraction.get(\"issuer_id\"):\n                issuer = f\"<@{infraction['issuer_id']}>\"\n\n            embed.add_field(\n                name=f\"Infraction #{infraction.get('_id', 'Unknown')}\",\n                value=(\n                    f\"> **Type:** {infraction['type']}\\n\"\n                    f\"> **Reason:** {infraction['reason']}\\n\"\n                    f\"> **Issuer:** {issuer}\\n\"\n                    f\"> **Date:** <t:{int(infraction['timestamp'])}:F>\\n\"\n                    f\"> **Status:** {'Revoked' if infraction.get('revoked', False) else 'Active'}\"\n                ),\n                inline=False,\n            )\n\n        pages = [\n            CustomPage(embeds=[embed], identifier=str(index + 1))\n            for index, embed in enumerate(embeds)\n        ]\n\n        if len(pages) > 1:\n            paginator = SelectPagination(self.bot, ctx.author.id, pages=pages)\n            await ctx.send(embed=embeds[0], view=paginator)\n        else:\n            await ctx.send(embed=embeds[0])\n\n    @commands.guild_only()\n    @infractions.command(name=\"issue\", description=\"Issue an infraction to a user\")\n    @is_staff()\n    @require_settings()\n    @app_commands.autocomplete(type=infraction_type_autocomplete)\n    @app_commands.describe(\n        type=\"The type of infraction to give\",\n        user=\"The user to issue an infraction to\",\n        reason=\"What is your reason for giving this infraction?\",\n    )\n    async def infractions_issue(\n        self, ctx, user: discord.Member, type: str, *, reason: str\n    ):\n        \"\"\"Issue an infraction to a user\"\"\"\n        has_manager_role = await self.check_manager_role(ctx)\n        if not has_manager_role and not await management_predicate(ctx):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Permission Denied\",\n                    description=\"You need management permissions or your infractions manager permission to issue infractions.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        settings = await self.bot.settings.find_by_id(ctx.guild.id)\n        if not settings:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Setup\",\n                    description=\"Your server is not setup.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        if not settings.get(\"infractions\"):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Not Enabled\",\n                    description=\"Infractions are not enabled on this server.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        target_id = user.id\n        target_name = user.name\n\n        infraction_config = next(\n            (\n                inf\n                for inf in settings[\"infractions\"][\"infractions\"]\n                if inf[\"name\"] == type\n            ),\n            None,\n        )\n\n        if not infraction_config:\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Invalid Type\",\n                    description=\"This infraction type does not exist.\",\n                    color=BLANK_COLOR,\n                ),\n                ephemeral=True,\n            )\n\n        will_escalate = False\n        existing_count = 0\n        original_type = type\n        current_type = type\n\n        if infraction_config.get(\"escalation\"):\n            while True:\n                threshold = infraction_config[\"escalation\"].get(\"threshold\", 0)\n                next_infraction = infraction_config[\"escalation\"].get(\"next_infraction\")\n\n                if not threshold or not next_infraction:\n                    break\n\n                existing_count = await self.bot.db.infractions.count_documents(\n                    {\n                        \"user_id\": target_id,\n                        \"guild_id\": ctx.guild.id,\n                        \"type\": current_type,\n                        \"revoked\": {\"$ne\": True},\n                    }\n                )\n\n                if (existing_count + 1) >= threshold:\n                    next_config = next(\n                        (\n                            inf\n                            for inf in settings[\"infractions\"][\"infractions\"]\n                            if inf[\"name\"] == next_infraction\n                        ),\n                        None,\n                    )\n                    if not next_config:\n                        break\n\n                    current_type = next_infraction\n                    will_escalate = True\n                    infraction_config = next_config\n                else:\n                    break\n\n        if will_escalate:\n            type = current_type\n            reason = (\n                f\"{reason}\\n\\nEscalated from {original_type} after reaching threshold\"\n            )\n\n        # Create infraction document\n        infraction_doc = {\n            \"user_id\": target_id,\n            \"username\": target_name,\n            \"guild_id\": ctx.guild.id,\n            \"type\": type,\n            \"original_type\": original_type if will_escalate else None,\n            \"reason\": reason,\n            \"timestamp\": datetime.datetime.now(tz=pytz.UTC).timestamp(),\n            \"issuer_id\": ctx.author.id,\n            \"issuer_username\": ctx.author.name,\n            \"escalated\": will_escalate,\n            \"escalation_count\": existing_count + 1 if will_escalate else None,\n        }\n\n        result = await self.bot.db.infractions.insert_one(infraction_doc)\n        infraction_doc[\"_id\"] = result.inserted_id\n\n        self.bot.dispatch(\"infraction_create\", infraction_doc)\n\n        target_name = str(target_id)\n        try:\n            member = ctx.guild.get_member(target_id)\n            if member:\n                target_name = member.name\n            else:\n                user = self.bot.get_user(target_id)\n                if user:\n                    target_name = user.name\n                else:\n                    roblox_user = await get_roblox_by_username(\n                        str(target_id), self.bot, ctx\n                    )\n                    if roblox_user and not roblox_user.get(\"errors\"):\n                        target_name = roblox_user[\"name\"]\n        except:\n            pass\n\n        await ctx.send(\n            embed=discord.Embed(\n                title=f\"{self.bot.emoji_controller.get_emoji('success')} Infraction Issued\",\n                description=\"Successfully issued an infraction!\",\n                color=discord.Color.green(),\n            ).add_field(\n                name=\"Details\",\n                value=(\n                    f\"> **User:** {target_name}\\n\"\n                    f\"> **Type:** {type}\\n\"\n                    f\"> **Reason:** {reason}\\n\"\n                    f\"> **Issued By:** {ctx.author.mention}\\n\"\n                    f\"> **Date:** <t:{int(infraction_doc['timestamp'])}:F>\\n\"\n                    f\"> **ID:** `{result.inserted_id}`\\n\"\n                    + (\n                        f\"> **Escalated:** Yes (from {original_type})\"\n                        if will_escalate\n                        else \"\"\n                    )\n                ),\n                inline=False,\n            ),\n            ephemeral=True,\n        )\n\n    @infractions.command(name=\"revoke\", description=\"Revoke an infraction using its ID\")\n    @is_staff()\n    @require_settings()\n    @app_commands.describe(infraction_id=\"The ID of the infraction to revoke\")\n    async def infractions_revoke(self, ctx, infraction_id: str):\n        \"\"\"Revoke an infraction\"\"\"\n        has_manager_role = await self.check_manager_role(ctx)\n        if not has_manager_role and not await management_predicate(ctx):\n            return await ctx.send(\n                embed=discord.Embed(\n                    title=\"Permission Denied\",\n                    description=\"You need management permissions to revoke infractions.\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n        try:\n            from bson import ObjectId\n\n            infraction = await self.bot.db.infractions.find_one(\n                {\"_id\": ObjectId(infraction_id)}\n            )\n            if not infraction:\n                return await ctx.send(\n                    embed=discord.Embed(\n                        title=\"Not Found\",\n                        description=\"No infraction was found with that ID.\",\n                        color=BLANK_COLOR,\n                    )\n                )\n\n            if infraction[\"guild_id\"] != ctx.guild.id:\n                return await ctx.send(\n                    embed=discord.Embed(\n                        title=\"Not Found\",\n                        description=\"No infraction was found with that ID in this server.\",\n                        color=BLANK_COLOR,\n                    )\n                )\n\n            if infraction.get(\"revoked\", False):\n                return await ctx.send(\n                    embed=discord.Embed(\n                        title=\"Already Revoked\",\n                        description=\"This infraction has already been revoked.\",\n                        color=BLANK_COLOR,\n                    )\n                )\n\n            await self.bot.db.infractions.update_one(\n                {\"_id\": ObjectId(infraction_id)},\n                {\n                    \"$set\": {\n                        \"revoked\": True,\n                        \"revoked_at\": datetime.datetime.now(tz=pytz.UTC).timestamp(),\n                        \"revoked_by\": ctx.author.id,\n                    }\n                },\n            )\n\n            infraction[\"revoked\"] = True\n            infraction[\"revoked_at\"] = datetime.datetime.now(tz=pytz.UTC).timestamp()\n            infraction[\"revoked_by\"] = ctx.author.id\n            self.bot.dispatch(\"infraction_revoke\", infraction)\n\n            await ctx.send(\n                embed=discord.Embed(\n                    title=f\"{self.bot.emoji_controller.get_emoji('success')} Infraction Revoked\",\n                    description=\"Successfully revoked the infraction!\",\n                    color=discord.Color.green(),\n                )\n            )\n\n        except Exception as e:\n            await ctx.send(\n                embed=discord.Embed(\n                    title=\"Error\",\n                    description=f\"An error occurred while revoking the infraction: {str(e)}\",\n                    color=BLANK_COLOR,\n                )\n            )\n\n\nasync def setup(bot):\n    await bot.add_cog(Infractions(bot))\n"}
{"type": "source_file", "path": "datamodels/MapleKeys.py", "content": "from discord.ext import commands\nimport discord\nfrom utils.mongo import Document\nfrom datamodels.ServerKeys import ServerKey\n\n\nclass MapleKeys(Document):\n    async def get_server_key(self, guild_id: int):\n        doc = await self.db.find_one({\"guildId\": guild_id})\n        if not doc:\n            return None\n        return ServerKey(guild_id=doc[\"guildId\"], key=doc[\"uniqueToken\"])\n"}
{"type": "source_file", "path": "datamodels/Reminders.py", "content": "from discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass Reminders(Document):\r\n    pass\r\n"}
{"type": "source_file", "path": "events/on_break_start.py", "content": "import datetime\n\nimport discord\nfrom bson import ObjectId\nfrom discord.ext import commands\nfrom datamodels.ShiftManagement import ShiftItem\nfrom utils.constants import BLANK_COLOR\nfrom utils.timestamp import td_format\n\n\nclass OnBreakStart(commands.Cog):\n    def __init__(self, bot: commands.Bot):\n        self.bot = bot\n\n    @commands.Cog.listener()\n    async def on_break_start(self, object_id: ObjectId):\n\n        document = await self.bot.shift_management.shifts.find_by_id(object_id)\n        if not document:\n            return\n        shift: ShiftItem = await self.bot.shift_management.fetch_shift(object_id)\n\n        guild: discord.Guild = self.bot.get_guild(shift.guild)\n        if guild is None:\n            return\n\n        guild_settings = await self.bot.settings.find_by_id(guild.id)\n        if not guild_settings:\n            return\n\n        shift_type = shift.type\n        custom_shift_type = None\n        break_roles = []\n\n        if shift_type != \"Default\":\n            total_shift_types = guild_settings.get(\"shift_types\", {\"types\": []})\n            for item in total_shift_types[\"types\"]:\n                if item[\"name\"] == shift_type:\n                    custom_shift_type = item\n\n        if custom_shift_type is None:\n            try:\n                channel = await guild.fetch_channel(\n                    guild_settings.get(\"shift_management\").get(\"channel\", 0)\n                )\n            except discord.HTTPException:\n                channel = None\n            nickname_prefix = guild_settings.get(\"shift_management\").get(\n                \"nickname_prefix\", None\n            )\n            assigned_roles = guild_settings.get(\"shift_management\").get(\"role\", [])\n            break_roles = guild_settings.get(\"shift_management\").get(\"break_roles\", [])\n        else:\n            try:\n                channel = await guild.fetch_channel(custom_shift_type.get(\"channel\", 0))\n            except discord.HTTPException:\n                try:\n                    channel = await guild.fetch_channel(\n                        guild_settings.get(\"shift_management\").get(\"channel\", 0)\n                    )\n                except discord.HTTPException:\n                    channel = None\n            nickname_prefix = custom_shift_type.get(\"nickname\", None)\n            assigned_roles = custom_shift_type.get(\"role\", [])\n            break_roles = custom_shift_type.get(\"break_roles\", [])\n\n        try:\n            staff_member: discord.Member = await guild.fetch_member(shift.user_id)\n        except discord.NotFound:\n            return\n\n        if not staff_member:\n            return\n        for role in assigned_roles or []:\n            discord_role: discord.Role = guild.get_role(role)\n            if discord_role is None:\n                continue\n            try:\n                await staff_member.remove_roles(discord_role, atomic=True)\n            except discord.HTTPException:\n                pass\n\n        for role in break_roles or []:\n            discord_role: discord.Role = guild.get_role(role)\n            if discord_role is None:\n                continue\n            try:\n                await staff_member.add_roles(discord_role, atomic=True)\n            except discord.HTTPException:\n                pass\n\n        if nickname_prefix is not None:\n            try:\n                await staff_member.edit(\n                    nick=f\"{(staff_member.nick or staff_member.display_name).removeprefix(nickname_prefix)}\"\n                )\n            except discord.HTTPException:\n                pass\n\n        if channel is not None:\n            await channel.send(\n                embed=discord.Embed(title=\"Break Started\", color=BLANK_COLOR)\n                .add_field(\n                    name=\"Shift Information\",\n                    value=(\n                        f\"> **Staff Member:** {staff_member.mention}\\n\"\n                        f\"> **Shift Type:** {shift_type}\\n\"\n                    ),\n                    inline=False,\n                )\n                .add_field(\n                    name=\"Other Information\",\n                    value=(\n                        f\"> **Shift Start:** <t:{int(shift.start_epoch)}>\\n\"\n                        f\"> **Started Break At:** <t:{int(shift.breaks[0].start_epoch)}>\\n\"\n                        f\"> **Total Breaks:** {len(shift.breaks)}\\n\"\n                        f\"> **Nickname:** `{shift.nickname}`\\n\"\n                    ),\n                    inline=False,\n                )\n                .set_author(\n                    name=guild.name, icon_url=guild.icon.url if guild.icon else \"\"\n                )\n                .set_thumbnail(url=staff_member.display_avatar.url)\n            )\n\n\nasync def setup(bot: commands.Bot):\n    await bot.add_cog(OnBreakStart(bot))\n"}
{"type": "source_file", "path": "erm.py", "content": "import datetime\r\nimport json\r\nimport logging\r\nimport time\r\nfrom dataclasses import MISSING\r\nfrom pkgutil import iter_modules\r\nimport re\r\nfrom collections import defaultdict\r\n\r\nfrom datamodels.MapleKeys import MapleKeys\r\nfrom datamodels.Whitelabel import Whitelabel\r\nfrom tasks.iterate_ics import iterate_ics\r\nfrom tasks.check_loa import check_loa\r\nfrom tasks.check_reminders import check_reminders\r\nfrom tasks.check_infractions import check_infractions\r\nfrom tasks.iterate_prc_logs import iterate_prc_logs\r\nfrom tasks.tempban_checks import tempban_checks\r\nfrom tasks.process_scheduled_pms import process_scheduled_pms\r\nfrom tasks.statistics_check import statistics_check\r\nfrom tasks.change_status import change_status\r\nfrom tasks.check_whitelisted_car import check_whitelisted_car\r\nfrom tasks.sync_weather import sync_weather\r\nfrom tasks.iterate_conditions import iterate_conditions\r\nfrom utils.emojis import EmojiController\r\n\r\nfrom utils.log_tracker import LogTracker\r\nfrom utils.mc_api import MCApiClient\r\nfrom utils.mongo import Document\r\n\r\ntry:\r\n    import Levenshtein\r\n    from fuzzywuzzy import fuzz, process\r\nexcept ImportError:\r\n    from fuzzywuzzy import fuzz, process\r\nimport aiohttp\r\nimport decouple\r\nimport discord.mentions\r\nimport motor.motor_asyncio\r\nimport asyncio\r\nimport pytz\r\nimport sentry_sdk\r\nfrom decouple import config\r\nfrom discord import app_commands\r\nfrom discord.ext import tasks\r\nfrom roblox import client as roblox\r\nfrom sentry_sdk import push_scope, capture_exception\r\nfrom sentry_sdk.integrations.pymongo import PyMongoIntegration\r\n\r\nfrom datamodels.CustomFlags import CustomFlags\r\nfrom datamodels.ServerKeys import ServerKeys\r\nfrom datamodels.ShiftManagement import ShiftManagement\r\nfrom datamodels.ActivityNotice import ActivityNotices\r\nfrom datamodels.Analytics import Analytics\r\nfrom datamodels.Consent import Consent\r\nfrom datamodels.CustomCommands import CustomCommands\r\nfrom datamodels.Errors import Errors\r\nfrom datamodels.FiveMLinks import FiveMLinks\r\nfrom datamodels.LinkStrings import LinkStrings\r\nfrom datamodels.PunishmentTypes import PunishmentTypes\r\nfrom datamodels.Reminders import Reminders\r\nfrom datamodels.Settings import Settings\r\nfrom datamodels.APITokens import APITokens\r\nfrom datamodels.StaffConnections import StaffConnections\r\nfrom datamodels.Views import Views\r\nfrom datamodels.Actions import Actions\r\nfrom datamodels.Warnings import Warnings\r\nfrom datamodels.ProhibitedUseKeys import ProhibitedUseKeys\r\nfrom datamodels.PendingOAuth2 import PendingOAuth2\r\nfrom datamodels.OAuth2Users import OAuth2Users\r\nfrom datamodels.IntegrationCommandStorage import IntegrationCommandStorage\r\nfrom datamodels.SavedLogs import SavedLogs\r\nfrom menus import CompleteReminder, LOAMenu, RDMActions\r\nfrom utils.viewstatemanger import ViewStateManager\r\nfrom utils.bloxlink import Bloxlink\r\nfrom utils.prc_api import PRCApiClient\r\nfrom utils.prc_api import ResponseFailure\r\nfrom utils.utils import *\r\nfrom utils.constants import *\r\nimport utils.prc_api\r\n\r\n\r\nsetup = False\r\n\r\ntry:\r\n    sentry_url = config(\"SENTRY_URL\")\r\n    bloxlink_api_key = config(\"BLOXLINK_API_KEY\")\r\nexcept decouple.UndefinedValueError:\r\n    sentry_url = \"\"\r\n    bloxlink_api_key = \"\"\r\n\r\ndiscord.utils.setup_logging(level=logging.INFO)\r\n\r\nintents = discord.Intents.default()\r\nintents.message_content = True\r\nintents.members = True\r\nintents.voice_states = True\r\n\r\ncredentials_dict = {}\r\nscope = [\r\n    \"https://spreadsheets.google.com/feeds\",\r\n    \"https://www.googleapis.com/auth/spreadsheets\",\r\n    \"https://www.googleapis.com/auth/drive.file\",\r\n    \"https://www.googleapis.com/auth/drive\",\r\n]\r\n\r\n\r\nclass Bot(commands.AutoShardedBot):\r\n    def __init__(self, *args, **kwargs):\r\n        super().__init__(*args, **kwargs)\r\n        self.setup_status: bool = False\r\n\r\n    async def close(self):\r\n        for session in self.external_http_sessions:\r\n            if session is not None and session.closed is False:\r\n                await session.close()\r\n        await super().close()\r\n\r\n    async def is_owner(self, user: discord.User):\r\n        # Only developers of the bot on the team should have\r\n        # full access to Jishaku commands. Hard-coded\r\n        # IDs are a security vulnerability.\r\n\r\n        # Else fall back to the original\r\n        if user.id == 1165311055728226444:\r\n            return True\r\n\r\n        if environment != \"CUSTOM\":\r\n            return await super().is_owner(user)\r\n        else:\r\n            return False\r\n\r\n    async def setup_hook(self) -> None:\r\n        self.external_http_sessions: list[aiohttp.ClientSession] = []\r\n        self.view_state_manager: ViewStateManager = ViewStateManager()\r\n\r\n        global setup\r\n        if not self.setup_status:\r\n            # await bot.load_extension('utils.routes')\r\n            logging.info(\r\n                \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━���━━━━━━\\n\\n{} is online!\".format(\r\n                    self.user.name\r\n                )\r\n            )\r\n            self.mongo = motor.motor_asyncio.AsyncIOMotorClient(str(mongo_url))\r\n            if environment == \"DEVELOPMENT\":\r\n                self.db = self.mongo[\"erm\"]\r\n            elif environment == \"PRODUCTION\":\r\n                self.db = self.mongo[\"erm\"]\r\n            elif environment == \"ALPHA\":\r\n                self.db = self.mongo[\"alpha\"]\r\n            elif environment == \"CUSTOM\":\r\n                self.db = self.mongo[\"erm\"]\r\n            else:\r\n                raise Exception(\"Invalid environment\")\r\n\r\n            self.panel_db = self.mongo[\"UserIdentity\"]\r\n            self.priority_settings = Document(self.panel_db, \"PrioritySettings\")\r\n            self.staff_requests = Document(self.panel_db, \"StaffRequests\")\r\n\r\n            self.start_time = time.time()\r\n\r\n            self.log_tracker = LogTracker(self)\r\n            self.scheduled_pm_queue = asyncio.Queue()\r\n            self.pm_counter = {}\r\n            self.team_restrictions_infractions = (\r\n                {}\r\n            )  # Guild ID => [ { Username: Count } ]\r\n\r\n            self.shift_management = ShiftManagement(self.db, \"shift_management\")\r\n            self.errors = Errors(self.db, \"errors\")\r\n            self.loas = ActivityNotices(self.db, \"leave_of_absences\")\r\n            self.reminders = Reminders(self.db, \"reminders\")\r\n            self.custom_commands = CustomCommands(self.db, \"custom_commands\")\r\n            self.analytics = Analytics(self.db, \"analytics\")\r\n            self.punishment_types = PunishmentTypes(self.db, \"punishment_types\")\r\n            self.custom_flags = CustomFlags(self.db, \"custom_flags\")\r\n            self.views = Views(self.db, \"views\")\r\n            self.api_tokens = APITokens(self.db, \"api_tokens\")\r\n            self.link_strings = LinkStrings(self.db, \"link_strings\")\r\n            self.fivem_links = FiveMLinks(self.db, \"fivem_links\")\r\n            self.consent = Consent(self.db, \"consent\")\r\n            self.punishments = Warnings(self)\r\n            self.settings = Settings(self.db, \"settings\")\r\n            self.server_keys = ServerKeys(self.db, \"server_keys\")\r\n\r\n            self.maple_county = self.mongo[\"MapleCounty\"]\r\n            self.mc_keys = MapleKeys(self.maple_county, \"Auth\")\r\n\r\n            self.staff_connections = StaffConnections(self.db, \"staff_connections\")\r\n            self.ics = IntegrationCommandStorage(self.db, \"logged_command_data\")\r\n            self.actions = Actions(self.db, \"actions\")\r\n            self.prohibited = ProhibitedUseKeys(self.db, \"prohibited_keys\")\r\n            self.saved_logs = SavedLogs(self.db, \"saved_logs\")\r\n            self.whitelabel = Whitelabel(self.mongo[\"ERMProcessing\"], \"Instances\")\r\n\r\n            self.pending_oauth2 = PendingOAuth2(self.db, \"pending_oauth2\")\r\n            self.oauth2_users = OAuth2Users(self.db, \"oauth2\")\r\n\r\n            self.roblox = roblox.Client()\r\n            self.prc_api = PRCApiClient(\r\n                self,\r\n                base_url=config(\r\n                    \"PRC_API_URL\", default=\"https://api.policeroleplay.community/v1\"\r\n                ),\r\n                api_key=config(\"PRC_API_KEY\", default=\"default_api_key\"),\r\n            )\r\n            self.mc_api = MCApiClient(\r\n                self, base_url=config(\"MC_API_URL\"), api_key=config(\"MC_API_KEY\")\r\n            )\r\n            self.bloxlink = Bloxlink(self, config(\"BLOXLINK_API_KEY\"))\r\n\r\n            Extensions = [m.name for m in iter_modules([\"cogs\"], prefix=\"cogs.\")]\r\n            Events = [m.name for m in iter_modules([\"events\"], prefix=\"events.\")]\r\n            BETA_EXT = [\"cogs.StaffConduct\"]\r\n            EXTERNAL_EXT = [\"utils.api\"]\r\n            [Extensions.append(i) for i in EXTERNAL_EXT]\r\n\r\n            # used for checking whether this is WL!\r\n            self.environment = environment\r\n            self.emoji_controller = EmojiController(self)\r\n\r\n            await self.emoji_controller.prefetch_emojis()\r\n\r\n            for extension in Extensions:\r\n                try:\r\n                    if extension not in BETA_EXT:\r\n                        await self.load_extension(extension)\r\n                        logging.info(f\"Loaded {extension}\")\r\n                    elif environment == \"DEVELOPMENT\" or environment == \"ALPHA\":\r\n                        await self.load_extension(extension)\r\n                        logging.info(f\"Loaded {extension}\")\r\n                except Exception as e:\r\n                    logging.error(f\"Failed to load extension {extension}.\", exc_info=e)\r\n\r\n            for extension in Events:\r\n                try:\r\n                    await self.load_extension(extension)\r\n                    logging.info(f\"Loaded {extension}\")\r\n                except Exception as e:\r\n                    logging.error(f\"Failed to load extension {extension}.\", exc_info=e)\r\n\r\n            bot.error_list = []\r\n            logging.info(\"Connected to MongoDB!\")\r\n\r\n            # await bot.load_extension(\"jishaku\")\r\n            await bot.load_extension(\"utils.hot_reload\")\r\n            # await bot.load_extension('utils.server')\r\n\r\n            if not bot.is_synced:  # check if slash commands have been synced\r\n                bot.tree.copy_global_to(guild=discord.Object(id=987798554972143728))\r\n            if environment == \"DEVELOPMENT\":\r\n                pass\r\n                # await bot.tree.sync(guild=discord.Object(id=987798554972143728))\r\n            elif environment == \"CUSTOM\":\r\n                await self.tree.sync()\r\n                # Prevent auto syncing\r\n                # await bot.tree.sync()\r\n                # guild specific: leave blank if global (global registration can take 1-24 hours)\r\n            bot.is_synced = True\r\n\r\n            # we do this so the bot can get a cache of things before we spam discord with fetches\r\n            asyncio.create_task(self.start_tasks())\r\n\r\n            async for document in self.views.db.find({}):\r\n                if document[\"view_type\"] == \"LOAMenu\":\r\n                    for index, item in enumerate(document[\"args\"]):\r\n                        if item == \"SELF\":\r\n                            document[\"args\"][index] = self\r\n                    loa_id = document[\"args\"][3]\r\n                    if isinstance(loa_id, dict):\r\n                        loa_expiry = loa_id[\"expiry\"]\r\n                        if loa_expiry < datetime.datetime.now().timestamp():\r\n                            await self.views.delete_by_id(document[\"_id\"])\r\n                            continue\r\n                    self.add_view(\r\n                        LOAMenu(*document[\"args\"]), message_id=document[\"message_id\"]\r\n                    )\r\n            self.setup_status = True\r\n\r\n    async def start_tasks(self):\r\n        logging.info(\"Starting tasks after 10 minute delay...\")\r\n        # await asyncio.sleep(600)  # 10 mins\r\n        check_reminders.start(bot)\r\n        check_loa.start(bot)\r\n        iterate_ics.start(bot)\r\n        # GDPR.start()\r\n        iterate_prc_logs.start(bot)\r\n        # statistics_check.start(bot)\r\n        tempban_checks.start(bot)\r\n        check_whitelisted_car.start(bot)\r\n        if self.environment != \"CUSTOM\":\r\n            change_status.start(bot)\r\n        process_scheduled_pms.start(bot)\r\n        sync_weather.start(bot)\r\n        iterate_conditions.start(bot)\r\n        check_infractions.start(bot)\r\n        logging.info(\"All tasks are now running!\")\r\n\r\n\r\nif config(\"ENVIRONMENT\") == \"CUSTOM\":\r\n    Bot.__bases__ = (commands.Bot,)\r\n\r\nbot = Bot(\r\n    command_prefix=get_prefix,\r\n    case_insensitive=True,\r\n    intents=intents,\r\n    help_command=None,\r\n    allowed_mentions=discord.AllowedMentions(\r\n        replied_user=False, everyone=False, roles=False\r\n    ),\r\n)\r\nbot.debug_servers = [987798554972143728]\r\nbot.is_synced = False\r\nbot.shift_management_disabled = False\r\nbot.punishments_disabled = False\r\nbot.bloxlink_api_key = bloxlink_api_key\r\nenvironment = config(\"ENVIRONMENT\", default=\"DEVELOPMENT\")\r\ninternal_command_storage = {}\r\n\r\n\r\ndef running():\r\n    if bot:\r\n        if bot._ready != MISSING:\r\n            return 1\r\n        else:\r\n            return -1\r\n    else:\r\n        return -1\r\n\r\n\r\n@bot.before_invoke\r\nasync def AutoDefer(ctx: commands.Context):\r\n    if (\r\n        environment == \"CUSTOM\"\r\n        and config(\"CUSTOM_GUILD_ID\", default=None) != 0\r\n        and not getattr(ctx.bot, \"whitelist_disabled\", False)\r\n    ):\r\n        if ctx.guild.id != int(config(\"CUSTOM_GUILD_ID\")):\r\n            if ctx.interaction:\r\n                await ctx.interaction.response.send_message(\r\n                    embed=discord.Embed(\r\n                        title=\"Not Permitted\",\r\n                        description=\"This bot is not permitted to be used in this server. You can change this in the **Whitelabel Bot Dashboard**.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    ephemeral=True,\r\n                )\r\n                raise Exception(f\"Guild not permitted to use this bot: {ctx.guild.id}\")\r\n\r\n    guild_id = ctx.guild.id\r\n    doc = await bot.whitelabel.db.find_one({\"GuildID\": guild_id})\r\n    if doc:\r\n        # must be a whitelabel instance. are we the whitelabel instance?\r\n        if environment == \"CUSTOM\" and int(config(\"CUSTOM_GUILD_ID\")) == guild_id:\r\n            pass  # we are the whitelabel instance, we're fine.\r\n        else:\r\n            # we aren't the whitelabel instance!\r\n            if ctx.interaction:\r\n                await ctx.interaction.response.send_message(\r\n                    embed=discord.Embed(\r\n                        title=\"Not Permitted\",\r\n                        description=\"There is a whitelabel bot already in this server.\",\r\n                        color=BLANK_COLOR,\r\n                    ),\r\n                    ephemeral=True,\r\n                )\r\n            raise Exception(\"Whitelabel bot already in use\")\r\n\r\n    internal_command_storage[ctx] = datetime.datetime.now(tz=pytz.UTC).timestamp()\r\n    if ctx.command:\r\n        if ctx.command.extras.get(\"ephemeral\") is True:\r\n            if ctx.interaction:\r\n                return await ctx.defer(ephemeral=True)\r\n        if ctx.command.extras.get(\"ignoreDefer\") is True:\r\n            return\r\n        await ctx.defer()\r\n\r\n\r\n@bot.after_invoke\r\nasync def loggingCommandExecution(ctx: commands.Context):\r\n    if ctx in internal_command_storage:\r\n        command_name = ctx.command.qualified_name\r\n\r\n        duration = float(\r\n            datetime.datetime.now(tz=pytz.UTC).timestamp()\r\n            - internal_command_storage[ctx]\r\n        )\r\n        logging.info(\r\n            f\"Command {command_name} was run by {ctx.author.name} ({ctx.author.id}) and lasted {duration} seconds\"\r\n        )\r\n        shard_info = (\r\n            f\"Shard ID ::: {ctx.guild.shard_id}\"\r\n            if ctx.guild\r\n            else \"Shard ID ::: -1, Direct Messages\"\r\n        )\r\n        logging.info(shard_info)\r\n    else:\r\n        logging.info(\r\n            \"Command could not be found in internal context storage. Please report.\"\r\n        )\r\n    del internal_command_storage[ctx]\r\n\r\n\r\n@bot.event\r\nasync def on_message(\r\n    message,\r\n):  # DO NOT COG\r\n\r\n    if environment == \"CUSTOM\" and not message.guild:\r\n        return await bot.process_commands(message)\r\n\r\n    if (\r\n        environment == \"CUSTOM\"\r\n        and config(\"CUSTOM_GUILD_ID\", default=None) != 0\r\n        and not getattr(bot, \"whitelist_disabled\", False)\r\n    ):\r\n        if message.guild.id != int(config(\"CUSTOM_GUILD_ID\")):\r\n            ctx = await bot.get_context(message)\r\n            if ctx.command:\r\n                if \"jishaku\" in ctx.command.full_parent_name:\r\n                    await bot.process_commands(message)\r\n                    return\r\n                await message.reply(\r\n                    embed=discord.Embed(\r\n                        title=\"Not Permitted\",\r\n                        description=\"This bot is not permitted to be used in this server. You can change this in the **Whitelabel Bot Dashboard**.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                return\r\n\r\n    filter_map = [\r\n        int(item[\"GuildID\"] or 0)\r\n        async for item in bot.whitelabel.db.find({})\r\n    ]\r\n\r\n    if message.guild.id in filter_map and environment == \"PRODUCTION\":\r\n        return # handle ERM responses to prefix commands\r\n\r\n    await bot.process_commands(message)\r\n\r\n\r\nclient = roblox.Client()\r\n\r\n\r\nasync def staff_check(bot_obj, guild, member):\r\n    guild_settings = await bot_obj.settings.find_by_id(guild.id)\r\n    if guild_settings:\r\n        if \"role\" in guild_settings[\"staff_management\"].keys():\r\n            if guild_settings[\"staff_management\"][\"role\"] != \"\":\r\n                if isinstance(guild_settings[\"staff_management\"][\"role\"], list):\r\n                    for role in guild_settings[\"staff_management\"][\"role\"]:\r\n                        if role in [role.id for role in member.roles]:\r\n                            return True\r\n                elif isinstance(guild_settings[\"staff_management\"][\"role\"], int):\r\n                    if guild_settings[\"staff_management\"][\"role\"] in [\r\n                        role.id for role in member.roles\r\n                    ]:\r\n                        return True\r\n    if member.guild_permissions.manage_messages:\r\n        return True\r\n    return False\r\n\r\n\r\nasync def management_check(bot_obj, guild, member):\r\n    guild_settings = await bot_obj.settings.find_by_id(guild.id)\r\n    if guild_settings:\r\n        if \"management_role\" in guild_settings[\"staff_management\"].keys():\r\n            if guild_settings[\"staff_management\"][\"management_role\"] != \"\":\r\n                if isinstance(\r\n                    guild_settings[\"staff_management\"][\"management_role\"], list\r\n                ):\r\n                    for role in guild_settings[\"staff_management\"][\"management_role\"]:\r\n                        if role in [role.id for role in member.roles]:\r\n                            return True\r\n                elif isinstance(\r\n                    guild_settings[\"staff_management\"][\"management_role\"], int\r\n                ):\r\n                    if guild_settings[\"staff_management\"][\"management_role\"] in [\r\n                        role.id for role in member.roles\r\n                    ]:\r\n                        return True\r\n    if member.guild_permissions.manage_guild:\r\n        return True\r\n    return False\r\n\r\n\r\nasync def admin_check(bot_obj, guild, member):\r\n    guild_settings = await bot_obj.settings.find_by_id(guild.id)\r\n    if guild_settings:\r\n        if \"admin_role\" in guild_settings[\"staff_management\"].keys():\r\n            if guild_settings[\"staff_management\"][\"admin_role\"] != \"\":\r\n                if isinstance(guild_settings[\"staff_management\"][\"admin_role\"], list):\r\n                    for role in guild_settings[\"staff_management\"][\"admin_role\"]:\r\n                        if role in [role.id for role in member.roles]:\r\n                            return True\r\n                elif isinstance(guild_settings[\"staff_management\"][\"admin_role\"], int):\r\n                    if guild_settings[\"staff_management\"][\"admin_role\"] in [\r\n                        role.id for role in member.roles\r\n                    ]:\r\n                        return True\r\n        if \"management_role\" in guild_settings[\"staff_management\"].keys():\r\n            if guild_settings[\"staff_management\"][\"management_role\"] != \"\":\r\n                if isinstance(\r\n                    guild_settings[\"staff_management\"][\"management_role\"], list\r\n                ):\r\n                    for role in guild_settings[\"staff_management\"][\"management_role\"]:\r\n                        if role in [role.id for role in member.roles]:\r\n                            return True\r\n                elif isinstance(\r\n                    guild_settings[\"staff_management\"][\"management_role\"], int\r\n                ):\r\n                    if guild_settings[\"staff_management\"][\"management_role\"] in [\r\n                        role.id for role in member.roles\r\n                    ]:\r\n                        return True\r\n    if member.guild_permissions.administrator:\r\n        return True\r\n    return False\r\n\r\n\r\nasync def staff_predicate(ctx):\r\n    if ctx.guild is None:\r\n        return True\r\n    else:\r\n        return await staff_check(ctx.bot, ctx.guild, ctx.author)\r\n\r\n\r\ndef is_staff():\r\n    return commands.check(staff_predicate)\r\n\r\n\r\nasync def admin_predicate(ctx):\r\n    if ctx.guild is None:\r\n        return True\r\n    else:\r\n        return await admin_check(ctx.bot, ctx.guild, ctx.author)\r\n\r\n\r\ndef is_admin():\r\n    return commands.check(admin_predicate)\r\n\r\n\r\nasync def management_predicate(ctx):\r\n    if ctx.guild is None:\r\n        return True\r\n    else:\r\n        return await management_check(ctx.bot, ctx.guild, ctx.author)\r\n\r\n\r\ndef is_management():\r\n    return commands.check(management_predicate)\r\n\r\n\r\nasync def check_privacy(bot: Bot, guild: int, setting: str):\r\n    privacySettings = await bot.privacy.find_by_id(guild)\r\n    if not privacySettings:\r\n        return True\r\n    if not setting in privacySettings.keys():\r\n        return True\r\n    return privacySettings[setting]\r\n\r\n\r\nasync def warning_json_to_mongo(jsonName: str, guildId: int):\r\n    with open(f\"{jsonName}\", \"r\") as f:\r\n        logging.info(f)\r\n        f = json.load(f)\r\n\r\n    logging.info(f)\r\n\r\n    for key, value in f.items():\r\n        structure = {\"_id\": key.lower(), \"warnings\": []}\r\n        logging.info([key, value])\r\n        logging.info(key.lower())\r\n\r\n        if await bot.warnings.find_by_id(key.lower()):\r\n            data = await bot.warnings.find_by_id(key.lower())\r\n            for item in data[\"warnings\"]:\r\n                structure[\"warnings\"].append(item)\r\n\r\n        for item in value:\r\n            item.pop(\"ID\", None)\r\n            item[\"id\"] = next(generator)\r\n            item[\"Guild\"] = guildId\r\n            structure[\"warnings\"].append(item)\r\n\r\n        logging.info(structure)\r\n\r\n        if await bot.warnings.find_by_id(key.lower()) == None:\r\n            await bot.warnings.insert(structure)\r\n        else:\r\n            await bot.warnings.update(structure)\r\n\r\n\r\nbot.erm_team = {\r\n    \"i_imikey\": \"Bot Developer\",\r\n    \"mbrinkley\": \"First Community Manager - Removed\",\r\n    \"theoneandonly_5567\": \"Executive Manager\",\r\n    \"royalcrests\": \"Website Developer & Asset Designer\",\r\n    \"1friendlydoge\": \"Data Scientist - a friendly doge\",\r\n}\r\n\r\nbot.warning_json_to_mongo = warning_json_to_mongo\r\n\r\n# include environment variables\r\nif environment == \"PRODUCTION\":\r\n    bot_token = config(\"PRODUCTION_BOT_TOKEN\")\r\n    logging.info(\"Using production token...\")\r\nelif environment == \"DEVELOPMENT\":\r\n    try:\r\n        bot_token = config(\"DEVELOPMENT_BOT_TOKEN\")\r\n    except decouple.UndefinedValueError:\r\n        bot_token = \"\"\r\n    logging.info(\"Using development token...\")\r\nelif environment == \"ALPHA\":\r\n    try:\r\n        bot_token = config(\"ALPHA_BOT_TOKEN\")\r\n    except decouple.UndefinedValueError:\r\n        bot_token = \"\"\r\n    logging.info(\"Using ERM V4 Alpha token...\")\r\nelif environment == \"CUSTOM\":\r\n    bot_token = config(\"CUSTOM_BOT_TOKEN\")\r\n    logging.info(\"Using custom bot token...\")\r\nelse:\r\n    raise Exception(\"Invalid environment\")\r\ntry:\r\n    mongo_url = config(\"MONGO_URL\", default=None)\r\nexcept decouple.UndefinedValueError:\r\n    mongo_url = \"\"\r\n\r\n\r\nintents = discord.Intents.default()\r\nintents.message_content = True\r\nintents.members = True\r\nintents.voice_states = True\r\n\r\nscope = [\r\n    \"https://spreadsheets.google.com/feeds\",\r\n    \"https://www.googleapis.com/auth/spreadsheets\",\r\n    \"https://www.googleapis.com/auth/drive.file\",\r\n    \"https://www.googleapis.com/auth/drive\",\r\n]\r\n\r\ncredentials_dict = {\r\n    \"type\": config(\"TYPE\", default=\"\"),\r\n    \"project_id\": config(\"PROJECT_ID\", default=\"\"),\r\n    \"private_key_id\": config(\"PRIVATE_KEY_ID\", default=\"\"),\r\n    \"private_key\": config(\"PRIVATE_KEY\", default=\"\").replace(\"\\\\n\", \"\\n\"),\r\n    \"client_email\": config(\"CLIENT_EMAIL\", default=\"\"),\r\n    \"client_id\": config(\"CLIENT_ID\", default=\"\"),\r\n    \"auth_uri\": config(\"AUTH_URI\", default=\"\"),\r\n    \"token_uri\": config(\"TOKEN_URI\", default=\"\"),\r\n    \"auth_provider_x509_cert_url\": config(\"AUTH_PROVIDER_X509_CERT_URL\", default=\"\"),\r\n    \"client_x509_cert_url\": config(\"CLIENT_X509_CERT_URL\", default=\"\"),\r\n}\r\n\r\n\r\ndef run():\r\n    sentry_sdk.init(\r\n        dsn=sentry_url,\r\n        traces_sample_rate=1.0,\r\n        integrations=[PyMongoIntegration()],\r\n        _experiments={\r\n            \"profiles_sample_rate\": 1.0,\r\n        },\r\n    )\r\n\r\n    try:\r\n        bot.run(bot_token)\r\n    except Exception as e:\r\n        raise e  # sentry got ratelimited guys\r\n\r\n        # with sentry_sdk.isolation_scope() as scope:\r\n        #     scope.level = \"error\"\r\n        #     capture_exception(e)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    run()\r\n"}
{"type": "source_file", "path": "datamodels/Views.py", "content": "from discord.ext import commands\r\nimport discord\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass Views(Document):\r\n    pass\r\n"}
{"type": "source_file", "path": "datamodels/Whitelabel.py", "content": "from discord.ext import commands\nimport discord\nfrom utils.mongo import Document\n\n\nclass Whitelabel(Document):\n    pass\n"}
{"type": "source_file", "path": "datamodels/Warnings.py", "content": "import typing\r\nfrom copy import copy\r\n\r\nimport aiohttp\r\nimport pymongo.operations\r\nfrom bson import ObjectId\r\nfrom decouple import config\r\nfrom discord.ext import commands\r\nimport discord\r\n\r\nfrom utils.utils import generator\r\nfrom utils.mongo import Document\r\n\r\n\r\nclass WarningItem:\r\n    id: str\r\n    username: str\r\n    user_id: int\r\n    warning_type: str\r\n    reason: str\r\n    moderator_name: str\r\n    moderator_id: int\r\n    guild_id: int\r\n    time_epoch: int\r\n    until_epoch: typing.Optional[int]\r\n    snowflake: int\r\n\r\n    def __init__(self, **kwargs):\r\n        for key, value in kwargs.items():\r\n            setattr(self, key, value)\r\n\r\n    def __getitem__(self, item):\r\n        legacy_correspondents = {\r\n            \"_id\": \"id\",\r\n            \"userid\": \"user_id\",\r\n            \"type\": \"warning_type\",\r\n            \"moderator\": \"moderator_name\",\r\n            \"moderatorid\": \"moderator_id\",\r\n            \"guild\": \"guild_id\",\r\n            \"epoch\": \"time_epoch\",\r\n            \"untilepoch\": \"until_epoch\",\r\n        }\r\n        if legacy_correspondents.get(item.lower()) is not None:\r\n            item = legacy_correspondents[item.lower()]\r\n        return getattr(self, item.lower())\r\n\r\n\r\nclass Warnings(Document):\r\n    \"\"\"\r\n    Also known as the punishment module, this is used for intermediary methods for the Warnings database <-> ERM.\r\n    \"\"\"\r\n\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n        super().__init__(bot.db, \"punishments\")\r\n        self.recovery = Document(bot.db, \"recovery\")\r\n\r\n    async def get_warnings(self, user: int, guild: int) -> list[WarningItem]:\r\n        \"\"\"\r\n        Gets the warnings for a user in a guild.\r\n        \"\"\"\r\n        return [\r\n            WarningItem(\r\n                id=i[\"_id\"],\r\n                snowflake=i[\"Snowflake\"],\r\n                username=i[\"Username\"],\r\n                user_id=i[\"UserID\"],\r\n                warning_type=i[\"Type\"],\r\n                reason=i[\"Reason\"],\r\n                moderator_name=i[\"Moderator\"],\r\n                moderator_id=i[\"ModeratorID\"],\r\n                guild_id=i[\"Guild\"],\r\n                time_epoch=i[\"Epoch\"],\r\n                until_epoch=None if i.get(\"UntilEpoch\") == 0 else i[\"UntilEpoch\"],\r\n            )\r\n            async for i in self.db.find({\"Guild\": guild, \"UserID\": user})\r\n        ]\r\n\r\n    async def fetch_warning(self, warning_id: str) -> WarningItem | None:\r\n        \"\"\"\r\n        Fetches a warning by its ID.\r\n        \"\"\"\r\n        i = await self.db.find_one({\"_id\": ObjectId(warning_id)})\r\n        if i is None:\r\n            return None\r\n        return WarningItem(\r\n            id=i[\"_id\"],\r\n            snowflake=i[\"Snowflake\"],\r\n            username=i[\"Username\"],\r\n            user_id=i[\"UserID\"],\r\n            warning_type=i[\"Type\"],\r\n            reason=i[\"Reason\"],\r\n            moderator_name=i[\"Moderator\"],\r\n            moderator_id=i[\"ModeratorID\"],\r\n            guild_id=i[\"Guild\"],\r\n            time_epoch=i[\"Epoch\"],\r\n            until_epoch=None if i.get(\"UntilEpoch\") == 0 else i[\"UntilEpoch\"],\r\n        )\r\n\r\n    async def get_warning(self, warning_id: str) -> dict:\r\n        \"\"\"\r\n        Gets a warning by its ID.\r\n        \"\"\"\r\n        return await self.db.find_one({\"_id\": ObjectId(warning_id)})\r\n\r\n    async def remove_warning(self, warning_id: str):\r\n        \"\"\"\r\n        Removes a warning by its ID.\r\n        \"\"\"\r\n        await self.db.delete_one({\"_id\": ObjectId(warning_id)})\r\n\r\n    async def get_warning_by_snowflake(self, snowflake: int) -> dict:\r\n        \"\"\"\r\n        Gets a warning by its ID.\r\n        \"\"\"\r\n        return await self.db.find_one({\"Snowflake\": snowflake})\r\n\r\n    async def get_global_warnings(self, user: int) -> list[dict]:\r\n        \"\"\"\r\n        Gets the warnings for a user globally.\r\n        \"\"\"\r\n        return [i async for i in self.db.find({\"UserID\": user})]\r\n\r\n    async def get_guild_bolos(self, guild: int) -> list[dict]:\r\n        \"\"\"\r\n        Gets the BOLOs for a guild.\r\n        \"\"\"\r\n        return [\r\n            i\r\n            async for i in self.db.find(\r\n                {\"Guild\": guild, \"Type\": {\"$in\": [\"BOLO\", \"Bolo\"]}}\r\n            )\r\n        ]\r\n\r\n    async def insert_warning(\r\n        self,\r\n        staff_id: int,\r\n        staff_name: str,\r\n        user_id: int,\r\n        user_name: str,\r\n        guild_id: int,\r\n        reason: str,\r\n        moderation_type: str,\r\n        time_epoch: int,\r\n        until_epoch: int | None = None,\r\n    ) -> ObjectId | ValueError:\r\n        \"\"\"\r\n        Inserts a warning into the database.\r\n        {\r\n          \"_id\": 123456789012345678,\r\n          \"Username\": \"1friendlydoge\",\r\n          \"UserID\": 123456789012345678,\r\n          \"Type\": \"Warning\",\r\n          \"Reason\": \"Nerd\",\r\n          \"Moderator\": \"Noah\",\r\n          \"ModeratorID\": 123456789012345678,\r\n          \"Guild\": 12345678910111213,\r\n          \"Epoch\": 706969420,\r\n          \"UntilEpoch\": 706969420\r\n        }\r\n        \"\"\"\r\n        if all([until_epoch is None, moderation_type == \"Temporary Ban\"]):\r\n            return ValueError(\"Epoch must be provided for temporary bans.\")\r\n\r\n        if any(\r\n            not i\r\n            for i in [\r\n                staff_id,\r\n                staff_name,\r\n                user_id,\r\n                user_name,\r\n                guild_id,\r\n                reason,\r\n                moderation_type,\r\n            ]\r\n        ):\r\n            return ValueError(\"All arguments must be provided.\")\r\n\r\n        identifier = ObjectId()\r\n\r\n        await self.db.insert_one(\r\n            {\r\n                \"_id\": identifier,\r\n                \"Snowflake\": next(generator),\r\n                \"Username\": user_name,\r\n                \"UserID\": user_id,\r\n                \"Type\": moderation_type,\r\n                \"Reason\": reason,\r\n                \"Moderator\": staff_name,\r\n                \"ModeratorID\": staff_id,\r\n                \"Guild\": guild_id,\r\n                \"Epoch\": int(time_epoch),\r\n                \"UntilEpoch\": int(until_epoch if until_epoch is not None else 0),\r\n            }\r\n        )\r\n\r\n        try:\r\n            url_var = config(\"BASE_API_URL\")\r\n            panel_url_var = config(\"PANEL_API_URL\")\r\n            if url_var not in [\"\", None]:\r\n                async with aiohttp.ClientSession() as session:\r\n                    async with session.get(\r\n                        f\"{url_var}/Internal/SyncCreatePunishment/{identifier}\",\r\n                        headers={\"Authorization\": config(\"INTERNAL_API_AUTH\")},\r\n                    ):\r\n                        pass\r\n            if panel_url_var not in [\"\", None]:\r\n                async with aiohttp.ClientSession() as session:\r\n                    async with session.get(\r\n                        f\"{panel_url_var}/{guild_id}/SyncCreatePunishment?ID={identifier}\",\r\n                        headers={\"Authorization\": config(\"INTERNAL_API_AUTH\")},\r\n                    ):\r\n                        pass\r\n        except:\r\n            pass\r\n\r\n        return identifier\r\n\r\n    async def find_warning_by_spec(\r\n        self,\r\n        guild_id: int,\r\n        identifier: str | ObjectId | None = None,\r\n        snowflake: int | None = None,\r\n        warning_type: str | None = None,\r\n        moderator_id: int | None = None,\r\n        user_id: int | None = None,\r\n    ):\r\n        \"\"\"\r\n        Removes a warning from the database by a particular specification. Useful for removing many warnings at one time.\r\n        \"\"\"\r\n        if all(\r\n            [\r\n                identifier is None,\r\n                warning_type is None,\r\n                moderator_id is None,\r\n                user_id is None,\r\n                snowflake is None,\r\n            ]\r\n        ):\r\n            return ValueError(\"At least one argument must be provided.\")\r\n\r\n        if snowflake is not None and all(\r\n            [\r\n                warning_type is None,\r\n                moderator_id is None,\r\n                user_id is None,\r\n                identifier is None,\r\n            ]\r\n        ):\r\n            return await self.db.find_one({\"Snowflake\": snowflake})\r\n\r\n        if identifier is not None and all(\r\n            [\r\n                warning_type is None,\r\n                moderator_id is None,\r\n                user_id is None,\r\n                snowflake is None,\r\n            ]\r\n        ):\r\n            return await self.db.find_one({\"_id\": ObjectId(identifier)})\r\n\r\n        map = {\r\n            \"Snowflake\": identifier,\r\n            \"Type\": warning_type,\r\n            \"ModeratorID\": moderator_id,\r\n            \"UserID\": user_id,\r\n            \"Guild\": guild_id,\r\n        }\r\n\r\n        for i, v in copy(map).items():\r\n            if v is None:\r\n                del map[i]\r\n\r\n        return await self.db.find_one(map)\r\n\r\n    def find_warnings_by_spec(\r\n        self,\r\n        guild_id: int,\r\n        identifier: int | None = None,\r\n        snowflake: int | None = None,\r\n        warning_type: str | None = None,\r\n        moderator_id: int | None = None,\r\n        user_id: int | None = None,\r\n        bolo: bool = False,\r\n    ):\r\n        \"\"\"\r\n        Finds a warnings by a specification.\r\n        \"\"\"\r\n        if all(\r\n            [\r\n                identifier is None,\r\n                warning_type is None,\r\n                moderator_id is None,\r\n                user_id is None,\r\n                bolo is False,\r\n            ]\r\n        ):\r\n            return ValueError(\"At least one argument must be provided.\")\r\n\r\n        if snowflake is not None and all(\r\n            [\r\n                warning_type is None,\r\n                moderator_id is None,\r\n                user_id is None,\r\n                identifier is None,\r\n            ]\r\n        ):\r\n            return self.db.find({\"Snowflake\": snowflake})\r\n\r\n        if identifier is not None and all(\r\n            [\r\n                warning_type is None,\r\n                moderator_id is None,\r\n                user_id is None,\r\n                snowflake is None,\r\n            ]\r\n        ):\r\n            return self.db.find({\"_id\": identifier})\r\n\r\n        if bolo and not warning_type:\r\n            warning_type = {\"$regex\": \"bolo\", \"$options\": \"i\"}\r\n\r\n        map = {\r\n            \"Snowflake\": identifier,\r\n            \"Type\": warning_type,\r\n            \"ModeratorID\": moderator_id,\r\n            \"UserID\": user_id,\r\n            \"Guild\": guild_id,\r\n        }\r\n\r\n        for i, v in copy(map).items():\r\n            if v is None:\r\n                del map[i]\r\n\r\n        return self.db.find(map)\r\n\r\n    async def remove_warnings_by_spec(\r\n        self,\r\n        guild_id: int,\r\n        identifier: int | None = None,\r\n        warning_type: str | None = None,\r\n        moderator_id: int | None = None,\r\n        user_id: int | None = None,\r\n    ):\r\n        \"\"\"\r\n        Removes a warning from the database by a particular specification. Useful for removing many warnings at one time.\r\n        \"\"\"\r\n        # # print(\"!!!!\")\r\n        if all(\r\n            [\r\n                identifier is None,\r\n                warning_type is None,\r\n                moderator_id is None,\r\n                user_id is None,\r\n                guild_id is None,\r\n            ]\r\n        ):\r\n            return ValueError(\"At least one argument must be provided.\")\r\n\r\n        if identifier is not None and all(\r\n            [\r\n                warning_type is None,\r\n                moderator_id is None,\r\n                user_id is None,\r\n                guild_id is None,\r\n            ]\r\n        ):\r\n            return await self.db.delete_many({\"Snowflake\": identifier})\r\n\r\n        map = {\r\n            \"Snowflake\": identifier,\r\n            \"Type\": warning_type,\r\n            \"ModeratorID\": moderator_id,\r\n            \"UserID\": user_id,\r\n            \"Guild\": guild_id,\r\n        }\r\n\r\n        for i, v in copy(map).items():\r\n            if v is None:\r\n                del map[i]\r\n\r\n        storage = []\r\n        async for i in self.db.find(map):\r\n            storage.append(i)\r\n            await self.db.delete_one({\"_id\": i[\"_id\"]})\r\n\r\n        bulk_writes = []\r\n        for i in storage:\r\n            l = copy(i)\r\n            del l[\"_id\"]\r\n            bulk_writes.append(\r\n                pymongo.operations.UpdateOne(\r\n                    {\"_id\": i[\"_id\"]}, {\"$set\": l}, upsert=True\r\n                )\r\n            )\r\n\r\n        await self.recovery.db.bulk_write(bulk_writes)\r\n        # await self.recovery.db.insert_many(storage)\r\n\r\n    async def remove_warning_by_snowflake(\r\n        self, identifier: int, guild_id: int | None = None\r\n    ):\r\n        \"\"\"\r\n        Removes a warning from the database by its snowflake.\r\n        \"\"\"\r\n\r\n        selected_item = await self.db.find_one({\"Snowflake\": identifier})\r\n        if selected_item[\"Guild\"] == (guild_id or selected_item[\"Guild\"]):\r\n            try:\r\n                url_var = config(\"BASE_API_URL\")\r\n                panel_url_var = config(\"PANEL_API_URL\")\r\n                if url_var not in [\"\", None]:\r\n                    async with aiohttp.ClientSession() as session:\r\n                        async with session.get(\r\n                            f\"{url_var}/Internal/SyncDeletePunishment/{selected_item['_id']}\",\r\n                            headers={\"Authorization\": config(\"INTERNAL_API_AUTH\")},\r\n                        ):\r\n                            pass\r\n                if panel_url_var not in [\"\", None]:\r\n                    async with aiohttp.ClientSession() as session:\r\n                        async with session.get(\r\n                            f\"{panel_url_var}/{guild_id}/SyncDeletePunishment?ID={identifier}\",\r\n                            headers={\"Authorization\": config(\"INTERNAL_API_AUTH\")},\r\n                        ):\r\n                            pass\r\n            except ValueError:\r\n                pass\r\n            return await self.db.delete_one({\"Snowflake\": identifier})\r\n        else:\r\n            return ValueError(\"Warning does not exist.\")\r\n\r\n    async def count_warnings(\r\n        self,\r\n        identifier: int | None = None,\r\n        warning_type: str | None = None,\r\n        moderator_id: int | None = None,\r\n        user_id: int | None = None,\r\n        guild_id: int | None = None,\r\n    ):\r\n        \"\"\"\r\n        Counts the warnings in the database.\r\n        \"\"\"\r\n\r\n        map = {\r\n            \"Snowflake\": identifier,\r\n            \"Type\": warning_type,\r\n            \"ModeratorID\": moderator_id,\r\n            \"UserID\": user_id,\r\n            \"Guild\": guild_id,\r\n        }\r\n\r\n        for i, v in copy(map).items():\r\n            if v is None:\r\n                del map[i]\r\n\r\n        return await self.db.count_documents(map)\r\n"}
{"type": "source_file", "path": "events/on_command_error.py", "content": "import datetime\r\nimport logging\r\n\r\nimport asyncio\r\nimport discord\r\nimport httpcore\r\nimport pytz\r\nimport roblox\r\nfrom discord.ext import commands\r\nfrom discord.ui import Button, View\r\nfrom discord.ext.commands import HybridCommandError\r\nfrom sentry_sdk import capture_exception, push_scope\r\nfrom aiohttp import ClientConnectorSSLError\r\n\r\nfrom utils.constants import BLANK_COLOR, RED_COLOR\r\nfrom utils.utils import error_gen, GuildCheckFailure\r\nfrom utils.prc_api import ServerLinkNotFound, ResponseFailure\r\n\r\n\r\nclass OnCommandError(commands.Cog):\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n\r\n    @commands.Cog.listener(\"on_command_error\")\r\n    async def on_command_error(self, ctx, error):\r\n        do_not_send = getattr(ctx, \"dnr\", False)\r\n        bot = self.bot\r\n        error_id = error_gen()\r\n\r\n        if isinstance(error, commands.CommandInvokeError):\r\n            error = error.original\r\n            return await self.on_command_error(ctx, error)\r\n\r\n        if isinstance(error, commands.CommandOnCooldown):\r\n            return (\r\n                await ctx.reply(\r\n                    embed=discord.Embed(\r\n                        title=\"Cooldown\",\r\n                        description=f\"This command is on cooldown. Please try again in {error.retry_after:.2f} seconds.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                if not do_not_send\r\n                else None\r\n            )\r\n\r\n        if (\r\n            \"Invalid Webhook Token\" in str(error)\r\n            or \"Unknown Message\" in str(error)\r\n            or \"Unknown message\" in str(error)\r\n            or isinstance(error, asyncio.TimeoutError)\r\n        ):\r\n            return\r\n\r\n        if isinstance(\r\n            error, HybridCommandError\r\n        ) and \"RemoteProtocolError: Server disconnected without sending a response.\" in str(\r\n            error\r\n        ):\r\n            return (\r\n                await ctx.reply(\r\n                    embed=discord.Embed(\r\n                        title=\"Connection Error\",\r\n                        description=\"The server disconnected without sending a response. Your issue will be fixed if you try again.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                if not do_not_send\r\n                else None\r\n            )\r\n\r\n        if isinstance(error, httpcore.ConnectTimeout):\r\n            return (\r\n                await ctx.reply(\r\n                    embed=discord.Embed(\r\n                        title=\"HTTP Error\",\r\n                        description=\"I could not connect to the ROBLOX API. Please try again later.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                if not do_not_send\r\n                else None\r\n            )\r\n\r\n        if isinstance(error, ResponseFailure):\r\n            (\r\n                await ctx.reply(\r\n                    embed=discord.Embed(\r\n                        title=f\"PRC Response Failure ({error.status_code})\",\r\n                        description=(\r\n                            \"Your server seems to be offline. If this is incorrect, PRC's API may be down.\"\r\n                            if error.status_code == 422\r\n                            else \"There seems to be issues with the PRC API. Stand by and wait a few minutes before trying again.\"\r\n                        ),\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                if not do_not_send\r\n                else None\r\n            )\r\n\r\n            with push_scope() as scope:\r\n                scope.set_tag(\"error_id\", error_id)\r\n                scope.set_tag(\"guild_id\", ctx.guild.id)\r\n                scope.set_tag(\"user_id\", ctx.author.id)\r\n                if isinstance(ctx.bot, commands.AutoShardedBot):\r\n                    scope.set_tag(\"shard_id\", ctx.guild.shard_id)\r\n                scope.set_level(\"error\")\r\n                await bot.errors.insert(\r\n                    {\r\n                        \"_id\": error_id,\r\n                        \"error\": str(error),\r\n                        \"time\": datetime.datetime.now(tz=pytz.UTC).strftime(\r\n                            \"%m/%d/%Y, %H:%M:%S\"\r\n                        ),\r\n                        \"channel\": ctx.channel.id,\r\n                        \"guild\": ctx.guild.id,\r\n                    }\r\n                )\r\n\r\n                capture_exception(error)\r\n            return\r\n\r\n        if isinstance(error, commands.BadArgument):\r\n            return (\r\n                await ctx.reply(\r\n                    embed=discord.Embed(\r\n                        title=\"Invalid Argument\",\r\n                        description=\"You provided an invalid argument to this command.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                if not do_not_send\r\n                else None\r\n            )\r\n\r\n        if \"Invalid username\" in str(error):\r\n            return (\r\n                await ctx.reply(\r\n                    embed=discord.Embed(\r\n                        title=\"Player not found\",\r\n                        description=\"I could not find a ROBLOX player with that corresponding username.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                if not do_not_send\r\n                else None\r\n            )\r\n\r\n        if isinstance(error, roblox.UserNotFound):\r\n            return (\r\n                await ctx.reply(\r\n                    embed=discord.Embed(\r\n                        title=\"Player not found\",\r\n                        description=\"I could not find a ROBLOX player with that corresponding username.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                if not do_not_send\r\n                else None\r\n            )\r\n\r\n        if isinstance(error, discord.Forbidden):\r\n            if \"Cannot send messages to this user\" in str(error):\r\n                return\r\n\r\n        if isinstance(error, commands.NoPrivateMessage):\r\n            embed = discord.Embed(\r\n                title=\"Direct Messages\",\r\n                description=f\"I would love to talk to you more personally, \"\r\n                f\"but I can't do that in DMs. Please use me in a server.\",\r\n                color=BLANK_COLOR,\r\n            )\r\n            if not do_not_send:\r\n                await ctx.send(embed=embed)\r\n            return\r\n\r\n        if isinstance(error, GuildCheckFailure):\r\n            return (\r\n                await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Not Setup\",\r\n                        description=\"This command requires for the bot to be configured before this command is ran. Please use `/setup` first.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                if not do_not_send\r\n                else None\r\n            )\r\n\r\n        if isinstance(error, commands.CommandNotFound):\r\n            return\r\n\r\n        if isinstance(error, ServerLinkNotFound):\r\n            aliases = {\r\n                \"mc\": \"Maple County\",\r\n                \"erlc\": \"ER:LC\",\r\n            }\r\n            if error.code == 9999 and not do_not_send:\r\n                await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=\"API Versioning Change\",\r\n                        description=\"Due to a new change with PRC's Private Server API, in order to use API features, the private server has to be __fully restarted__. If there is no one in-game, a player has to join the game for the API features to work effectively.\\n\\nIf the server is currently active, when all users leave the game and when one person joins back, the API features will begin working again.\\n\\nSorry for the inconvenience,\\nERM Team\",\r\n                        color=BLANK_COLOR,\r\n                    ).set_footer(text=f\"{error.code} | {error_id}\")\r\n                )\r\n            elif error.code in [2000, 2001, 2002, 401] and not do_not_send:\r\n                await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Not Linked\",\r\n                        description=f\"This server does not have an {aliases[error.platform]} server connected. \\nTo link your {aliases[error.platform]} server, run **/{error.platform} link**.\",\r\n                        color=BLANK_COLOR,\r\n                    ).set_footer(text=error_id)\r\n                )\r\n            else:\r\n                if not do_not_send:\r\n                    await ctx.send(\r\n                        embed=discord.Embed(\r\n                            title=\"API Fatal Error\",\r\n                            description=f\"The {aliases[error.platform]} API encountered a fatal error which has resulted in us being unable to fetch {aliases[error.platform]} data.\",\r\n                            color=BLANK_COLOR,\r\n                        ).set_footer(text=f\"{error.code} | {error_id}\")\r\n                    )\r\n            with push_scope() as scope:\r\n                scope.set_tag(\"error_id\", error_id)\r\n                scope.set_tag(\"guild_id\", ctx.guild.id)\r\n                scope.set_tag(\"user_id\", ctx.author.id)\r\n                if isinstance(ctx.bot, commands.AutoShardedBot):\r\n                    scope.set_tag(\"shard_id\", ctx.guild.shard_id)\r\n                scope.set_level(\"error\")\r\n                await bot.errors.insert(\r\n                    {\r\n                        \"_id\": error_id,\r\n                        \"error\": str(error),\r\n                        \"time\": datetime.datetime.now(tz=pytz.UTC).strftime(\r\n                            \"%m/%d/%Y, %H:%M:%S\"\r\n                        ),\r\n                        \"channel\": ctx.channel.id,\r\n                        \"guild\": ctx.guild.id,\r\n                    }\r\n                )\r\n\r\n                capture_exception(error)\r\n            return\r\n\r\n        if isinstance(error, commands.CheckFailure):\r\n            return (\r\n                await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Not Permitted\",\r\n                        description=\"You are not permitted to run this command.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                if not do_not_send\r\n                else None\r\n            )\r\n        if isinstance(error, OverflowError):\r\n            return (\r\n                await ctx.reply(\r\n                    embed=discord.Embed(\r\n                        title=\"Overflow Error\",\r\n                        description=\"A user has inputted an arbitrary time amount of time into ERM and we were unable to display the requested data because of this. Please find the source of this, and remove the excess amount of time.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                if not do_not_send\r\n                else None\r\n            )\r\n        if isinstance(error, commands.MissingRequiredArgument):\r\n            return (\r\n                await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=\"Missing Argument\",\r\n                        description=\"You are missing a required argument to run this command.\",\r\n                        color=BLANK_COLOR,\r\n                    )\r\n                )\r\n                if not do_not_send\r\n                else None\r\n            )\r\n\r\n        if not isinstance(\r\n            error,\r\n            (\r\n                commands.CommandNotFound,\r\n                commands.CheckFailure,\r\n                commands.MissingRequiredArgument,\r\n                discord.Forbidden,\r\n            ),\r\n        ):\r\n            if not do_not_send:\r\n                await ctx.send(\r\n                    embed=discord.Embed(\r\n                        title=f\"{self.bot.emoji_controller.get_emoji('error')} Command Failure\",\r\n                        description=\"The command you were attempting to run failed.\\nContact ERM Support for assistance.\",\r\n                        color=RED_COLOR,\r\n                    ).add_field(name=\"Error ID\", value=f\"`{error_id}`\", inline=False),\r\n                    view=View().add_item(\r\n                        Button(\r\n                            label=\"Contact ERM Support\",\r\n                            style=discord.ButtonStyle.link,\r\n                            url=\"https://discord.gg/FAC629TzBy\",\r\n                        )\r\n                    ),\r\n                )\r\n\r\n            with push_scope() as scope:\r\n                scope.set_tag(\"error_id\", error_id)\r\n                scope.set_tag(\"guild_id\", ctx.guild.id)\r\n                scope.set_tag(\"user_id\", ctx.author.id)\r\n                if isinstance(ctx.bot, commands.AutoShardedBot):\r\n                    scope.set_tag(\"shard_id\", ctx.guild.shard_id)\r\n                scope.set_level(\"error\")\r\n                await bot.errors.insert(\r\n                    {\r\n                        \"_id\": error_id,\r\n                        \"error\": str(error),\r\n                        \"time\": datetime.datetime.now(tz=pytz.UTC).strftime(\r\n                            \"%m/%d/%Y, %H:%M:%S\"\r\n                        ),\r\n                        \"channel\": ctx.channel.id,\r\n                        \"guild\": ctx.guild.id,\r\n                    }\r\n                )\r\n\r\n                capture_exception(error)\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(OnCommandError(bot))\r\n"}
{"type": "source_file", "path": "datamodels/StaffConnections.py", "content": "import typing\n\nfrom bson import ObjectId\nfrom utils.mongo import Document\nfrom utils.basedataclass import BaseDataClass\n\n\nclass StaffConnection(BaseDataClass):\n    roblox_id: int\n    discord_id: int\n    document_id: ObjectId\n\n    def to_document(self) -> dict:\n        return (\n            {\"discord_id\": self.discord_id, \"roblox_id\": self.roblox_id}\n            if not self.document_id\n            else {\n                \"_id\": self.document_id,\n                \"discord_id\": self.discord_id,\n                \"roblox_id\": self.roblox_id,\n            }\n        )\n\n\nclass StaffConnections(Document):\n    async def fetch_by_spec(\n        self,\n        roblox_id: typing.Optional[int] = None,\n        discord_id: typing.Optional[int] = None,\n        document_id: typing.Optional[typing.Union[ObjectId, str]] = None,\n    ) -> StaffConnection | None:\n\n        attributes = {}\n\n        for key, value in {\n            \"roblox_id\": roblox_id,\n            \"discord_id\": discord_id,\n            \"_id\": document_id,\n        }.items():\n            if value is not None:\n                attributes.__setitem__(key, value)\n\n        document = await self.db.find_one(attributes)\n        if not document:\n            return None\n\n        return StaffConnection(\n            roblox_id=document[\"roblox_id\"],\n            discord_id=document[\"discord_id\"],\n            document_id=document[\"_id\"],\n        )\n\n    async def insert_connection(self, connection: StaffConnection):\n        return await self.db.insert_one(connection.to_document())\n"}
{"type": "source_file", "path": "events/on_break_end.py", "content": "import discord\nfrom bson import ObjectId\nfrom discord.ext import commands\nfrom datamodels.ShiftManagement import ShiftItem\nfrom utils.constants import BLANK_COLOR\n\n\nclass OnBreakEnd(commands.Cog):\n    def __init__(self, bot: commands.Bot):\n        self.bot = bot\n\n    @commands.Cog.listener()\n    async def on_break_end(self, object_id: ObjectId):\n\n        document = await self.bot.shift_management.shifts.find_by_id(object_id)\n        if not document:\n            return\n        shift: ShiftItem = await self.bot.shift_management.fetch_shift(object_id)\n\n        guild: discord.Guild = self.bot.get_guild(shift.guild)\n        if guild is None:\n            return\n\n        guild_settings = await self.bot.settings.find_by_id(guild.id)\n        if not guild_settings:\n            return\n\n        shift_type = shift.type\n        custom_shift_type = None\n        break_roles = []\n        if shift_type != \"Default\":\n            total_shift_types = guild_settings.get(\"shift_types\", {\"types\": []})\n            for item in total_shift_types[\"types\"]:\n                if item[\"name\"] == shift_type:\n                    custom_shift_type = item\n\n        if custom_shift_type is None:\n            try:\n                channel = await guild.fetch_channel(\n                    guild_settings.get(\"shift_management\").get(\"channel\", 0)\n                )\n            except discord.HTTPException:\n                channel = None\n            nickname_prefix = guild_settings.get(\"shift_management\").get(\n                \"nickname_prefix\", None\n            )\n            assigned_roles = guild_settings.get(\"shift_management\").get(\"role\", [])\n            break_roles = guild_settings.get(\"shift_management\").get(\"break_roles\", [])\n        else:\n            try:\n                channel = await guild.fetch_channel(custom_shift_type.get(\"channel\", 0))\n            except discord.HTTPException:\n                try:\n                    channel = await guild.fetch_channel(\n                        guild_settings.get(\"shift_management\").get(\"channel\", 0)\n                    )\n                except discord.HTTPException:\n                    channel = None\n            nickname_prefix = custom_shift_type.get(\"nickname\", None)\n            assigned_roles = custom_shift_type.get(\"role\", [])\n            break_roles = custom_shift_type.get(\"break_roles\", [])\n\n        try:\n            staff_member: discord.Member = await guild.fetch_member(shift.user_id)\n        except discord.NotFound:\n            return\n\n        if not staff_member:\n            return\n        for role in assigned_roles or []:\n            discord_role: discord.Role = guild.get_role(role)\n            if discord_role is None:\n                continue\n            try:\n                await staff_member.add_roles(discord_role, atomic=True)\n            except discord.HTTPException:\n                pass\n\n        for role in break_roles or []:\n            discord_role: discord.Role = guild.get_role(role)\n            if discord_role is None:\n                continue\n            try:\n                await staff_member.remove_roles(discord_role, atomic=True)\n            except discord.HTTPException:\n                pass\n\n        if nickname_prefix is not None:\n            try:\n                await staff_member.edit(\n                    nick=f\"{nickname_prefix}{(staff_member.nick or staff_member.display_name)}\"\n                )\n            except discord.HTTPException:\n                pass\n\n        if channel is not None:\n            await channel.send(\n                embed=discord.Embed(title=\"Break Ended\", color=BLANK_COLOR)\n                .add_field(\n                    name=\"Shift Information\",\n                    value=(\n                        f\"> **Staff Member:** {staff_member.mention}\\n\"\n                        f\"> **Shift Type:** {shift_type}\\n\"\n                    ),\n                    inline=False,\n                )\n                .add_field(\n                    name=\"Other Information\",\n                    value=(\n                        f\"> **Shift Start:** <t:{int(shift.start_epoch)}>\\n\"\n                        f\"> **Ended Break At:** <t:{int(shift.breaks[0].end_epoch)}>\\n\"\n                        f\"> **Total Breaks:** {len(shift.breaks)}\\n\"\n                        f\"> **Nickname:** `{shift.nickname}`\\n\"\n                    ),\n                    inline=False,\n                )\n                .set_author(\n                    name=guild.name, icon_url=guild.icon.url if guild.icon else \"\"\n                )\n                .set_thumbnail(url=staff_member.display_avatar.url)\n            )\n\n\nasync def setup(bot: commands.Bot):\n    await bot.add_cog(OnBreakEnd(bot))\n"}
{"type": "source_file", "path": "events/on_error.py", "content": "import datetime\r\nimport logging\r\n\r\nimport discord\r\nimport pytz\r\nfrom discord.ext import commands\r\nfrom sentry_sdk import capture_exception, push_scope\r\n\r\nfrom utils.utils import error_gen\r\n\r\n\r\nclass OnError(commands.Cog):\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n\r\n    @commands.Cog.listener(\"on_error\")\r\n    async def on_error(self, error):\r\n        bot = self.bot\r\n        error_id = error_gen()\r\n\r\n        if isinstance(error, discord.Forbidden):\r\n            if \"Cannot send messages to this user\" in str(error):\r\n                return\r\n\r\n        if isinstance(error, commands.CommandNotFound):\r\n            return\r\n        if isinstance(error, commands.CheckFailure):\r\n            return\r\n        if isinstance(error, commands.MissingRequiredArgument):\r\n            return\r\n        # # print(error)\r\n        # # print(str(error))\r\n        with push_scope() as scope:\r\n            scope.set_tag(\"error_id\", error_id)\r\n            scope.level = \"error\"\r\n            await bot.errors.insert(\r\n                {\r\n                    \"_id\": error_id,\r\n                    \"error\": str(error),\r\n                    \"time\": datetime.datetime.now(tz=pytz.UTC).strftime(\r\n                        \"%m/%d/%Y, %H:%M:%S\"\r\n                    ),\r\n                }\r\n            )\r\n\r\n            capture_exception(error)\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(OnError(bot))\r\n"}
{"type": "source_file", "path": "events/on_guild_join.py", "content": "import logging\r\n\r\nimport discord\r\nfrom discord.ext import commands\r\n\r\n\r\nclass OnGuildJoin(commands.Cog):\r\n    def __init__(self, bot):\r\n        self.bot = bot\r\n\r\n    @commands.Cog.listener(\"on_guild_join\")\r\n    async def on_guild_join(self, guild: discord.Guild):\r\n        bot = self.bot\r\n        if self.bot.environment != \"CUSTOM\":\r\n            channel = bot.get_channel(1033021466381398086)\r\n            embed = discord.Embed(title=guild.name, color=0xED4348)\r\n            embed.description = f\"\"\"\r\n            > **Server Membercount:** {guild.member_count}\r\n            > **Bots:** {len([member for member in guild.members if member.bot == True])}\r\n            > **Guild Count:** {len(bot.guilds)}\r\n            > **Guild Owner:** <@{guild.owner.id}> `({guild.owner.id})`    \r\n            \"\"\"\r\n            try:\r\n                embed.set_footer(icon_url=guild.icon, text=f\"Guild ID: {guild.id}\")\r\n                embed.set_thumbnail(url=guild.icon)\r\n            except AttributeError:\r\n                pass\r\n            await channel.send(embed=embed)\r\n            logging.info(\"Server has been sent welcome sequence.\")\r\n\r\n\r\nasync def setup(bot):\r\n    await bot.add_cog(OnGuildJoin(bot))\r\n"}
{"type": "source_file", "path": "events/on_infraction_create.py", "content": "import datetime\nimport logging\nimport discord\nfrom discord.ext import commands\nfrom utils.constants import BLANK_COLOR\n\nlogger = logging.getLogger(__name__)\n\n\nclass OnInfractionCreate(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n\n    def replace_variables(self, data, variables):\n        if isinstance(data, str):\n            result = data\n            for key, value in variables.items():\n                result = result.replace(key, value)\n            return result\n        elif isinstance(data, dict):\n            result = {}\n            for key, value in data.items():\n                if key == \"color\" and isinstance(value, (int, float)):\n                    result[key] = int(value)\n                elif isinstance(value, (dict, list)):\n                    result[key] = self.replace_variables(value, variables)\n                elif isinstance(value, str):\n                    result[key] = self.replace_variables(value, variables)\n                else:\n                    result[key] = value\n            return result\n        elif isinstance(data, list):\n            return [self.replace_variables(item, variables) for item in data]\n        return data\n\n    @commands.Cog.listener()\n    async def on_infraction_create(self, infraction_doc):\n        try:\n            guild = self.bot.get_guild(infraction_doc[\"guild_id\"])\n            if not guild:\n                return\n\n            member = guild.get_member(infraction_doc[\"user_id\"])\n            if not member:\n                try:\n                    member = await guild.fetch_member(infraction_doc[\"user_id\"])\n                except:\n                    return\n\n            settings = await self.bot.settings.find_by_id(guild.id)\n            if not settings or \"infractions\" not in settings:\n                return\n\n            infraction_config = next(\n                (\n                    inf\n                    for inf in settings[\"infractions\"][\"infractions\"]\n                    if inf[\"name\"] == infraction_doc[\"type\"]\n                ),\n                None,\n            )\n            if not infraction_config:\n                return\n\n            # Set up variables for replacements\n            issuer = None\n            if issuer_id := infraction_doc.get(\"issuer_id\"):\n                try:\n                    issuer = guild.get_member(issuer_id) or await guild.fetch_member(\n                        issuer_id\n                    )\n                except:\n                    pass\n\n            variables = {\n                \"{user}\": member.mention,\n                \"{user.name}\": member.name,\n                \"{user.id}\": str(member.id),\n                \"{user.tag}\": str(member),\n                \"{guild}\": guild.name,\n                \"{guild.id}\": str(guild.id),\n                \"{guild.icon}\": str(guild.icon.url) if guild.icon else \"\",\n                \"{reason}\": infraction_doc[\"reason\"],\n                \"{type}\": infraction_doc[\"type\"],\n                \"{issuer}\": f\"<@{infraction_doc.get('issuer_id', '0')}>\",\n                \"{issuer.id}\": str(infraction_doc.get(\"issuer_id\", \"0\")),\n                \"{issuer.name}\": issuer.name if issuer else \"Unknown\",\n                \"{timestamp}\": f\"<t:{int(datetime.datetime.now().timestamp())}:F>\",\n                \"{timestamp.short}\": f\"<t:{int(datetime.datetime.now().timestamp())}:f>\",\n                \"{timestamp.relative}\": f\"<t:{int(datetime.datetime.now().timestamp())}:R>\",\n                \"{escalated}\": (\n                    \"Yes\" if infraction_doc.get(\"escalated\", False) else \"No\"\n                ),\n                \"{count}\": str(\n                    await self.bot.db.infractions.count_documents(\n                        {\n                            \"user_id\": member.id,\n                            \"guild_id\": guild.id,\n                            \"type\": infraction_doc[\"type\"],\n                        }\n                    )\n                ),\n                \"{user.username}\": infraction_doc.get(\"username\", member.name),\n                \"{issuer.username}\": infraction_doc.get(\"issuer_username\", \"Unknown\"),\n            }\n\n            # Process role changes\n            roles_added = []\n            roles_removed = []\n\n            if infraction_config.get(\"role_changes\"):\n                # Handle role additions\n                if infraction_config[\"role_changes\"].get(\"add\"):\n                    await self._process_role_add(\n                        infraction_config[\"role_changes\"][\"add\"],\n                        guild,\n                        member,\n                        infraction_doc,\n                        roles_added,\n                    )\n\n                if infraction_config[\"role_changes\"].get(\"remove\"):\n                    await self._process_role_remove(\n                        infraction_config[\"role_changes\"][\"remove\"],\n                        guild,\n                        member,\n                        infraction_doc,\n                        roles_removed,\n                    )\n\n            if roles_added or roles_removed:\n                await self._update_role_changes(\n                    infraction_doc, roles_added, roles_removed\n                )\n\n            if infraction_config.get(\"notifications\"):\n                await self._process_notifications(\n                    infraction_config[\"notifications\"], guild, member, variables\n                )\n\n            await self._process_additional_actions(infraction_config, guild, member)\n\n        except Exception as e:\n            logger.error(f\"Error processing infraction: {e}\")\n\n    async def _process_role_add(\n        self, add_config, guild, member, infraction_doc, roles_added\n    ):\n        roles_to_add = []\n        for role_id in add_config.get(\"roles\", []):\n            try:\n                role = guild.get_role(int(role_id))\n                if role and role not in member.roles:\n                    roles_to_add.append(role)\n                    roles_added.append(role.id)\n            except Exception as e:\n                logger.error(f\"Failed to process add role {role_id}: {e}\")\n\n        if roles_to_add:\n            try:\n                await member.add_roles(\n                    *roles_to_add, reason=f\"Infraction {infraction_doc['type']}\"\n                )\n                if add_config.get(\"temporary\") and add_config.get(\"duration\"):\n                    infraction_doc[\"temp_roles_added\"] = [r.id for r in roles_to_add]\n                    infraction_doc[\"temp_roles_added_expiry\"] = (\n                        datetime.datetime.now().timestamp() + add_config[\"duration\"]\n                    )\n            except Exception as e:\n                logger.error(f\"Failed to add roles: {e}\")\n\n    async def _process_role_remove(\n        self, remove_config, guild, member, infraction_doc, roles_removed\n    ):\n        roles_to_remove = []\n        for role_id in remove_config.get(\"roles\", []):\n            try:\n                role = guild.get_role(int(role_id))\n                if role and role in member.roles:\n                    roles_to_remove.append(role)\n                    roles_removed.append(role.id)\n            except Exception as e:\n                logger.error(f\"Failed to process remove role {role_id}: {e}\")\n\n        if roles_to_remove:\n            try:\n                await member.remove_roles(\n                    *roles_to_remove, reason=f\"Infraction {infraction_doc['type']}\"\n                )\n                if remove_config.get(\"temporary\") and remove_config.get(\"duration\"):\n                    infraction_doc[\"temp_roles_removed\"] = [\n                        r.id for r in roles_to_remove\n                    ]\n                    infraction_doc[\"temp_roles_removed_expiry\"] = (\n                        datetime.datetime.now().timestamp() + remove_config[\"duration\"]\n                    )\n            except Exception as e:\n                logger.error(f\"Failed to remove roles: {e}\")\n\n    async def _process_notifications(self, notifications, guild, member, variables):\n        if notifications.get(\"dm\", {}).get(\"enabled\"):\n            dm_config = notifications[\"dm\"]\n            content = self.replace_variables(dm_config.get(\"content\", \"\"), variables)\n            if dm_config.get(\"embed\"):\n                try:\n                    embed = discord.Embed.from_dict(\n                        self.replace_variables(dm_config[\"embed\"], variables)\n                    )\n                    await member.send(content=content or None, embed=embed)\n                except Exception as e:\n                    logger.error(f\"Failed to send DM notification: {e}\")\n\n        if notifications.get(\"public\", {}).get(\"enabled\"):\n            public_config = notifications[\"public\"]\n            content = self.replace_variables(\n                public_config.get(\"content\", \"\"), variables\n            )\n            if public_config.get(\"embed\"):\n                try:\n                    embed = discord.Embed.from_dict(\n                        self.replace_variables(public_config[\"embed\"], variables)\n                    )\n                    if channel_id := public_config.get(\"channel_id\"):\n                        if channel := guild.get_channel(int(channel_id)):\n                            await channel.send(content=content or None, embed=embed)\n                except Exception as e:\n                    logger.error(f\"Failed to send public notification: {e}\")\n\n    async def _process_additional_actions(self, config, guild, member):\n        if config.get(\"remove_ingame_perms\", False):\n            try:\n                roblox_info = await self.bot.bloxlink.find_roblox(member.id)\n                if roblox_info and \"robloxID\" in roblox_info:\n                    roblox_id = roblox_info[\"robloxID\"]\n                    await self.bot.prc_api.run_command(guild.id, f\":unmod {roblox_id}\")\n                    await self.bot.prc_api.run_command(\n                        guild.id, f\":unadmin {roblox_id}\"\n                    )\n            except Exception as e:\n                logger.error(f\"Failed to remove in-game permissions: {e}\")\n\n        if config.get(\"end_shift\", False):\n            try:\n                current_shift = await self.bot.shift_management.get_current_shift(\n                    member, guild.id\n                )\n                if current_shift:\n                    await self.bot.shift_management.end_shift(\n                        current_shift[\"_id\"], guild.id\n                    )\n                    self.bot.dispatch(\"shift_end\", current_shift[\"_id\"])\n            except Exception as e:\n                logger.error(f\"Failed to end shift: {e}\")\n\n    async def _update_role_changes(self, infraction_doc, roles_added, roles_removed):\n        if roles_added or roles_removed:\n            update_data = {\"roles_modified\": True}\n            if roles_added:\n                update_data[\"roles_added\"] = roles_added\n            if roles_removed:\n                update_data[\"roles_removed\"] = roles_removed\n\n            try:\n                await self.bot.db.infractions.update_one(\n                    {\"_id\": infraction_doc[\"_id\"]}, {\"$set\": update_data}\n                )\n            except Exception as e:\n                logger.error(\n                    f\"Failed to update infraction document with role changes: {e}\"\n                )\n\n\nasync def setup(bot):\n    await bot.add_cog(OnInfractionCreate(bot))\n"}

{"repo_info": {"repo_name": "Building-Data-Science-Applications-with-FastAPI", "repo_owner": "PacktPublishing", "repo_url": "https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI"}}
{"type": "test_file", "path": "tests/__init__.py", "content": ""}
{"type": "test_file", "path": "tests/conftest.py", "content": "from typing import Callable, AsyncGenerator, Generator\nimport asyncio\n\nimport httpx\nimport pytest\nimport pytest_asyncio\nfrom asgi_lifespan import LifespanManager\nfrom fastapi import FastAPI\nfrom fastapi.testclient import TestClient\n\nTestClientGenerator = Callable[[FastAPI], AsyncGenerator[httpx.AsyncClient, None]]\n\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    loop = asyncio.get_event_loop()\n    yield loop\n    loop.close()\n\n\n@pytest_asyncio.fixture\nasync def client(\n    request: pytest.FixtureRequest,\n) -> AsyncGenerator[httpx.AsyncClient, None]:\n    marker = request.node.get_closest_marker(\"fastapi\")\n    if marker is None:\n        raise ValueError(\"client fixture: the marker fastapi must be provided\")\n    try:\n        app = marker.kwargs[\"app\"]\n    except KeyError:\n        raise ValueError(\n            \"client fixture: keyword argument app must be provided in the marker\"\n        )\n    if not isinstance(app, FastAPI):\n        raise ValueError(\"client fixture: app must be a FastAPI instance\")\n\n    dependency_overrides = marker.kwargs.get(\"dependency_overrides\")\n    if dependency_overrides:\n        if not isinstance(dependency_overrides, dict):\n            raise ValueError(\n                \"client fixture: dependency_overrides must be a dictionary\"\n            )\n        app.dependency_overrides = dependency_overrides\n\n    run_lifespan_events = marker.kwargs.get(\"run_lifespan_events\", True)\n    if not isinstance(run_lifespan_events, bool):\n        raise ValueError(\"client fixture: run_lifespan_events must be a bool\")\n\n    test_client_generator = httpx.AsyncClient(app=app, base_url=\"http://app.io\")\n    if run_lifespan_events:\n        async with LifespanManager(app):\n            async with test_client_generator as test_client:\n                yield test_client\n    else:\n        async with test_client_generator as test_client:\n            yield test_client\n\n\n@pytest.fixture\ndef websocket_client(\n    request: pytest.FixtureRequest,\n    event_loop: asyncio.AbstractEventLoop,\n) -> Generator[TestClient, None, None]:\n    asyncio.set_event_loop(event_loop)\n\n    marker = request.node.get_closest_marker(\"fastapi\")\n    if marker is None:\n        raise ValueError(\"client fixture: the marker fastapi must be provided\")\n    try:\n        app = marker.kwargs[\"app\"]\n    except KeyError:\n        raise ValueError(\n            \"client fixture: keyword argument app must be provided in the marker\"\n        )\n    if not isinstance(app, FastAPI):\n        raise ValueError(\"client fixture: app must be a FastAPI instance\")\n\n    dependency_overrides = marker.kwargs.get(\"dependency_overrides\")\n    if dependency_overrides:\n        if not isinstance(dependency_overrides, dict):\n            raise ValueError(\n                \"client fixture: dependency_overrides must be a dictionary\"\n            )\n        app.dependency_overrides = dependency_overrides\n\n    with TestClient(app) as test_client:\n        yield test_client\n"}
{"type": "test_file", "path": "tests/test_chapter7.py", "content": "import httpx\nimport pytest\nfrom fastapi import status\n\nfrom chapter7.chapter7_api_key_header import (\n    app as chapter7_api_key_header_app,\n    API_TOKEN as CHAPTER7_API_KEY_HEADER_API_TOKEN,\n)\nfrom chapter7.chapter7_api_key_header_dependency import (\n    app as chapter7_api_key_header_app_dependency,\n    API_TOKEN as CHAPTER7_API_KEY_HEADER_DEPENDENCY_API_TOKEN,\n)\n\n\n@pytest.mark.fastapi(app=chapter7_api_key_header_app)\n@pytest.mark.asyncio\nclass TestChapter7APIKeyHeader:\n    async def test_missing_header(self, client: httpx.AsyncClient):\n        response = await client.get(\"/protected-route\")\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    async def test_invalid_token(self, client: httpx.AsyncClient):\n        response = await client.get(\"/protected-route\", headers={\"Token\": \"Foo\"})\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    async def test_valid_token(self, client: httpx.AsyncClient):\n        response = await client.get(\n            \"/protected-route\", headers={\"Token\": CHAPTER7_API_KEY_HEADER_API_TOKEN}\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"hello\": \"world\"}\n\n\n@pytest.mark.fastapi(app=chapter7_api_key_header_app_dependency)\n@pytest.mark.asyncio\nclass TestChapter7APIKeyHeaderDependency:\n    async def test_missing_header(self, client: httpx.AsyncClient):\n        response = await client.get(\"/protected-route\")\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    async def test_invalid_token(self, client: httpx.AsyncClient):\n        response = await client.get(\"/protected-route\", headers={\"Token\": \"Foo\"})\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    async def test_valid_token(self, client: httpx.AsyncClient):\n        response = await client.get(\n            \"/protected-route\",\n            headers={\"Token\": CHAPTER7_API_KEY_HEADER_DEPENDENCY_API_TOKEN},\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"hello\": \"world\"}\n"}
{"type": "test_file", "path": "tests/test_chapter14.py", "content": "from os import path\nfrom typing import cast\n\nimport httpx\nimport pytest\nfrom fastapi import status\nfrom fastapi.testclient import TestClient\nfrom pytest_unordered import unordered\nfrom starlette.testclient import WebSocketTestSession\n\nfrom chapter14.chapter14_api import app as chapter14_api_app\nfrom chapter14.websocket_face_detection.app import (\n    app as chapter14_websocket_face_detection_app,\n)\n\nassets_folder = path.join(path.dirname(path.dirname(__file__)), \"assets\")\npeople_image_file = path.join(assets_folder, \"people.jpg\")\n\n\n@pytest.mark.fastapi(app=chapter14_api_app)\n@pytest.mark.asyncio\nclass TestChapter14API:\n    async def test_invalid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\"/face-detection\", files={})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_valid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/face-detection\", files={\"image\": open(people_image_file, \"rb\")}\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        faces = json[\"faces\"]\n        assert unordered(faces) == [[237, 92, 80, 80], [426, 75, 115, 115]]\n\n\n@pytest.mark.fastapi(app=chapter14_websocket_face_detection_app)\nclass TestChapter14WebSocketFaceDetection:\n    def test_single_detection(self, websocket_client: TestClient):\n        with websocket_client.websocket_connect(\"/face-detection\") as websocket:\n            websocket = cast(WebSocketTestSession, websocket)\n\n            with open(people_image_file, \"rb\") as image:\n                websocket.send_bytes(image.read())\n                result = websocket.receive_json()\n                faces = result[\"faces\"]\n                assert unordered(faces) == [[237, 92, 80, 80], [426, 75, 115, 115]]\n\n    def test_backpressure(self, websocket_client: TestClient):\n        QUEUE_LIMIT = 10\n        with websocket_client.websocket_connect(\"/face-detection\") as websocket:\n            websocket = cast(WebSocketTestSession, websocket)\n\n            with open(people_image_file, \"rb\") as image:\n                bytes = image.read()\n                for _ in range(QUEUE_LIMIT + 1):\n                    websocket.send_bytes(bytes)\n                for _ in range(QUEUE_LIMIT):\n                    result = websocket.receive_json()\n                    faces = result[\"faces\"]\n                    assert unordered(faces) == [[237, 92, 80, 80], [426, 75, 115, 115]]\n"}
{"type": "test_file", "path": "tests/test_chapter3_project.py", "content": "import httpx\nimport pytest\nfrom fastapi import status\n\nfrom chapter3_project.app import app\nfrom chapter3_project.models.user import User\nfrom chapter3_project.models.post import Post\nfrom chapter3_project.db import db\n\n\n@pytest.fixture(autouse=True)\ndef fill_db():\n    db.users = {\n        1: User(id=1, email=\"user1@example.com\"),\n        2: User(id=2, email=\"user2@example.com\"),\n        3: User(id=3, email=\"user3@example.com\"),\n    }\n    db.posts = {\n        1: Post(id=1, user=1, title=\"Post 1\"),\n        2: Post(id=2, user=2, title=\"Post 2\"),\n        3: Post(id=3, user=3, title=\"Post 3\"),\n    }\n\n\n@pytest.mark.fastapi(app=app)\n@pytest.mark.asyncio\nclass TestUsersRouter:\n    async def test_all(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users/\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert len(json) == 3\n\n    async def test_get_not_found(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users/10\")\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    async def test_get_found(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users/1\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"id\": 1, \"email\": \"user1@example.com\"}\n\n    async def test_create_invalid(self, client: httpx.AsyncClient):\n        payload = {\"foo\": \"bar\"}\n        response = await client.post(\"/users/\", json=payload)\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_create_valid(self, client: httpx.AsyncClient):\n        payload = {\"email\": \"user4@example.com\"}\n        response = await client.post(\"/users/\", json=payload)\n\n        assert response.status_code == status.HTTP_201_CREATED\n        json = response.json()\n        assert json == {\"id\": 4, \"email\": \"user4@example.com\"}\n        assert 4 in db.users\n\n    async def test_delete_not_found(self, client: httpx.AsyncClient):\n        response = await client.delete(\"/users/10\")\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    async def test_delete_found(self, client: httpx.AsyncClient):\n        response = await client.delete(\"/users/1\")\n\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        assert 1 not in db.users\n\n\n@pytest.mark.fastapi(app=app)\n@pytest.mark.asyncio\nclass TestPostsRouter:\n    async def test_all(self, client: httpx.AsyncClient):\n        response = await client.get(\"/posts/\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert len(json) == 3\n\n    async def test_get_not_found(self, client: httpx.AsyncClient):\n        response = await client.get(\"/posts/10\")\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    async def test_get_found(self, client: httpx.AsyncClient):\n        response = await client.get(\"/posts/1\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"id\": 1, \"user\": 1, \"title\": \"Post 1\"}\n\n    async def test_create_invalid(self, client: httpx.AsyncClient):\n        payload = {\"title\": \"Post 4\"}\n        response = await client.post(\"/posts/\", json=payload)\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_create_not_existing_user(self, client: httpx.AsyncClient):\n        payload = {\"user\": 4, \"title\": \"Post 4\"}\n        response = await client.post(\"/posts/\", json=payload)\n\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        json = response.json()\n        assert json == {\"detail\": \"User with id 4 doesn't exist.\"}\n\n    async def test_create_valid(self, client: httpx.AsyncClient):\n        payload = {\"user\": 1, \"title\": \"Post 4\"}\n        response = await client.post(\"/posts/\", json=payload)\n\n        assert response.status_code == status.HTTP_201_CREATED\n        json = response.json()\n        assert json == {\"id\": 4, \"user\": 1, \"title\": \"Post 4\"}\n        assert 4 in db.posts\n\n    async def test_delete_not_found(self, client: httpx.AsyncClient):\n        response = await client.delete(\"/posts/10\")\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    async def test_delete_found(self, client: httpx.AsyncClient):\n        response = await client.delete(\"/posts/1\")\n\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        assert 1 not in db.posts\n"}
{"type": "test_file", "path": "tests/test_chapter5.py", "content": "from typing import Optional\n\nimport httpx\nimport pytest\nfrom fastapi import status\n\nfrom chapter5.chapter5_what_is_dependency_injection_01 import (\n    app as chapter5_what_is_dependency_injection_01_app,\n)\nfrom chapter5.chapter5_function_dependency_01 import (\n    app as chapter5_function_dependency_01_app,\n)\nfrom chapter5.chapter5_function_dependency_02 import (\n    app as chapter5_function_dependency_02_app,\n)\nfrom chapter5.chapter5_function_dependency_03 import (\n    app as chapter5_function_dependency_03_app,\n)\nfrom chapter5.chapter5_class_dependency_01 import (\n    app as chapter5_class_dependency_01_app,\n)\nfrom chapter5.chapter5_class_dependency_02 import (\n    app as chapter5_class_dependency_02_app,\n)\nfrom chapter5.chapter5_path_dependency_01 import (\n    app as chapter5_path_dependency_01_app,\n)\nfrom chapter5.chapter5_router_dependency_01 import (\n    app as chapter5_router_dependency_01_app,\n)\nfrom chapter5.chapter5_router_dependency_02 import (\n    app as chapter5_router_dependency_02_app,\n)\nfrom chapter5.chapter5_global_dependency_01 import (\n    app as chapter5_global_dependency_01_app,\n)\n\n\n@pytest.mark.fastapi(app=chapter5_what_is_dependency_injection_01_app)\n@pytest.mark.asyncio\nclass TestWhatIsDependencyInjection01:\n    async def test_missing_header(self, client: httpx.AsyncClient):\n        client.headers.pop(\"User-Agent\")\n        response = await client.get(\"/\")\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_valid_header(self, client: httpx.AsyncClient):\n        response = await client.get(\"/\", headers={\"User-Agent\": \"HTTPX\"})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"user_agent\": \"HTTPX\"}\n\n\n@pytest.mark.fastapi(app=chapter5_function_dependency_01_app)\n@pytest.mark.parametrize(\"path\", [\"/items\", \"/things\"])\n@pytest.mark.asyncio\nclass TestFunctionDependency01:\n    async def test_default_pagination(self, client: httpx.AsyncClient, path: str):\n        response = await client.get(path)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"skip\": 0, \"limit\": 10}\n\n    async def test_custom_pagination(self, client: httpx.AsyncClient, path: str):\n        response = await client.get(path, params={\"skip\": 10, \"limit\": 100})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"skip\": 10, \"limit\": 100}\n\n\n@pytest.mark.fastapi(app=chapter5_function_dependency_02_app)\n@pytest.mark.parametrize(\"path\", [\"/items\", \"/things\"])\n@pytest.mark.asyncio\nclass TestFunctionDependency02:\n    async def test_default_pagination(self, client: httpx.AsyncClient, path: str):\n        response = await client.get(path)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"skip\": 0, \"limit\": 10}\n\n    async def test_invalid_skip(self, client: httpx.AsyncClient, path: str):\n        response = await client.get(path, params={\"skip\": -10})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_invalid_limit(self, client: httpx.AsyncClient, path: str):\n        response = await client.get(path, params={\"limit\": -10})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_capped_limit(self, client: httpx.AsyncClient, path: str):\n        response = await client.get(path, params={\"skip\": 10, \"limit\": 1000})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"skip\": 10, \"limit\": 100}\n\n    async def test_custom_pagination(self, client: httpx.AsyncClient, path: str):\n        response = await client.get(path, params={\"skip\": 10, \"limit\": 100})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"skip\": 10, \"limit\": 100}\n\n\n@pytest.mark.fastapi(app=chapter5_function_dependency_03_app)\n@pytest.mark.asyncio\nclass TestFunctionDependency03:\n    async def test_get_404(self, client: httpx.AsyncClient):\n        response = await client.get(\"/posts/4\")\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    async def test_get_ok(self, client: httpx.AsyncClient):\n        response = await client.get(\"/posts/1\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json[\"id\"] == 1\n\n    async def test_update_404(self, client: httpx.AsyncClient):\n        response = await client.patch(\"/posts/4\", json={})\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    async def test_update_ok(self, client: httpx.AsyncClient):\n        response = await client.patch(\"/posts/1\", json={\"title\": \"New title\"})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json[\"id\"] == 1\n        assert json[\"title\"] == \"New title\"\n\n    async def test_delete_404(self, client: httpx.AsyncClient):\n        response = await client.delete(\"/posts/4\")\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    async def test_delete_ok(self, client: httpx.AsyncClient):\n        response = await client.delete(\"/posts/1\")\n\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n\n@pytest.mark.fastapi(app=chapter5_class_dependency_01_app)\n@pytest.mark.parametrize(\"path\", [\"/items\", \"/things\"])\n@pytest.mark.asyncio\nclass TestClassDependency01:\n    async def test_default_pagination(self, client: httpx.AsyncClient, path: str):\n        response = await client.get(path)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"skip\": 0, \"limit\": 10}\n\n    async def test_invalid_skip(self, client: httpx.AsyncClient, path: str):\n        response = await client.get(path, params={\"skip\": -10})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_invalid_limit(self, client: httpx.AsyncClient, path: str):\n        response = await client.get(path, params={\"limit\": -10})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_capped_limit(self, client: httpx.AsyncClient, path: str):\n        response = await client.get(path, params={\"skip\": 10, \"limit\": 1000})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"skip\": 10, \"limit\": 50}\n\n    async def test_custom_pagination(self, client: httpx.AsyncClient, path: str):\n        response = await client.get(path, params={\"skip\": 10, \"limit\": 50})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"skip\": 10, \"limit\": 50}\n\n\n@pytest.mark.fastapi(app=chapter5_class_dependency_02_app)\n@pytest.mark.asyncio\nclass TestClassDependency02:\n    async def test_skip_limit_default_pagination(self, client: httpx.AsyncClient):\n        response = await client.get(\"/items\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"skip\": 0, \"limit\": 10}\n\n    async def test_skip_limit_invalid_skip(self, client: httpx.AsyncClient):\n        response = await client.get(\"/items\", params={\"skip\": -10})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_skip_limit_invalid_limit(self, client: httpx.AsyncClient):\n        response = await client.get(\"/items\", params={\"limit\": -10})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_skip_limit_capped_limit(self, client: httpx.AsyncClient):\n        response = await client.get(\"/items\", params={\"skip\": 10, \"limit\": 1000})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"skip\": 10, \"limit\": 50}\n\n    async def test_skip_limit_custom_pagination(self, client: httpx.AsyncClient):\n        response = await client.get(\"/items\", params={\"skip\": 10, \"limit\": 50})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"skip\": 10, \"limit\": 50}\n\n    async def test_page_size_default_pagination(self, client: httpx.AsyncClient):\n        response = await client.get(\"/things\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"page\": 1, \"size\": 10}\n\n    async def test_page_size_invalid_page(self, client: httpx.AsyncClient):\n        response = await client.get(\"/things\", params={\"page\": -10})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_page_size_invalid_size(self, client: httpx.AsyncClient):\n        response = await client.get(\"/things\", params={\"size\": -10})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_page_size_capped_limit(self, client: httpx.AsyncClient):\n        response = await client.get(\"/things\", params={\"page\": 10, \"size\": 1000})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"page\": 10, \"size\": 50}\n\n    async def test_page_size_custom_pagination(self, client: httpx.AsyncClient):\n        response = await client.get(\"/things\", params={\"page\": 10, \"size\": 50})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"page\": 10, \"size\": 50}\n\n\n@pytest.mark.fastapi(app=chapter5_path_dependency_01_app)\n@pytest.mark.asyncio\nclass TestPathDependency01:\n    @pytest.mark.parametrize(\"secret_header\", [None, \"INVALID_VALUE\"])\n    async def test_invalid_header(\n        self, client: httpx.AsyncClient, secret_header: Optional[str]\n    ):\n        headers = {}\n        if secret_header:\n            headers[\"Secret-Header\"] = secret_header\n        response = await client.get(\"/protected-route\", headers=headers)\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    async def test_valid_header(self, client: httpx.AsyncClient):\n        response = await client.get(\n            \"/protected-route\", headers={\"Secret-Header\": \"SECRET_VALUE\"}\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n\n\n@pytest.mark.fastapi(app=chapter5_router_dependency_01_app)\n@pytest.mark.parametrize(\"path\", [\"/router/route1\", \"/router/route2\"])\n@pytest.mark.asyncio\nclass TestRouterDependency01:\n    @pytest.mark.parametrize(\"secret_header\", [None, \"INVALID_VALUE\"])\n    async def test_invalid_header(\n        self, client: httpx.AsyncClient, path: str, secret_header: Optional[str]\n    ):\n        headers = {}\n        if secret_header:\n            headers[\"Secret-Header\"] = secret_header\n        response = await client.get(path, headers=headers)\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    async def test_valid_header(self, path: str, client: httpx.AsyncClient):\n        response = await client.get(path, headers={\"Secret-Header\": \"SECRET_VALUE\"})\n\n        assert response.status_code == status.HTTP_200_OK\n\n\n@pytest.mark.fastapi(app=chapter5_router_dependency_02_app)\n@pytest.mark.parametrize(\"path\", [\"/router/route1\", \"/router/route2\"])\n@pytest.mark.asyncio\nclass TestRouterDependency02:\n    @pytest.mark.parametrize(\"secret_header\", [None, \"INVALID_VALUE\"])\n    async def test_invalid_header(\n        self, client: httpx.AsyncClient, path: str, secret_header: Optional[str]\n    ):\n        headers = {}\n        if secret_header:\n            headers[\"Secret-Header\"] = secret_header\n        response = await client.get(path, headers=headers)\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    async def test_valid_header(self, path: str, client: httpx.AsyncClient):\n        response = await client.get(path, headers={\"Secret-Header\": \"SECRET_VALUE\"})\n\n        assert response.status_code == status.HTTP_200_OK\n\n\n@pytest.mark.fastapi(app=chapter5_global_dependency_01_app)\n@pytest.mark.parametrize(\"path\", [\"/route1\", \"/route2\"])\n@pytest.mark.asyncio\nclass TestGlobalDependency01:\n    @pytest.mark.parametrize(\"secret_header\", [None, \"INVALID_VALUE\"])\n    async def test_invalid_header(\n        self, client: httpx.AsyncClient, path: str, secret_header: Optional[str]\n    ):\n        headers = {}\n        if secret_header:\n            headers[\"Secret-Header\"] = secret_header\n        response = await client.get(path, headers=headers)\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    async def test_valid_header(self, path: str, client: httpx.AsyncClient):\n        response = await client.get(path, headers={\"Secret-Header\": \"SECRET_VALUE\"})\n\n        assert response.status_code == status.HTTP_200_OK\n"}
{"type": "test_file", "path": "tests/test_chapter7_cors.py", "content": "import httpx\nimport pytest\nfrom fastapi import status\n\nfrom chapter7.cors.app_without_cors import app as app_without_cors\nfrom chapter7.cors.app_with_cors import app as app_with_cors\n\n\n@pytest.mark.fastapi(app=app_without_cors)\n@pytest.mark.asyncio\nclass TestChapter7AppWithoutCORS:\n    async def test_options(self, client: httpx.AsyncClient):\n        response = await client.options(\"/\")\n\n        assert response.status_code == status.HTTP_405_METHOD_NOT_ALLOWED\n\n    async def test_get(self, client: httpx.AsyncClient):\n        response = await client.get(\"/\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"detail\": \"GET response\"}\n\n        assert \"access-control-allow-origin\" not in response.headers\n\n    async def test_post(self, client: httpx.AsyncClient):\n        response = await client.post(\"/\", json={\"hello\": \"world\"})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"detail\": \"POST response\", \"input_payload\": {\"hello\": \"world\"}}\n\n        assert \"access-control-allow-origin\" not in response.headers\n\n\n@pytest.mark.fastapi(app=app_with_cors)\n@pytest.mark.asyncio\nclass TestChapter7AppWithCORS:\n    async def test_options(self, client: httpx.AsyncClient):\n        response = await client.options(\n            \"/\",\n            headers={\n                \"Origin\": \"http://localhost:9000\",\n                \"access-control-request-method\": \"POST\",\n            },\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n\n        assert (\n            response.headers[\"access-control-allow-origin\"] == \"http://localhost:9000\"\n        )\n\n    async def test_get(self, client: httpx.AsyncClient):\n        response = await client.get(\"/\", headers={\"Origin\": \"http://localhost:9000\"})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"detail\": \"GET response\"}\n\n        assert (\n            response.headers[\"access-control-allow-origin\"] == \"http://localhost:9000\"\n        )\n\n    async def test_post(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/\", headers={\"Origin\": \"http://localhost:9000\"}, json={\"hello\": \"world\"}\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"detail\": \"POST response\", \"input_payload\": {\"hello\": \"world\"}}\n\n        assert (\n            response.headers[\"access-control-allow-origin\"] == \"http://localhost:9000\"\n        )\n"}
{"type": "test_file", "path": "tests/test_chapter13.py", "content": "from typing import List, Tuple\n\nimport httpx\nimport joblib\nimport pytest\nfrom fastapi import status\nfrom sklearn.pipeline import Pipeline\nfrom chapter13.chapter13_prediction_endpoint import (\n    app as chapter13_prediction_endpoint_app,\n)\nfrom chapter13.chapter13_caching import app as chapter13_caching_app, memory\nfrom chapter13.chapter13_async_not_async import app as chapter13_async_not_async_app\n\n\ndef test_chapter13_dump_joblib():\n    from chapter13.chapter13_dump_joblib import categories\n\n    model_file = \"newsgroups_model.joblib\"\n    loaded_model: Tuple[Pipeline, List[str]] = joblib.load(model_file)\n    model, targets = loaded_model\n\n    assert isinstance(model, Pipeline)\n    assert set(targets) == set(categories)\n\n\ndef test_chapter13_load_joblib():\n    from chapter13.chapter13_load_joblib import model, targets\n\n    assert isinstance(model, Pipeline)\n    assert set(targets) == set(\n        [\n            \"soc.religion.christian\",\n            \"talk.religion.misc\",\n            \"comp.sys.mac.hardware\",\n            \"sci.crypt\",\n        ]\n    )\n\n\n@pytest.mark.fastapi(app=chapter13_prediction_endpoint_app)\n@pytest.mark.asyncio\nclass TestChapter13PredictionEndpoint:\n    async def test_invalid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\"/prediction\", json={})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_valid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/prediction\", json={\"text\": \"computer cpu memory ram\"}\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"category\": \"comp.sys.mac.hardware\"}\n\n\n@pytest.mark.fastapi(app=chapter13_caching_app)\n@pytest.mark.asyncio\nclass TestChapter13Caching:\n    async def test_invalid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\"/prediction\", json={})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_valid_payload(self, client: httpx.AsyncClient):\n        memory.clear()\n\n        for _ in range(2):\n            response = await client.post(\n                \"/prediction\", json={\"text\": \"computer cpu memory ram\"}\n            )\n\n            assert response.status_code == status.HTTP_200_OK\n            json = response.json()\n            assert json == {\"category\": \"comp.sys.mac.hardware\"}\n\n    async def test_delete_cache(self, client: httpx.AsyncClient):\n        response = await client.delete(\"/cache\")\n\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n\n\n@pytest.mark.fastapi(app=chapter13_async_not_async_app)\n@pytest.mark.asyncio\nclass TestChapter13AsyncNotAsync:\n    @pytest.mark.parametrize(\"path\", [\"/fast\", \"/slow-async\", \"/slow-sync\"])\n    async def test_route(self, path: str, client: httpx.AsyncClient):\n        response = await client.get(path)\n        assert response.status_code == status.HTTP_200_OK\n        assert response.json() == {\"endpoint\": path[1:]}\n"}
{"type": "test_file", "path": "tests/test_chapter6_mongodb.py", "content": "import os\nfrom typing import Any, Dict, Optional\n\nimport httpx\nimport pytest\nimport pytest_asyncio\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom bson import ObjectId\nfrom fastapi import status\n\nfrom chapter6.mongodb.app import app, get_database\nfrom chapter6.mongodb.models import PostDB\n\n\nmotor_client = AsyncIOMotorClient(\n    os.getenv(\"MONGODB_CONNECTION_STRING\", \"mongodb://localhost:27017\")\n)\ndatabase_test = motor_client[\"chapter6_mongo_test\"]\ninitial_posts = [\n    PostDB(title=\"Post 1\", content=\"Content 1\"),\n    PostDB(title=\"Post 2\", content=\"Content 2\"),\n    PostDB(title=\"Post 3\", content=\"Content 3\"),\n]\nexisting_id = str(initial_posts[0].id)\nnot_existing_id = str(ObjectId())\ninvalid_id = \"aaa\"\n\n\n@pytest_asyncio.fixture(autouse=True, scope=\"module\")\nasync def initialize_database():\n    await database_test[\"posts\"].insert_many(\n        [post.dict(by_alias=True) for post in initial_posts]\n    )\n\n    yield\n\n    await motor_client.drop_database(\"chapter6_mongo_test\")\n\n\n@pytest.mark.fastapi(\n    app=app, dependency_overrides={get_database: lambda: database_test}\n)\n@pytest.mark.asyncio\nclass TestChapter6MongoDB:\n    @pytest.mark.parametrize(\n        \"skip,limit,nb_results\", [(None, None, 3), (0, 1, 1), (10, 1, 0)]\n    )\n    async def test_list_posts(\n        self,\n        client: httpx.AsyncClient,\n        skip: Optional[int],\n        limit: Optional[int],\n        nb_results: int,\n    ):\n        params = {}\n        if skip:\n            params[\"skip\"] = skip\n        if limit:\n            params[\"limit\"] = limit\n        response = await client.get(\"/posts\", params=params)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert len(json) == nb_results\n        for post in json:\n            assert \"_id\" in post\n\n    @pytest.mark.parametrize(\n        \"id,status_code\",\n        [\n            (existing_id, status.HTTP_200_OK),\n            (not_existing_id, status.HTTP_404_NOT_FOUND),\n            (invalid_id, status.HTTP_404_NOT_FOUND),\n        ],\n    )\n    async def test_get_post(self, client: httpx.AsyncClient, id: str, status_code: int):\n        response = await client.get(f\"/posts/{id}\")\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_200_OK:\n            json = response.json()\n            assert json[\"_id\"] == id\n\n    @pytest.mark.parametrize(\n        \"payload,status_code\",\n        [\n            ({\"title\": \"New post\", \"content\": \"New content\"}, status.HTTP_201_CREATED),\n            ({}, status.HTTP_422_UNPROCESSABLE_ENTITY),\n        ],\n    )\n    async def test_create_post(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any], status_code: int\n    ):\n        response = await client.post(\"/posts\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_201_CREATED:\n            json = response.json()\n            assert \"_id\" in json\n\n    @pytest.mark.parametrize(\n        \"id,payload,status_code\",\n        [\n            (existing_id, {\"title\": \"Post 1 Updated\"}, status.HTTP_200_OK),\n            (not_existing_id, {\"title\": \"Post 10 Updated\"}, status.HTTP_404_NOT_FOUND),\n            (invalid_id, {\"title\": \"Post 10 Updated\"}, status.HTTP_404_NOT_FOUND),\n        ],\n    )\n    async def test_update_post(\n        self,\n        client: httpx.AsyncClient,\n        id: str,\n        payload: Dict[str, Any],\n        status_code: int,\n    ):\n        response = await client.patch(f\"/posts/{id}\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_200_OK:\n            json = response.json()\n            for key in payload:\n                assert json[key] == payload[key]\n\n    @pytest.mark.parametrize(\n        \"id,status_code\",\n        [\n            (existing_id, status.HTTP_204_NO_CONTENT),\n            (not_existing_id, status.HTTP_404_NOT_FOUND),\n            (invalid_id, status.HTTP_404_NOT_FOUND),\n        ],\n    )\n    async def test_delete_post(\n        self, client: httpx.AsyncClient, id: str, status_code: int\n    ):\n        response = await client.delete(f\"/posts/{id}\")\n\n        assert response.status_code == status_code\n"}
{"type": "test_file", "path": "tests/test_chapter7_csrf.py", "content": "import os\nfrom datetime import datetime, timedelta\n\nimport httpx\nimport pytest\nimport pytest_asyncio\nfrom fastapi import status\nfrom tortoise import Tortoise\n\nfrom chapter7.csrf.app import app\nfrom chapter7.csrf.models import (\n    AccessToken,\n    AccessTokenTortoise,\n    UserDB,\n    UserTortoise,\n)\nfrom chapter7.csrf.password import get_password_hash\n\nDATABASE_FILE_PATH = \"chapter7_csrf.test.db\"\nDATABASE_URL = f\"sqlite://{DATABASE_FILE_PATH}\"\n\n\n@pytest_asyncio.fixture(autouse=True, scope=\"module\")\nasync def initialize_database():\n    await Tortoise.init(\n        db_url=DATABASE_URL,\n        modules={\"models\": [\"chapter7.csrf.models\"]},\n    )\n    await Tortoise.generate_schemas()\n\n    initial_users = [\n        UserDB(\n            id=1, email=\"user1@example.com\", hashed_password=get_password_hash(\"foobar\")\n        ),\n    ]\n    await UserTortoise.bulk_create(\n        (UserTortoise(**user.dict()) for user in initial_users)\n    )\n\n    initial_tokens = [\n        AccessToken(\n            access_token=\"VALID_USER1_TOKEN\",\n            user_id=1,\n            expiration_date=datetime.utcnow() + timedelta(seconds=86400),\n        ),\n        AccessToken(\n            access_token=\"EXPIRED_USER1_TOKEN\",\n            user_id=1,\n            expiration_date=datetime.utcnow() - timedelta(seconds=86400),\n        ),\n    ]\n    await AccessTokenTortoise.bulk_create(\n        (AccessTokenTortoise(**token.dict()) for token in initial_tokens)\n    )\n\n    yield\n\n    await Tortoise.close_connections()\n    os.remove(DATABASE_FILE_PATH)\n\n\n@pytest.mark.fastapi(app=app, run_lifespan_events=False)\n@pytest.mark.asyncio\nclass TestChapter7CSRFRegister:\n    async def test_invalid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\"/register\", json={})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_email_already_exists(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/register\", json={\"email\": \"user1@example.com\", \"password\": \"foobar\"}\n        )\n\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        json = response.json()\n        assert json[\"detail\"] == \"Email already exists\"\n\n    async def test_valid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/register\", json={\"email\": \"user2@example.com\", \"password\": \"foobar\"}\n        )\n\n        assert response.status_code == status.HTTP_201_CREATED\n        json = response.json()\n        assert json[\"email\"] == \"user2@example.com\"\n        assert \"id\" in json\n        assert \"hashed_password\" not in json\n\n\n@pytest.mark.fastapi(app=app, run_lifespan_events=False)\n@pytest.mark.asyncio\nclass TestChapter7CSRFLogin:\n    async def test_invalid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\"/login\", data={})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_invalid_email(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/login\",\n            data={\"email\": \"user3@example.com\", \"password\": \"invalid_password\"},\n        )\n\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    async def test_invalid_password(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/login\",\n            data={\"email\": \"user1@example.com\", \"password\": \"invalid_password\"},\n        )\n\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    async def test_valid_credentials(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/login\",\n            data={\"email\": \"user1@example.com\", \"password\": \"foobar\"},\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        assert \"token\" in response.cookies\n\n\n@pytest.mark.fastapi(app=app, run_lifespan_events=False)\n@pytest.mark.asyncio\nclass TestChapter7CSRFGetMe:\n    async def test_not_authenticated(self, client: httpx.AsyncClient):\n        response = await client.get(\"/me\")\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    async def test_invalid_token(self, client: httpx.AsyncClient):\n        response = await client.get(\"/me\", cookies={\"token\": \"INVALID_TOKEN\"})\n\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    async def test_expired_token(self, client: httpx.AsyncClient):\n        response = await client.get(\"/me\", cookies={\"token\": \"EXPIRED_USER1_TOKEN\"})\n\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    async def test_valid_token(self, client: httpx.AsyncClient):\n        response = await client.get(\"/me\", cookies={\"token\": \"VALID_USER1_TOKEN\"})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n\n        assert json == {\"id\": 1, \"email\": \"user1@example.com\"}\n\n\n@pytest.mark.fastapi(app=app, run_lifespan_events=False)\n@pytest.mark.asyncio\nclass TestChapter7CSRFUpdateMe:\n    async def test_no_csrf(self, client: httpx.AsyncClient):\n        response = await client.post(\"/me\", json={})\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    async def test_not_authenticated(self, client: httpx.AsyncClient):\n        await self._handle_csrf(client)\n        response = await client.post(\"/me\", json={})\n\n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n    async def test_invalid_token(self, client: httpx.AsyncClient):\n        await self._handle_csrf(client)\n        response = await client.post(\"/me\", cookies={\"token\": \"INVALID_TOKEN\"}, json={})\n\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    async def test_expired_token(self, client: httpx.AsyncClient):\n        await self._handle_csrf(client)\n        response = await client.post(\n            \"/me\", cookies={\"token\": \"EXPIRED_USER1_TOKEN\"}, json={}\n        )\n\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    async def test_valid_token(self, client: httpx.AsyncClient):\n        await self._handle_csrf(client)\n        response = await client.post(\n            \"/me\",\n            cookies={\"token\": \"VALID_USER1_TOKEN\"},\n            json={\"email\": \"user1+updated@example.com\"},\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n\n        assert json == {\"id\": 1, \"email\": \"user1+updated@example.com\"}\n\n    async def _handle_csrf(self, client: httpx.AsyncClient):\n        response = await client.get(\"/csrf\")\n        set_cookie_header = response.headers[\"set-cookie\"]\n        csrf = set_cookie_header.split(\";\")[0].split(\"=\")[1]\n\n        client.cookies[\"csrftoken\"] = csrf\n        client.headers[\"x-csrftoken\"] = csrf\n"}
{"type": "test_file", "path": "tests/test_chapter6_tortoise.py", "content": "import os\nfrom typing import Any, Dict, Optional\n\nimport httpx\nimport pytest\nimport pytest_asyncio\nfrom fastapi import status\nfrom tortoise import Tortoise\n\nfrom chapter6.tortoise.app import app\nfrom chapter6.tortoise.models import PostDB, PostTortoise\n\n\nDATABASE_FILE_PATH = \"chapter6_tortoise.test.db\"\nDATABASE_URL = f\"sqlite://{DATABASE_FILE_PATH}\"\n\n\n@pytest_asyncio.fixture(autouse=True, scope=\"module\")\nasync def initialize_database():\n    await Tortoise.init(\n        db_url=DATABASE_URL, modules={\"models\": [\"chapter6.tortoise.models\"]}\n    )\n    await Tortoise.generate_schemas()\n\n    initial_posts = [\n        PostDB(id=1, title=\"Post 1\", content=\"Content 1\"),\n        PostDB(id=2, title=\"Post 2\", content=\"Content 2\"),\n        PostDB(id=3, title=\"Post 3\", content=\"Content 3\"),\n    ]\n    await PostTortoise.bulk_create(\n        (PostTortoise(**post.dict()) for post in initial_posts)\n    )\n\n    yield\n\n    await Tortoise.close_connections()\n    os.remove(DATABASE_FILE_PATH)\n\n\n@pytest.mark.fastapi(app=app, run_lifespan_events=False)\n@pytest.mark.asyncio\nclass TestChapter6Tortoise:\n    @pytest.mark.parametrize(\n        \"skip,limit,nb_results\", [(None, None, 3), (0, 1, 1), (10, 1, 0)]\n    )\n    async def test_list_posts(\n        self,\n        client: httpx.AsyncClient,\n        skip: Optional[int],\n        limit: Optional[int],\n        nb_results: int,\n    ):\n        params = {}\n        if skip:\n            params[\"skip\"] = skip\n        if limit:\n            params[\"limit\"] = limit\n        response = await client.get(\"/posts\", params=params)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert len(json) == nb_results\n\n    @pytest.mark.parametrize(\n        \"id,status_code\", [(1, status.HTTP_200_OK), (10, status.HTTP_404_NOT_FOUND)]\n    )\n    async def test_get_post(self, client: httpx.AsyncClient, id: int, status_code: int):\n        response = await client.get(f\"/posts/{id}\")\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_200_OK:\n            json = response.json()\n            assert json[\"id\"] == id\n\n    @pytest.mark.parametrize(\n        \"payload,status_code\",\n        [\n            ({\"title\": \"New post\", \"content\": \"New content\"}, status.HTTP_201_CREATED),\n            ({}, status.HTTP_422_UNPROCESSABLE_ENTITY),\n        ],\n    )\n    async def test_create_post(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any], status_code: int\n    ):\n        response = await client.post(\"/posts\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_201_CREATED:\n            json = response.json()\n            assert \"id\" in json\n\n    @pytest.mark.parametrize(\n        \"id,payload,status_code\",\n        [\n            (1, {\"title\": \"Post 1 Updated\"}, status.HTTP_200_OK),\n            (10, {\"title\": \"Post 10 Updated\"}, status.HTTP_404_NOT_FOUND),\n        ],\n    )\n    async def test_update_post(\n        self,\n        client: httpx.AsyncClient,\n        id: int,\n        payload: Dict[str, Any],\n        status_code: int,\n    ):\n        response = await client.patch(f\"/posts/{id}\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_200_OK:\n            json = response.json()\n            for key in payload:\n                assert json[key] == payload[key]\n\n    @pytest.mark.parametrize(\n        \"id,status_code\",\n        [(1, status.HTTP_204_NO_CONTENT), (10, status.HTTP_404_NOT_FOUND)],\n    )\n    async def test_delete_post(\n        self, client: httpx.AsyncClient, id: int, status_code: int\n    ):\n        response = await client.delete(f\"/posts/{id}\")\n\n        assert response.status_code == status_code\n"}
{"type": "test_file", "path": "tests/test_chapter7_authentication.py", "content": "import os\nfrom datetime import datetime, timedelta\n\nimport httpx\nimport pytest\nimport pytest_asyncio\nfrom fastapi import status\nfrom tortoise import Tortoise\n\nfrom chapter7.authentication.app import app\nfrom chapter7.authentication.models import (\n    AccessToken,\n    AccessTokenTortoise,\n    UserDB,\n    UserTortoise,\n)\nfrom chapter7.authentication.password import get_password_hash\n\nDATABASE_FILE_PATH = \"chapter7_authentication.test.db\"\nDATABASE_URL = f\"sqlite://{DATABASE_FILE_PATH}\"\n\n\n@pytest_asyncio.fixture(autouse=True, scope=\"module\")\nasync def initialize_database():\n    await Tortoise.init(\n        db_url=DATABASE_URL,\n        modules={\"models\": [\"chapter7.authentication.models\"]},\n    )\n    await Tortoise.generate_schemas()\n\n    initial_users = [\n        UserDB(\n            id=1, email=\"user1@example.com\", hashed_password=get_password_hash(\"foobar\")\n        ),\n    ]\n    await UserTortoise.bulk_create(\n        (UserTortoise(**user.dict()) for user in initial_users)\n    )\n\n    initial_tokens = [\n        AccessToken(\n            access_token=\"VALID_USER1_TOKEN\",\n            user_id=1,\n            expiration_date=datetime.utcnow() + timedelta(seconds=86400),\n        ),\n        AccessToken(\n            access_token=\"EXPIRED_USER1_TOKEN\",\n            user_id=1,\n            expiration_date=datetime.utcnow() - timedelta(seconds=86400),\n        ),\n    ]\n    await AccessTokenTortoise.bulk_create(\n        (AccessTokenTortoise(**token.dict()) for token in initial_tokens)\n    )\n\n    yield\n\n    await Tortoise.close_connections()\n    os.remove(DATABASE_FILE_PATH)\n\n\n@pytest.mark.fastapi(app=app, run_lifespan_events=False)\n@pytest.mark.asyncio\nclass TestChapter7ProjectRegister:\n    async def test_invalid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\"/register\", json={})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_email_already_exists(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/register\", json={\"email\": \"user1@example.com\", \"password\": \"foobar\"}\n        )\n\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        json = response.json()\n        assert json[\"detail\"] == \"Email already exists\"\n\n    async def test_valid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/register\", json={\"email\": \"user2@example.com\", \"password\": \"foobar\"}\n        )\n\n        assert response.status_code == status.HTTP_201_CREATED\n        json = response.json()\n        assert json[\"email\"] == \"user2@example.com\"\n        assert \"id\" in json\n        assert \"hashed_password\" not in json\n\n\n@pytest.mark.fastapi(app=app, run_lifespan_events=False)\n@pytest.mark.asyncio\nclass TestChapter7ProjectToken:\n    async def test_invalid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\"/token\", data={})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_invalid_email(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/token\",\n            data={\"username\": \"user3@example.com\", \"password\": \"invalid_password\"},\n        )\n\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    async def test_invalid_password(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/token\",\n            data={\"username\": \"user1@example.com\", \"password\": \"invalid_password\"},\n        )\n\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    async def test_valid_credentials(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/token\",\n            data={\"username\": \"user1@example.com\", \"password\": \"foobar\"},\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json[\"token_type\"] == \"bearer\"\n        assert \"access_token\" in json\n\n\n@pytest.mark.fastapi(app=app, run_lifespan_events=False)\n@pytest.mark.asyncio\nclass TestChapter7ProjectProtectedRoute:\n    async def test_not_authenticated(self, client: httpx.AsyncClient):\n        response = await client.get(\"/protected-route\")\n\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    async def test_invalid_token(self, client: httpx.AsyncClient):\n        response = await client.get(\n            \"/protected-route\", headers={\"Authorization\": \"Bearer INVALID_TOKEN\"}\n        )\n\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    async def test_expired_token(self, client: httpx.AsyncClient):\n        response = await client.get(\n            \"/protected-route\", headers={\"Authorization\": \"Bearer EXPIRED_USER1_TOKEN\"}\n        )\n\n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n    async def test_valid_token(self, client: httpx.AsyncClient):\n        response = await client.get(\n            \"/protected-route\", headers={\"Authorization\": \"Bearer VALID_USER1_TOKEN\"}\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n\n        assert json == {\"id\": 1, \"email\": \"user1@example.com\"}\n"}
{"type": "test_file", "path": "tests/test_chapter6_sqlalchemy.py", "content": "import os\nfrom typing import Any, Dict, Optional\n\nimport httpx\nimport pytest\nimport pytest_asyncio\nimport sqlalchemy\nfrom databases import Database\nfrom fastapi import status\n\nfrom chapter6.sqlalchemy.app import app\nfrom chapter6.sqlalchemy.models import PostDB, metadata, posts\nfrom chapter6.sqlalchemy.database import get_database\n\n\nDATABASE_FILE_PATH = \"chapter6_sqlalchemy.test.db\"\nDATABASE_URL = f\"sqlite:///{DATABASE_FILE_PATH}\"\ndatabase_test = Database(DATABASE_URL)\nsqlalchemy_engine = sqlalchemy.create_engine(DATABASE_URL)\n\n\n@pytest_asyncio.fixture(autouse=True, scope=\"module\")\nasync def initialize_database():\n    metadata.create_all(sqlalchemy_engine)\n\n    initial_posts = [\n        PostDB(id=1, title=\"Post 1\", content=\"Content 1\"),\n        PostDB(id=2, title=\"Post 2\", content=\"Content 2\"),\n        PostDB(id=3, title=\"Post 3\", content=\"Content 3\"),\n    ]\n    insert_query = posts.insert().values([post.dict() for post in initial_posts])\n    await database_test.execute(insert_query)\n\n    yield\n\n    os.remove(DATABASE_FILE_PATH)\n\n\n@pytest.mark.fastapi(\n    app=app, dependency_overrides={get_database: lambda: database_test}\n)\n@pytest.mark.asyncio\nclass TestChapter6SQLAlchemy:\n    @pytest.mark.parametrize(\n        \"skip,limit,nb_results\", [(None, None, 3), (0, 1, 1), (10, 1, 0)]\n    )\n    async def test_list_posts(\n        self,\n        client: httpx.AsyncClient,\n        skip: Optional[int],\n        limit: Optional[int],\n        nb_results: int,\n    ):\n        params = {}\n        if skip:\n            params[\"skip\"] = skip\n        if limit:\n            params[\"limit\"] = limit\n        response = await client.get(\"/posts\", params=params)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert len(json) == nb_results\n\n    @pytest.mark.parametrize(\n        \"id,status_code\", [(1, status.HTTP_200_OK), (10, status.HTTP_404_NOT_FOUND)]\n    )\n    async def test_get_post(self, client: httpx.AsyncClient, id: int, status_code: int):\n        response = await client.get(f\"/posts/{id}\")\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_200_OK:\n            json = response.json()\n            assert json[\"id\"] == id\n\n    @pytest.mark.parametrize(\n        \"payload,status_code\",\n        [\n            ({\"title\": \"New post\", \"content\": \"New content\"}, status.HTTP_201_CREATED),\n            ({}, status.HTTP_422_UNPROCESSABLE_ENTITY),\n        ],\n    )\n    async def test_create_post(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any], status_code: int\n    ):\n        response = await client.post(\"/posts\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_201_CREATED:\n            json = response.json()\n            assert \"id\" in json\n\n    @pytest.mark.parametrize(\n        \"id,payload,status_code\",\n        [\n            (1, {\"title\": \"Post 1 Updated\"}, status.HTTP_200_OK),\n            (2, {\"title\": \"Post 2 Updated\"}, status.HTTP_200_OK),\n            (10, {\"title\": \"Post 10 Updated\"}, status.HTTP_404_NOT_FOUND),\n        ],\n    )\n    async def test_update_post(\n        self,\n        client: httpx.AsyncClient,\n        id: int,\n        payload: Dict[str, Any],\n        status_code: int,\n    ):\n        response = await client.patch(f\"/posts/{id}\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_200_OK:\n            json = response.json()\n            for key in payload:\n                assert json[key] == payload[key]\n\n    @pytest.mark.parametrize(\n        \"id,status_code\",\n        [(1, status.HTTP_204_NO_CONTENT), (10, status.HTTP_404_NOT_FOUND)],\n    )\n    async def test_delete_post(\n        self, client: httpx.AsyncClient, id: int, status_code: int\n    ):\n        response = await client.delete(f\"/posts/{id}\")\n\n        assert response.status_code == status_code\n"}
{"type": "test_file", "path": "tests/test_chapter6_tortoise_relationship.py", "content": "import os\nfrom typing import Any, Dict, Optional\n\nimport httpx\nimport pytest\nimport pytest_asyncio\nfrom fastapi import status\nfrom tortoise import Tortoise\n\nfrom chapter6.tortoise_relationship.app import app\nfrom chapter6.tortoise_relationship.models import (\n    CommentDB,\n    CommentTortoise,\n    PostDB,\n    PostTortoise,\n)\n\n\nDATABASE_FILE_PATH = \"chapter6_tortoise_relationship.test.db\"\nDATABASE_URL = f\"sqlite://{DATABASE_FILE_PATH}\"\n\n\n@pytest_asyncio.fixture(autouse=True, scope=\"module\")\nasync def initialize_database():\n    await Tortoise.init(\n        db_url=DATABASE_URL,\n        modules={\"models\": [\"chapter6.tortoise_relationship.models\"]},\n    )\n    await Tortoise.generate_schemas()\n\n    initial_posts = [\n        PostDB(id=1, title=\"Post 1\", content=\"Content 1\"),\n        PostDB(id=2, title=\"Post 2\", content=\"Content 2\"),\n        PostDB(id=3, title=\"Post 3\", content=\"Content 3\"),\n    ]\n    await PostTortoise.bulk_create(\n        (PostTortoise(**post.dict()) for post in initial_posts)\n    )\n\n    initial_comments = [\n        CommentDB(id=1, post_id=1, content=\"Post 1 Comment 1\"),\n        CommentDB(id=2, post_id=1, content=\"Post 1 Comment 2\"),\n        CommentDB(id=3, post_id=1, content=\"Post 1 Comment 3\"),\n    ]\n    await CommentTortoise.bulk_create(\n        (CommentTortoise(**comment.dict()) for comment in initial_comments)\n    )\n\n    yield\n\n    await Tortoise.close_connections()\n    os.remove(DATABASE_FILE_PATH)\n\n\n@pytest.mark.fastapi(app=app, run_lifespan_events=False)\n@pytest.mark.asyncio\nclass TestChapter6TortoiseRelationship:\n    @pytest.mark.parametrize(\n        \"skip,limit,nb_results\", [(None, None, 3), (0, 1, 1), (10, 1, 0)]\n    )\n    async def test_list_posts(\n        self,\n        client: httpx.AsyncClient,\n        skip: Optional[int],\n        limit: Optional[int],\n        nb_results: int,\n    ):\n        params = {}\n        if skip:\n            params[\"skip\"] = skip\n        if limit:\n            params[\"limit\"] = limit\n        response = await client.get(\"/posts\", params=params)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert len(json) == nb_results\n\n    @pytest.mark.parametrize(\n        \"id,status_code,nb_comments\",\n        [(1, status.HTTP_200_OK, 3), (10, status.HTTP_404_NOT_FOUND, 0)],\n    )\n    async def test_get_post(\n        self, client: httpx.AsyncClient, id: int, status_code: int, nb_comments: int\n    ):\n        response = await client.get(f\"/posts/{id}\")\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_200_OK:\n            json = response.json()\n            assert json[\"id\"] == id\n            assert len(json[\"comments\"]) == nb_comments\n\n    @pytest.mark.parametrize(\n        \"payload,status_code\",\n        [\n            ({\"title\": \"New post\", \"content\": \"New content\"}, status.HTTP_201_CREATED),\n            ({}, status.HTTP_422_UNPROCESSABLE_ENTITY),\n        ],\n    )\n    async def test_create_post(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any], status_code: int\n    ):\n        response = await client.post(\"/posts\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_201_CREATED:\n            json = response.json()\n            assert \"id\" in json\n            assert json[\"comments\"] == []\n\n    @pytest.mark.parametrize(\n        \"id,payload,status_code,nb_comments\",\n        [\n            (1, {\"title\": \"Post 1 Updated\"}, status.HTTP_200_OK, 3),\n            (10, {\"title\": \"Post 10 Updated\"}, status.HTTP_404_NOT_FOUND, 0),\n        ],\n    )\n    async def test_update_post(\n        self,\n        client: httpx.AsyncClient,\n        id: int,\n        payload: Dict[str, Any],\n        status_code: int,\n        nb_comments: int,\n    ):\n        response = await client.patch(f\"/posts/{id}\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_200_OK:\n            json = response.json()\n            for key in payload:\n                assert json[key] == payload[key]\n            assert len(json[\"comments\"]) == nb_comments\n\n    @pytest.mark.parametrize(\n        \"id,status_code\",\n        [(1, status.HTTP_204_NO_CONTENT), (10, status.HTTP_404_NOT_FOUND)],\n    )\n    async def test_delete_post(\n        self, client: httpx.AsyncClient, id: int, status_code: int\n    ):\n        response = await client.delete(f\"/posts/{id}\")\n\n        assert response.status_code == status_code\n\n    async def test_create_comment_not_existing_post(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/comments\", json={\"post_id\": 10, \"content\": \"New comment\"}\n        )\n\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        json = response.json()\n        assert json[\"detail\"] == \"Post 10 does not exist\"\n\n    @pytest.mark.parametrize(\n        \"payload,status_code\",\n        [\n            ({\"post_id\": 2, \"content\": \"New comment\"}, status.HTTP_201_CREATED),\n            ({}, status.HTTP_422_UNPROCESSABLE_ENTITY),\n        ],\n    )\n    async def test_create_comment(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any], status_code: int\n    ):\n        response = await client.post(\"/comments\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_201_CREATED:\n            json = response.json()\n            assert \"id\" in json\n"}
{"type": "test_file", "path": "tests/test_chapter8.py", "content": "import asyncio\nfrom typing import Optional, cast\n\nimport pytest\nfrom fastapi import status\nfrom fastapi.testclient import TestClient\nfrom starlette.testclient import WebSocketTestSession\nfrom starlette.websockets import WebSocketDisconnect\n\nfrom chapter8.echo.app import app as chapter8_echo_app\nfrom chapter8.concurrency.app import app as chapter8_concurrency_app\nfrom chapter8.dependencies.app import app as chapter8_dependencies_app, API_TOKEN\nfrom chapter8.broadcast.app import app as chapter8_broadcast_app\n\n\n@pytest.mark.fastapi(app=chapter8_echo_app)\nclass TestChapter8Echo:\n    def test_echo(self, websocket_client: TestClient):\n        with websocket_client.websocket_connect(\"/ws\") as websocket:\n            websocket = cast(WebSocketTestSession, websocket)\n\n            websocket.send_text(\"Hello\")\n            websocket.send_text(\"World\")\n\n            message1 = websocket.receive_text()\n            message2 = websocket.receive_text()\n\n            assert message1 == \"Message text was: Hello\"\n            assert message2 == \"Message text was: World\"\n\n\n@pytest.mark.fastapi(app=chapter8_concurrency_app)\nclass TestChapter8Concurrency:\n    def test_echo(self, websocket_client: TestClient):\n        with websocket_client.websocket_connect(\"/ws\") as websocket:\n            websocket = cast(WebSocketTestSession, websocket)\n\n            message_time = websocket.receive_text()\n\n            websocket.send_text(\"Hello\")\n            message_echo = websocket.receive_text()\n\n            assert message_time.startswith(\"It is:\")\n            assert message_echo == \"Message text was: Hello\"\n\n\n@pytest.mark.fastapi(app=chapter8_dependencies_app)\nclass TestChapter8Dependencies:\n    def test_missing_token(self, websocket_client: TestClient):\n        with pytest.raises(WebSocketDisconnect) as e:\n            websocket_client.websocket_connect(\"/ws\")\n            assert e.value.code == status.WS_1008_POLICY_VIOLATION\n\n    def test_invalid_token(self, websocket_client: TestClient):\n        with pytest.raises(WebSocketDisconnect) as e:\n            websocket_client.websocket_connect(\n                \"/ws\", headers={\"Cookie\": f\"token=INVALID_TOKEN\"}\n            )\n            assert e.value.code == status.WS_1008_POLICY_VIOLATION\n\n    @pytest.mark.parametrize(\n        \"username,welcome_message\",\n        [(None, \"Hello, Anonymous!\"), (\"John\", \"Hello, John!\")],\n    )\n    def test_valid_token(\n        self,\n        websocket_client: TestClient,\n        username: Optional[str],\n        welcome_message: str,\n    ):\n        url = \"/ws\"\n        if username:\n            url += f\"?username={username}\"\n\n        with websocket_client.websocket_connect(\n            url, headers={\"Cookie\": f\"token={API_TOKEN}\"}\n        ) as websocket:\n            websocket = cast(WebSocketTestSession, websocket)\n\n            message1 = websocket.receive_text()\n\n            websocket.send_text(\"Hello\")\n            message2 = websocket.receive_text()\n\n            assert message1 == welcome_message\n            assert message2 == \"Message text was: Hello\"\n\n\n@pytest.mark.fastapi(app=chapter8_broadcast_app)\n@pytest.mark.skip\nclass TestChapter8Broadcast:\n    def test_broadcast(self, websocket_client: TestClient):\n        with websocket_client.websocket_connect(\"/ws?username=U1\") as websocket1:\n            with websocket_client.websocket_connect(\"/ws?username=U2\") as websocket2:\n                websocket1 = cast(WebSocketTestSession, websocket1)\n                websocket2 = cast(WebSocketTestSession, websocket2)\n\n                websocket1.send_text(\"Hello from U1\")\n                websocket2.send_text(\"Hello from U2\")\n\n                websocket2_message = websocket2.receive_json()\n                websocket1_message = websocket1.receive_json()\n\n                assert websocket2_message == {\n                    \"username\": \"U1\",\n                    \"message\": \"Hello from U1\",\n                }\n                assert websocket1_message == {\n                    \"username\": \"U2\",\n                    \"message\": \"Hello from U2\",\n                }\n"}
{"type": "test_file", "path": "tests/test_chapter6_sqlalchemy_relationship.py", "content": "import os\nfrom typing import Any, Dict, Optional\n\nimport httpx\nimport pytest\nimport pytest_asyncio\nimport sqlalchemy\nfrom databases import Database\nfrom fastapi import status\n\nfrom chapter6.sqlalchemy_relationship.app import app\nfrom chapter6.sqlalchemy_relationship.models import (\n    CommentDB,\n    PostDB,\n    comments,\n    metadata,\n    posts,\n)\nfrom chapter6.sqlalchemy_relationship.database import get_database\n\n\nDATABASE_FILE_PATH = \"chapter6_sqlalchemy_relationship.test.db\"\nDATABASE_URL = f\"sqlite:///{DATABASE_FILE_PATH}\"\ndatabase_test = Database(DATABASE_URL)\nsqlalchemy_engine = sqlalchemy.create_engine(DATABASE_URL)\n\n\n@pytest_asyncio.fixture(autouse=True, scope=\"module\")\nasync def initialize_database():\n    metadata.create_all(sqlalchemy_engine)\n\n    initial_posts = [\n        PostDB(id=1, title=\"Post 1\", content=\"Content 1\"),\n        PostDB(id=2, title=\"Post 2\", content=\"Content 2\"),\n        PostDB(id=3, title=\"Post 3\", content=\"Content 3\"),\n    ]\n    insert_query = posts.insert().values([post.dict() for post in initial_posts])\n    await database_test.execute(insert_query)\n\n    initial_comments = [\n        CommentDB(id=1, post_id=1, content=\"Post 1 Comment 1\"),\n        CommentDB(id=2, post_id=1, content=\"Post 1 Comment 2\"),\n        CommentDB(id=3, post_id=1, content=\"Post 1 Comment 3\"),\n    ]\n    insert_query = comments.insert().values(\n        [comment.dict() for comment in initial_comments]\n    )\n    await database_test.execute(insert_query)\n\n    yield\n\n    os.remove(DATABASE_FILE_PATH)\n\n\n@pytest.mark.fastapi(\n    app=app, dependency_overrides={get_database: lambda: database_test}\n)\n@pytest.mark.asyncio\nclass TestChapter6SQLAlchemyRelationship:\n    @pytest.mark.parametrize(\n        \"skip,limit,nb_results\", [(None, None, 3), (0, 1, 1), (10, 1, 0)]\n    )\n    async def test_list_posts(\n        self,\n        client: httpx.AsyncClient,\n        skip: Optional[int],\n        limit: Optional[int],\n        nb_results: int,\n    ):\n        params = {}\n        if skip:\n            params[\"skip\"] = skip\n        if limit:\n            params[\"limit\"] = limit\n        response = await client.get(\"/posts\", params=params)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert len(json) == nb_results\n\n    @pytest.mark.parametrize(\n        \"id,status_code,nb_comments\",\n        [(1, status.HTTP_200_OK, 3), (10, status.HTTP_404_NOT_FOUND, 0)],\n    )\n    async def test_get_post(\n        self, client: httpx.AsyncClient, id: int, status_code: int, nb_comments: int\n    ):\n        response = await client.get(f\"/posts/{id}\")\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_200_OK:\n            json = response.json()\n            assert json[\"id\"] == id\n            assert len(json[\"comments\"]) == nb_comments\n\n    @pytest.mark.parametrize(\n        \"payload,status_code\",\n        [\n            ({\"title\": \"New post\", \"content\": \"New content\"}, status.HTTP_201_CREATED),\n            ({}, status.HTTP_422_UNPROCESSABLE_ENTITY),\n        ],\n    )\n    async def test_create_post(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any], status_code: int\n    ):\n        response = await client.post(\"/posts\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_201_CREATED:\n            json = response.json()\n            assert \"id\" in json\n            assert json[\"comments\"] == []\n\n    @pytest.mark.parametrize(\n        \"id,payload,status_code,nb_comments\",\n        [\n            (1, {\"title\": \"Post 1 Updated\"}, status.HTTP_200_OK, 3),\n            (2, {\"title\": \"Post 2 Updated\"}, status.HTTP_200_OK, 0),\n            (10, {\"title\": \"Post 10 Updated\"}, status.HTTP_404_NOT_FOUND, 0),\n        ],\n    )\n    async def test_update_post(\n        self,\n        client: httpx.AsyncClient,\n        id: int,\n        payload: Dict[str, Any],\n        status_code: int,\n        nb_comments: int,\n    ):\n        response = await client.patch(f\"/posts/{id}\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_200_OK:\n            json = response.json()\n            for key in payload:\n                assert json[key] == payload[key]\n            assert len(json[\"comments\"]) == nb_comments\n\n    @pytest.mark.parametrize(\n        \"id,status_code\",\n        [(1, status.HTTP_204_NO_CONTENT), (10, status.HTTP_404_NOT_FOUND)],\n    )\n    async def test_delete_post(\n        self, client: httpx.AsyncClient, id: int, status_code: int\n    ):\n        response = await client.delete(f\"/posts/{id}\")\n\n        assert response.status_code == status_code\n\n    async def test_create_comment_not_existing_post(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/comments\", json={\"post_id\": 10, \"content\": \"New comment\"}\n        )\n\n        assert response.status_code == status.HTTP_400_BAD_REQUEST\n        json = response.json()\n        assert json[\"detail\"] == \"Post 10 does not exist\"\n\n    @pytest.mark.parametrize(\n        \"payload,status_code\",\n        [\n            ({\"post_id\": 2, \"content\": \"New comment\"}, status.HTTP_201_CREATED),\n            ({}, status.HTTP_422_UNPROCESSABLE_ENTITY),\n        ],\n    )\n    async def test_create_comment(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any], status_code: int\n    ):\n        response = await client.post(\"/comments\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_201_CREATED:\n            json = response.json()\n            assert \"id\" in json\n"}
{"type": "test_file", "path": "tests/test_chapter3.py", "content": "from typing import Any, Dict, Optional\n\nimport httpx\nimport pytest\nfrom fastapi import status\n\nfrom chapter3.chapter3_first_endpoint_01 import app as chapter3_first_endpoint_01_app\nfrom chapter3.chapter3_path_parameters_01 import (\n    app as chapter3_path_parameters_01_app,\n)\nfrom chapter3.chapter3_path_parameters_02 import (\n    app as chapter3_path_parameters_02_app,\n)\nfrom chapter3.chapter3_path_parameters_03 import (\n    app as chapter3_path_parameters_03_app,\n)\nfrom chapter3.chapter3_path_parameters_04 import (\n    app as chapter3_path_parameters_04_app,\n)\nfrom chapter3.chapter3_path_parameters_05 import (\n    app as chapter3_path_parameters_05_app,\n)\nfrom chapter3.chapter3_path_parameters_06 import (\n    app as chapter3_path_parameters_06_app,\n)\nfrom chapter3.chapter3_query_parameters_01 import (\n    app as chapter3_query_parameters_01_app,\n)\nfrom chapter3.chapter3_query_parameters_02 import (\n    app as chapter3_query_parameters_02_app,\n)\nfrom chapter3.chapter3_query_parameters_03 import (\n    app as chapter3_query_parameters_03_app,\n)\nfrom chapter3.chapter3_request_body_01 import (\n    app as chapter3_request_body_01_app,\n)\nfrom chapter3.chapter3_request_body_02 import (\n    app as chapter3_request_body_02_app,\n)\nfrom chapter3.chapter3_request_body_03 import (\n    app as chapter3_request_body_03_app,\n)\nfrom chapter3.chapter3_request_body_04 import (\n    app as chapter3_request_body_04_app,\n)\nfrom chapter3.chapter3_form_data_01 import (\n    app as chapter3_form_data_01_app,\n)\nfrom chapter3.chapter3_file_uploads_01 import (\n    app as chapter3_file_uploads_01_app,\n)\nfrom chapter3.chapter3_file_uploads_02 import (\n    app as chapter3_file_uploads_02_app,\n)\nfrom chapter3.chapter3_file_uploads_03 import (\n    app as chapter3_file_uploads_03_app,\n)\nfrom chapter3.chapter3_headers_cookies_01 import (\n    app as chapter3_headers_cookies_01_app,\n)\nfrom chapter3.chapter3_headers_cookies_02 import (\n    app as chapter3_headers_cookies_02_app,\n)\nfrom chapter3.chapter3_headers_cookies_03 import (\n    app as chapter3_headers_cookies_03_app,\n)\nfrom chapter3.chapter3_request_object_01 import (\n    app as chapter3_request_object_01_app,\n)\nfrom chapter3.chapter3_response_path_parameters_01 import (\n    app as chapter3_response_path_parameters_01_app,\n)\nfrom chapter3.chapter3_response_path_parameters_02 import (\n    app as chapter3_response_path_parameters_02_app,\n)\nfrom chapter3.chapter3_response_path_parameters_03 import (\n    app as chapter3_response_path_parameters_03_app,\n)\nfrom chapter3.chapter3_response_path_parameters_04 import (\n    app as chapter3_response_path_parameters_04_app,\n)\nfrom chapter3.chapter3_response_parameter_01 import (\n    app as chapter3_response_parameter_01_app,\n)\nfrom chapter3.chapter3_response_parameter_02 import (\n    app as chapter3_response_parameter_02_app,\n)\nfrom chapter3.chapter3_response_parameter_03 import (\n    app as chapter3_response_parameter_03_app,\n)\nfrom chapter3.chapter3_raise_errors_01 import (\n    app as chapter3_raise_errors_01_app,\n)\nfrom chapter3.chapter3_raise_errors_02 import (\n    app as chapter3_raise_errors_02_app,\n)\nfrom chapter3.chapter3_custom_response_01 import (\n    app as chapter3_custom_response_01_app,\n)\nfrom chapter3.chapter3_custom_response_02 import (\n    app as chapter3_custom_response_02_app,\n)\nfrom chapter3.chapter3_custom_response_03 import (\n    app as chapter3_custom_response_03_app,\n)\nfrom chapter3.chapter3_custom_response_04 import (\n    app as chapter3_custom_response_04_app,\n)\nfrom chapter3.chapter3_custom_response_05 import (\n    app as chapter3_custom_response_05_app,\n)\n\n\n@pytest.mark.fastapi(app=chapter3_first_endpoint_01_app)\n@pytest.mark.asyncio\nclass TestFirstEndpoint01:\n    async def test_get(self, client: httpx.AsyncClient):\n        response = await client.get(\"/\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"hello\": \"world\"}\n\n\n@pytest.mark.fastapi(app=chapter3_path_parameters_01_app)\n@pytest.mark.asyncio\nclass TestPathParameters01:\n    async def test_get_without_id(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users/\")\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    async def test_get_str_id(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users/abc\")\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_int_id(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users/123\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"id\": 123}\n\n\n@pytest.mark.fastapi(app=chapter3_path_parameters_02_app)\n@pytest.mark.asyncio\nclass TestPathParameters02:\n    async def test_get_company_id(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users/standard/123/\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"type\": \"standard\", \"id\": 123}\n\n\n@pytest.mark.fastapi(app=chapter3_path_parameters_03_app)\n@pytest.mark.asyncio\nclass TestPathParameters03:\n    async def test_get_invalid_type(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users/foo/123/\")\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.parametrize(\"type\", [\"standard\", \"admin\"])\n    async def test_get_standard_user(self, client: httpx.AsyncClient, type: str):\n        response = await client.get(f\"/users/{type}/123/\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"type\": type, \"id\": 123}\n\n\n@pytest.mark.fastapi(app=chapter3_path_parameters_04_app)\n@pytest.mark.asyncio\nclass TestPathParameters04:\n    async def test_get_str_id(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users/abc\")\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_zero_id(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users/0\")\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_one_id(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users/1\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"id\": 1}\n\n    async def test_get_int_id(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users/123\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"id\": 123}\n\n\n@pytest.mark.fastapi(app=chapter3_path_parameters_05_app)\n@pytest.mark.asyncio\nclass TestPathParameters05:\n    async def test_get_too_short(self, client: httpx.AsyncClient):\n        response = await client.get(\"/license-plates/abc\")\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_too_long(self, client: httpx.AsyncClient):\n        response = await client.get(\"/license-plates/abc-123-def\")\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_correct_length(self, client: httpx.AsyncClient):\n        response = await client.get(\"/license-plates/ab-123-de\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"license\": \"ab-123-de\"}\n\n\n@pytest.mark.fastapi(app=chapter3_path_parameters_06_app)\n@pytest.mark.asyncio\nclass TestPathParameters06:\n    @pytest.mark.parametrize(\n        \"license\", [\"abc\", \"abc-123-def\", \"12-abc-42\", \"ab-123-bcd\"]\n    )\n    async def test_get_invalid_format(self, client: httpx.AsyncClient, license: str):\n        response = await client.get(f\"/license-plates/{license}\")\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_valid_format(self, client: httpx.AsyncClient):\n        response = await client.get(\"/license-plates/ab-123-de\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"license\": \"ab-123-de\"}\n\n\n@pytest.mark.fastapi(app=chapter3_query_parameters_01_app)\n@pytest.mark.asyncio\nclass TestQueryParameters01:\n    async def test_get_wrong_parameters(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users\", params={\"page\": \"foo\", \"size\": \"bar\"})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_default_parameters(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"page\": 1, \"size\": 10}\n\n    async def get_get_set_parameters(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users\", params={\"page\": 5, \"size\": 100})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"page\": 5, \"size\": 100}\n\n\n@pytest.mark.fastapi(app=chapter3_query_parameters_02_app)\n@pytest.mark.asyncio\nclass TestQueryParameters02:\n    async def test_missing_format(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users\")\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_wrong_format(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users\", params={\"format\": \"foo\"})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.parametrize(\"format\", [\"short\", \"full\"])\n    async def test_acceptable_format(self, client: httpx.AsyncClient, format: str):\n        response = await client.get(\"/users\", params={\"format\": format})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"format\": format}\n\n\n@pytest.mark.fastapi(app=chapter3_query_parameters_03_app)\n@pytest.mark.asyncio\nclass TestQueryParameters03:\n    async def test_get_wrong_parameters(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users\", params={\"page\": \"foo\", \"size\": \"bar\"})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    @pytest.mark.parametrize(\"page,size\", [(0, 5), (1, 150), (0, 150)])\n    async def test_get_out_of_range_parameters(\n        self, client: httpx.AsyncClient, page: int, size: int\n    ):\n        response = await client.get(\"/users\", params={\"page\": page, \"size\": size})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_default_parameters(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"page\": 1, \"size\": 10}\n\n    async def get_get_set_parameters(self, client: httpx.AsyncClient):\n        response = await client.get(\"/users\", params={\"page\": 5, \"size\": 100})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"page\": 5, \"size\": 100}\n\n\n@pytest.mark.fastapi(app=chapter3_request_body_01_app)\n@pytest.mark.asyncio\nclass TestRequestBody01:\n    @pytest.mark.parametrize(\n        \"payload\", [{}, {\"name\": \"John\"}, {\"name\": \"John\", \"age\": \"Doe\"}]\n    )\n    async def test_get_wrong_payload(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any]\n    ):\n        response = await client.post(\"/users\", json=payload)\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_valid_payload(self, client: httpx.AsyncClient):\n        payload = {\"name\": \"John\", \"age\": 30}\n        response = await client.post(\"/users\", json=payload)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == payload\n\n\n@pytest.mark.fastapi(app=chapter3_request_body_02_app)\n@pytest.mark.asyncio\nclass TestRequestBody02:\n    @pytest.mark.parametrize(\n        \"payload\", [{}, {\"name\": \"John\"}, {\"name\": \"John\", \"age\": \"Doe\"}]\n    )\n    async def test_get_wrong_payload(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any]\n    ):\n        response = await client.post(\"/users\", json=payload)\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_valid_payload(self, client: httpx.AsyncClient):\n        payload = {\"name\": \"John\", \"age\": 30}\n        response = await client.post(\"/users\", json=payload)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == payload\n\n\n@pytest.mark.fastapi(app=chapter3_request_body_03_app)\n@pytest.mark.asyncio\nclass TestRequestBody03:\n    @pytest.mark.parametrize(\n        \"payload\",\n        [\n            {},\n            {\"user\": {}, \"company\": {}},\n            {\"user\": {\"name\": \"John\", \"age\": \"Doe\"}, \"company\": {\"name\": \"ACME\"}},\n        ],\n    )\n    async def test_get_wrong_payload(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any]\n    ):\n        response = await client.post(\"/users\", json=payload)\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_valid_payload(self, client: httpx.AsyncClient):\n        payload = {\"user\": {\"name\": \"John\", \"age\": 30}, \"company\": {\"name\": \"ACME\"}}\n        response = await client.post(\"/users\", json=payload)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == payload\n\n\n@pytest.mark.fastapi(app=chapter3_request_body_04_app)\n@pytest.mark.asyncio\nclass TestRequestBody04:\n    @pytest.mark.parametrize(\n        \"payload\",\n        [\n            {},\n            {\"user\": {}, \"priority\": \"foo\"},\n            {\"user\": {\"name\": \"John\", \"age\": \"Doe\"}, \"priority\": 1},\n            {\"user\": {\"name\": \"John\", \"age\": 30}, \"priority\": 0},\n        ],\n    )\n    async def test_get_wrong_payload(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any]\n    ):\n        response = await client.post(\"/users\", json=payload)\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_valid_payload(self, client: httpx.AsyncClient):\n        payload = {\"user\": {\"name\": \"John\", \"age\": 30}, \"priority\": 1}\n        response = await client.post(\"/users\", json=payload)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == payload\n\n\n@pytest.mark.fastapi(app=chapter3_form_data_01_app)\n@pytest.mark.asyncio\nclass TestFormData01:\n    @pytest.mark.parametrize(\n        \"payload\", [{}, {\"name\": \"John\"}, {\"name\": \"John\", \"age\": \"Doe\"}]\n    )\n    async def test_get_wrong_payload(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any]\n    ):\n        response = await client.post(\"/users\", data=payload)\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_valid_payload(self, client: httpx.AsyncClient):\n        payload = {\"name\": \"John\", \"age\": 30}\n        response = await client.post(\"/users\", data=payload)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == payload\n\n\n@pytest.mark.fastapi(app=chapter3_file_uploads_01_app)\n@pytest.mark.asyncio\nclass TestFileUploads01:\n    async def test_get_missing_file(self, client: httpx.AsyncClient):\n        response = await client.post(\"/files\")\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_valid_file(self, client: httpx.AsyncClient):\n        response = await client.post(\"/files\", files={\"file\": b\"Hello\"})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"file_size\": 5}\n\n\n@pytest.mark.fastapi(app=chapter3_file_uploads_02_app)\n@pytest.mark.asyncio\nclass TestFileUploads02:\n    async def test_get_missing_file(self, client: httpx.AsyncClient):\n        response = await client.post(\"/files\")\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_valid_file(self, client: httpx.AsyncClient):\n        response = await client.post(\"/files\", files={\"file\": (\"hello.txt\", b\"Hello\")})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"file_name\": \"hello.txt\", \"content_type\": \"text/plain\"}\n\n\n@pytest.mark.fastapi(app=chapter3_file_uploads_03_app)\n@pytest.mark.asyncio\nclass TestFileUploads03:\n    async def test_get_missing_files(self, client: httpx.AsyncClient):\n        response = await client.post(\"/files\")\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_get_valid_files(self, client: httpx.AsyncClient):\n        response = await client.post(\n            \"/files\",\n            files=[\n                (\"files\", (\"hello1.txt\", b\"Hello\")),\n                (\"files\", (\"hello2.txt\", b\"Hello\")),\n            ],\n        )\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == [\n            {\"file_name\": \"hello1.txt\", \"content_type\": \"text/plain\"},\n            {\"file_name\": \"hello2.txt\", \"content_type\": \"text/plain\"},\n        ]\n\n\n@pytest.mark.fastapi(app=chapter3_headers_cookies_01_app)\n@pytest.mark.asyncio\nclass TestHeadersCookies01:\n    async def test_missing_header(self, client: httpx.AsyncClient):\n        response = await client.get(\"/\")\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_valid_header(self, client: httpx.AsyncClient):\n        response = await client.get(\"/\", headers={\"Hello\": \"World\"})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"hello\": \"World\"}\n\n\n@pytest.mark.fastapi(app=chapter3_headers_cookies_02_app)\n@pytest.mark.asyncio\nclass TestHeadersCookies02:\n    async def test_missing_header(self, client: httpx.AsyncClient):\n        client.headers.pop(\"User-Agent\")\n        response = await client.get(\"/\")\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_valid_header(self, client: httpx.AsyncClient):\n        response = await client.get(\"/\", headers={\"User-Agent\": \"HTTPX\"})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"user_agent\": \"HTTPX\"}\n\n\n@pytest.mark.fastapi(app=chapter3_headers_cookies_03_app)\n@pytest.mark.asyncio\nclass TestHeadersCookies03:\n    @pytest.mark.parametrize(\"cookie\", [None, \"World\"])\n    async def test_cookie(self, client: httpx.AsyncClient, cookie: Optional[str]):\n        cookies = []\n        if cookie:\n            cookies.append((\"hello\", cookie))\n        response = await client.get(\"/\", cookies=cookies)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"hello\": cookie}\n\n\n@pytest.mark.fastapi(app=chapter3_request_object_01_app)\n@pytest.mark.asyncio\nclass TestRequestObject01:\n    async def test_request(self, client: httpx.AsyncClient):\n        response = await client.get(\"/\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"path\": \"/\"}\n\n\n@pytest.mark.fastapi(app=chapter3_response_path_parameters_01_app)\n@pytest.mark.asyncio\nclass TestResponsePathParameters01:\n    async def test_create_post(self, client: httpx.AsyncClient):\n        payload = {\"title\": \"Hello\"}\n        response = await client.post(\"/posts\", json=payload)\n\n        assert response.status_code == status.HTTP_201_CREATED\n        json = response.json()\n        assert json == payload\n\n\n@pytest.mark.fastapi(app=chapter3_response_path_parameters_02_app)\n@pytest.mark.asyncio\nclass TestResponsePathParameters02:\n    async def test_delete_post(self, client: httpx.AsyncClient):\n        response = await client.delete(\"/posts/1\")\n\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        json = response.json()\n        assert json == None\n\n\n@pytest.mark.fastapi(app=chapter3_response_path_parameters_03_app)\n@pytest.mark.asyncio\nclass TestResponsePathParameters03:\n    async def test_get_post(self, client: httpx.AsyncClient):\n        response = await client.get(\"/posts/1\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"title\": \"Hello\", \"nb_views\": 100}\n\n\n@pytest.mark.fastapi(app=chapter3_response_path_parameters_04_app)\n@pytest.mark.asyncio\nclass TestResponsePathParameters04:\n    async def test_get_post(self, client: httpx.AsyncClient):\n        response = await client.get(\"/posts/1\")\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"title\": \"Hello\"}\n\n\n@pytest.mark.fastapi(app=chapter3_response_parameter_01_app)\n@pytest.mark.asyncio\nclass TestResponseParameter01:\n    async def test_get(self, client: httpx.AsyncClient):\n        response = await client.get(\"/\")\n\n        assert response.status_code == status.HTTP_200_OK\n        assert response.headers[\"custom-header\"] == \"Custom-Header-Value\"\n        json = response.json()\n        assert json == {\"hello\": \"world\"}\n\n\n@pytest.mark.fastapi(app=chapter3_response_parameter_02_app)\n@pytest.mark.asyncio\nclass TestResponseParameter02:\n    async def test_get(self, client: httpx.AsyncClient):\n        response = await client.get(\"/\")\n\n        assert response.status_code == status.HTTP_200_OK\n        assert response.cookies[\"cookie-name\"] == \"cookie-value\"\n        json = response.json()\n        assert json == {\"hello\": \"world\"}\n\n\n@pytest.mark.fastapi(app=chapter3_response_parameter_03_app)\n@pytest.mark.asyncio\nclass TestResponseParameter03:\n    @pytest.mark.parametrize(\n        \"id,status_code\", [(1, status.HTTP_200_OK), (2, status.HTTP_201_CREATED)]\n    )\n    async def test_update_or_create(\n        self, client: httpx.AsyncClient, id: int, status_code: int\n    ):\n        payload = {\"title\": \"New title\"}\n        response = await client.put(f\"/posts/{id}\", json=payload)\n\n        assert response.status_code == status_code\n        json = response.json()\n        assert json == payload\n\n\n@pytest.mark.fastapi(app=chapter3_raise_errors_01_app)\n@pytest.mark.asyncio\nclass TestRaiseErrors01:\n    @pytest.mark.parametrize(\n        \"password,password_confirm,status_code,message\",\n        [\n            (\n                \"aa\",\n                \"bb\",\n                status.HTTP_400_BAD_REQUEST,\n                {\"detail\": \"Passwords don't match.\"},\n            ),\n            (\"aa\", \"aa\", status.HTTP_200_OK, {\"message\": \"Passwords match.\"}),\n        ],\n    )\n    async def test_check_password(\n        self,\n        client: httpx.AsyncClient,\n        password: str,\n        password_confirm: str,\n        status_code: int,\n        message: Dict[str, str],\n    ):\n        payload = {\"password\": password, \"password_confirm\": password_confirm}\n        response = await client.post(f\"/password\", json=payload)\n\n        assert response.status_code == status_code\n        json = response.json()\n        assert json == message\n\n\n@pytest.mark.fastapi(app=chapter3_raise_errors_02_app)\n@pytest.mark.asyncio\nclass TestRaiseErrors02:\n    @pytest.mark.parametrize(\n        \"password,password_confirm,status_code,message\",\n        [\n            (\n                \"aa\",\n                \"bb\",\n                status.HTTP_400_BAD_REQUEST,\n                {\n                    \"detail\": {\n                        \"message\": \"Passwords don't match.\",\n                        \"hints\": [\n                            \"Check the caps lock on your keyboard\",\n                            \"Try to make the password visible by clicking on the eye icon to check your typing\",\n                        ],\n                    }\n                },\n            ),\n            (\"aa\", \"aa\", status.HTTP_200_OK, {\"message\": \"Passwords match.\"}),\n        ],\n    )\n    async def test_check_password(\n        self,\n        client: httpx.AsyncClient,\n        password: str,\n        password_confirm: str,\n        status_code: int,\n        message: Dict[str, str],\n    ):\n        payload = {\"password\": password, \"password_confirm\": password_confirm}\n        response = await client.post(f\"/password\", json=payload)\n\n        assert response.status_code == status_code\n        json = response.json()\n        assert json == message\n\n\n@pytest.mark.fastapi(app=chapter3_custom_response_01_app)\n@pytest.mark.asyncio\nclass TestCustomResponse01:\n    async def test_html(self, client: httpx.AsyncClient):\n        response = await client.get(\"/html\")\n\n        assert response.status_code == status.HTTP_200_OK\n        assert response.headers[\"content-type\"] == \"text/html; charset=utf-8\"\n        text = response.text\n        assert text.strip().startswith(\"<html>\")\n\n    async def test_text(self, client: httpx.AsyncClient):\n        response = await client.get(\"/text\")\n\n        assert response.status_code == status.HTTP_200_OK\n        assert response.headers[\"content-type\"] == \"text/plain; charset=utf-8\"\n        text = response.text\n        assert text == \"Hello world!\"\n\n\n@pytest.mark.fastapi(app=chapter3_custom_response_02_app)\n@pytest.mark.asyncio\nclass TestCustomResponse02:\n    async def test_redirect(self, client: httpx.AsyncClient):\n        response = await client.get(\"/redirect\")\n\n        assert response.status_code == status.HTTP_307_TEMPORARY_REDIRECT\n        assert response.headers[\"location\"] == \"/new-url\"\n\n\n@pytest.mark.fastapi(app=chapter3_custom_response_03_app)\n@pytest.mark.asyncio\nclass TestCustomResponse03:\n    async def test_redirect(self, client: httpx.AsyncClient):\n        response = await client.get(\"/redirect\")\n\n        assert response.status_code == status.HTTP_301_MOVED_PERMANENTLY\n        assert response.headers[\"location\"] == \"/new-url\"\n\n\n@pytest.mark.fastapi(app=chapter3_custom_response_04_app)\n@pytest.mark.asyncio\nclass TestCustomResponse04:\n    async def test_cat(self, client: httpx.AsyncClient):\n        response = await client.get(\"/cat\")\n\n        assert response.status_code == status.HTTP_200_OK\n        assert response.headers[\"content-type\"] == \"image/jpeg\"\n        assert response.headers[\"content-length\"] == \"71457\"\n\n\n@pytest.mark.fastapi(app=chapter3_custom_response_05_app)\n@pytest.mark.asyncio\nclass TestCustomResponse05:\n    async def test_xml(self, client: httpx.AsyncClient):\n        response = await client.get(\"/xml\")\n\n        assert response.status_code == status.HTTP_200_OK\n        assert response.headers[\"content-type\"] == \"application/xml\"\n        text = response.text\n        assert text.strip().startswith(\"<?xml\")\n"}
{"type": "test_file", "path": "tests/test_chapter12.py", "content": "import pytest\n\n\ndef test_chapter12_load_digits():\n    from chapter12.chapter12_load_digits import data, targets\n\n    assert data[:, 0].size == targets.size\n\n\ndef test_chapter12_fit_predict():\n    from chapter12.chapter12_fit_predict import accuracy\n\n    assert accuracy == pytest.approx(0.83, rel=1e-2)\n\n\ndef test_chapter12_pipelines():\n    from chapter12.chapter12_pipelines import accuracy\n\n    assert accuracy == pytest.approx(0.83, rel=1e-2)\n\n\ndef test_chapter12_cross_validation():\n    from chapter12.chapter12_cross_validation import score\n\n    assert score.mean() == pytest.approx(0.80, rel=1e-2)\n\n\ndef test_chapter12_gaussian_naive_bayes():\n    from chapter12.chapter12_gaussian_naive_bayes import model\n\n    assert len(model.theta_[0]) == 64\n    assert len(model.sigma_[0]) == 64\n\n\ndef test_chapter12_svm():\n    from chapter12.chapter12_svm import score\n\n    assert score.mean() == pytest.approx(0.96, rel=1e-2)\n\n\ndef test_chapter12_finding_parameters():\n    from chapter12.chapter12_finding_parameters import grid\n\n    assert grid.best_params_ == {\"C\": 10, \"kernel\": \"rbf\"}\n"}
{"type": "test_file", "path": "tests/test_chapter4.py", "content": "from datetime import date\nimport runpy\n\nimport httpx\nimport pytest\nfrom fastapi import status\nfrom pydantic import ValidationError\n\nfrom chapter4.chapter4_working_pydantic_objects_04 import (\n    app as chapter4_working_pydantic_objects_04_app,\n)\nfrom chapter4.chapter4_working_pydantic_objects_05 import (\n    app as chapter4_working_pydantic_objects_05_app,\n    db,\n    PostDB,\n)\n\n\ndef test_chapter4_custom_validation_01():\n    from chapter4.chapter4_custom_validation_01 import Person\n\n    # Invalid birthdate\n    try:\n        Person(first_name=\"John\", last_name=\"Doe\", birthdate=\"1800-01-01\")\n    except ValidationError as e:\n        assert len(e.errors()) == 1\n\n    person = Person(first_name=\"John\", last_name=\"Doe\", birthdate=\"1991-01-01\")\n    assert isinstance(person, Person)\n\n\ndef test_chapter4_custom_validation_02():\n    from chapter4.chapter4_custom_validation_02 import UserRegistration\n\n    # Passwords not matching\n    try:\n        UserRegistration(\n            email=\"jdoe@example.com\", password=\"aa\", password_confirmation=\"bb\"\n        )\n    except ValidationError as e:\n        assert len(e.errors()) == 1\n\n    # Valid\n    user_registration = UserRegistration(\n        email=\"jdoe@example.com\", password=\"aa\", password_confirmation=\"aa\"\n    )\n    assert isinstance(user_registration, UserRegistration)\n\n\ndef test_chapter4_custom_validation_03():\n    from chapter4.chapter4_custom_validation_03 import m\n\n    assert m.values == [1, 2, 3]\n\n\ndef test_chapter4_fields_validation_01():\n    from chapter4.chapter4_fields_validation_01 import Person\n\n    # Invalid first name\n    try:\n        Person(first_name=\"J\", last_name=\"Doe\", age=30)\n    except ValidationError as e:\n        assert len(e.errors()) == 1\n\n    # Invalid age\n    try:\n        Person(first_name=\"John\", last_name=\"Doe\", age=2000)\n    except ValidationError as e:\n        assert len(e.errors()) == 1\n\n    # Valid\n    person = Person(first_name=\"John\", last_name=\"Doe\", age=30)\n    assert person.first_name == \"John\"\n    assert person.last_name == \"Doe\"\n    assert person.age == 30\n\n\ndef test_chapter4_fields_validation_02():\n    from chapter4.chapter4_fields_validation_02 import o1, o2\n\n    assert o1.l == [\"a\", \"b\", \"c\", \"d\"]\n    assert o1.l2 == []\n\n    assert o2.l == [\"a\", \"b\", \"c\"]\n    assert o1.l2 == []\n\n    assert o1.d < o2.d\n\n\ndef test_chapter4_optional_fields_default_values_01():\n    from chapter4.chapter4_optional_fields_default_values_01 import user\n\n    assert user.location is None\n    assert user.subscribed_newsletter is True\n\n\ndef test_chapter4_optional_fields_default_values_02():\n    from chapter4.chapter4_optional_fields_default_values_02 import o1, o2\n\n    assert o1 == o2\n\n\ndef test_chapter4_pydantic_types_01():\n    from chapter4.chapter4_pydantic_types_01 import User\n\n    # Invalid email\n    try:\n        User(email=\"jdoe\", website=\"https://www.example.com\")\n    except ValidationError as e:\n        assert len(e.errors()) == 1\n\n    # Invalid URL\n    try:\n        User(email=\"jdoe@example.com\", website=\"jdoe\")\n    except ValidationError as e:\n        print(str(e))\n\n    # Valid\n    user = User(email=\"jdoe@example.com\", website=\"https://www.example.com\")\n    assert user.email == \"jdoe@example.com\"\n    assert user.website.scheme == \"https\"\n    assert user.website.host == \"www.example.com\"\n\n\ndef test_chapter4_standard_field_types_01():\n    from chapter4.chapter4_standard_field_types_01 import Person, person\n\n    assert isinstance(person, Person)\n\n\ndef test_chapter4_standard_field_types_02():\n    from chapter4.chapter4_standard_field_types_02 import Gender, Person\n\n    # Invalid gender\n    try:\n        Person(\n            first_name=\"John\",\n            last_name=\"Doe\",\n            gender=\"INVALID_VALUE\",\n            birthdate=\"1991-01-01\",\n            interests=[\"travel\", \"sports\"],\n        )\n    except ValidationError as e:\n        assert len(e.errors()) == 1\n\n    # Invalid birthdate\n    try:\n        Person(\n            first_name=\"John\",\n            last_name=\"Doe\",\n            gender=Gender.MALE,\n            birthdate=\"1991-13-42\",\n            interests=[\"travel\", \"sports\"],\n        )\n    except ValidationError as e:\n        assert len(e.errors()) == 1\n\n    # Valid\n    person = Person(\n        first_name=\"John\",\n        last_name=\"Doe\",\n        gender=Gender.MALE,\n        birthdate=\"1991-01-01\",\n        interests=[\"travel\", \"sports\"],\n    )\n    assert person.gender == Gender.MALE\n    assert person.birthdate == date(1991, 1, 1)\n    assert person.interests == [\"travel\", \"sports\"]\n\n\ndef test_chapter4_standard_field_types_03():\n    from chapter4.chapter4_standard_field_types_03 import Address, Gender, Person\n\n    # Invalid address\n    try:\n        Person(\n            first_name=\"John\",\n            last_name=\"Doe\",\n            gender=Gender.MALE,\n            birthdate=\"1991-01-01\",\n            interests=[\"travel\", \"sports\"],\n            address={\n                \"street_address\": \"12 Squirell Street\",\n                \"postal_code\": \"424242\",\n                \"city\": \"Woodtown\",\n                # Missing country\n            },\n        )\n    except ValidationError as e:\n        assert len(e.errors()) == 1\n\n    # Valid\n    person = Person(\n        first_name=\"John\",\n        last_name=\"Doe\",\n        gender=Gender.MALE,\n        birthdate=\"1991-01-01\",\n        interests=[\"travel\", \"sports\"],\n        address={\n            \"street_address\": \"12 Squirell Street\",\n            \"postal_code\": \"424242\",\n            \"city\": \"Woodtown\",\n            \"country\": \"US\",\n        },\n    )\n    assert isinstance(person.address, Address)\n\n\ndef test_chapter4_working_pydantic_objects_01():\n    from chapter4.chapter4_working_pydantic_objects_01 import person_dict\n\n    assert person_dict[\"first_name\"] == \"John\"\n    assert person_dict[\"address\"][\"street_address\"] == \"12 Squirell Street\"\n\n\ndef test_chapter4_working_pydantic_objects_02():\n    from chapter4.chapter4_working_pydantic_objects_02 import (\n        person_include,\n        person_exclude,\n        person_nested_include,\n    )\n\n    assert person_include == {\"first_name\": \"John\", \"last_name\": \"Doe\"}\n\n    assert \"birthdate\" not in person_exclude\n    assert \"interests\" not in person_exclude\n\n    assert person_nested_include == {\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\",\n        \"address\": {\"city\": \"Woodtown\", \"country\": \"US\"},\n    }\n\n\ndef test_chapter4_working_pydantic_objects_03():\n    from chapter4.chapter4_working_pydantic_objects_03 import name_dict\n\n    assert name_dict == {\"first_name\": \"John\", \"last_name\": \"Doe\"}\n\n\n@pytest.mark.fastapi(app=chapter4_working_pydantic_objects_04_app)\n@pytest.mark.asyncio\nclass TestWorkingPydanticObjects04:\n    async def test_invalid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\"/posts\", json={})\n\n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n    async def test_valid_payload(self, client: httpx.AsyncClient):\n        response = await client.post(\"/posts\", json={\"title\": \"Foo\", \"content\": \"Bar\"})\n\n        assert response.status_code == status.HTTP_201_CREATED\n        json = response.json()\n        assert json == {\"id\": 1, \"title\": \"Foo\", \"content\": \"Bar\"}\n\n\n@pytest.mark.fastapi(app=chapter4_working_pydantic_objects_05_app)\n@pytest.mark.asyncio\nclass TestWorkingPydanticObjects05:\n    async def test_not_existing_post(self, client: httpx.AsyncClient):\n        response = await client.patch(\"/posts/1\", json={})\n\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    async def test_valid_payload(self, client: httpx.AsyncClient):\n        db.posts = {1: PostDB(id=1, title=\"Foo\", content=\"Bar\")}\n        response = await client.patch(\"/posts/1\", json={\"title\": \"New title\"})\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert json == {\"id\": 1, \"title\": \"New title\", \"content\": \"Bar\"}\n"}
{"type": "test_file", "path": "tests/test_chapter6_mongodb_relationship.py", "content": "import os\nfrom typing import Any, Dict, Optional\n\nimport httpx\nimport pytest\nimport pytest_asyncio\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom bson import ObjectId\nfrom fastapi import status\n\nfrom chapter6.mongodb_relationship.app import app, get_database\nfrom chapter6.mongodb_relationship.models import CommentDB, PostDB\n\n\nmotor_client = AsyncIOMotorClient(\n    os.getenv(\"MONGODB_CONNECTION_STRING\", \"mongodb://localhost:27017\")\n)\ndatabase_test = motor_client[\"chapter6_mongo_relationship_test\"]\ninitial_posts = [\n    PostDB(\n        title=\"Post 1\",\n        content=\"Content 1\",\n        comments=[\n            CommentDB(content=\"Post 1 Comment 1\"),\n            CommentDB(content=\"Post 1 Comment 2\"),\n            CommentDB(content=\"Post 1 Comment 3\"),\n        ],\n    ),\n    PostDB(title=\"Post 2\", content=\"Content 2\"),\n    PostDB(title=\"Post 3\", content=\"Content 3\"),\n]\nexisting_id = str(initial_posts[0].id)\nnot_existing_id = str(ObjectId())\ninvalid_id = \"aaa\"\n\n\n@pytest_asyncio.fixture(autouse=True, scope=\"module\")\nasync def initialize_database():\n    await database_test[\"posts\"].insert_many(\n        [post.dict(by_alias=True) for post in initial_posts]\n    )\n\n    yield\n\n    await motor_client.drop_database(\"chapter6_mongo_relationship_test\")\n\n\n@pytest.mark.fastapi(\n    app=app, dependency_overrides={get_database: lambda: database_test}\n)\n@pytest.mark.asyncio\nclass TestChapter6MongoDBRelationship:\n    @pytest.mark.parametrize(\n        \"skip,limit,nb_results\", [(None, None, 3), (0, 1, 1), (10, 1, 0)]\n    )\n    async def test_list_posts(\n        self,\n        client: httpx.AsyncClient,\n        skip: Optional[int],\n        limit: Optional[int],\n        nb_results: int,\n    ):\n        params = {}\n        if skip:\n            params[\"skip\"] = skip\n        if limit:\n            params[\"limit\"] = limit\n        response = await client.get(\"/posts\", params=params)\n\n        assert response.status_code == status.HTTP_200_OK\n        json = response.json()\n        assert len(json) == nb_results\n        for post in json:\n            assert \"_id\" in post\n\n    @pytest.mark.parametrize(\n        \"id,status_code,nb_comments\",\n        [\n            (existing_id, status.HTTP_200_OK, 3),\n            (not_existing_id, status.HTTP_404_NOT_FOUND, 0),\n            (invalid_id, status.HTTP_404_NOT_FOUND, 0),\n        ],\n    )\n    async def test_get_post(\n        self, client: httpx.AsyncClient, id: str, status_code: int, nb_comments: int\n    ):\n        response = await client.get(f\"/posts/{id}\")\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_200_OK:\n            json = response.json()\n            assert json[\"_id\"] == id\n            assert len(json[\"comments\"]) == nb_comments\n\n    @pytest.mark.parametrize(\n        \"payload,status_code\",\n        [\n            ({\"title\": \"New post\", \"content\": \"New content\"}, status.HTTP_201_CREATED),\n            ({}, status.HTTP_422_UNPROCESSABLE_ENTITY),\n        ],\n    )\n    async def test_create_post(\n        self, client: httpx.AsyncClient, payload: Dict[str, Any], status_code: int\n    ):\n        response = await client.post(\"/posts\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_201_CREATED:\n            json = response.json()\n            assert \"_id\" in json\n            assert json[\"comments\"] == []\n\n    @pytest.mark.parametrize(\n        \"id,payload,status_code,nb_comments\",\n        [\n            (existing_id, {\"title\": \"Post 1 Updated\"}, status.HTTP_200_OK, 3),\n            (\n                not_existing_id,\n                {\"title\": \"Post 10 Updated\"},\n                status.HTTP_404_NOT_FOUND,\n                0,\n            ),\n            (invalid_id, {\"title\": \"Post 10 Updated\"}, status.HTTP_404_NOT_FOUND, 0),\n        ],\n    )\n    async def test_update_post(\n        self,\n        client: httpx.AsyncClient,\n        id: str,\n        payload: Dict[str, Any],\n        status_code: int,\n        nb_comments: int,\n    ):\n        response = await client.patch(f\"/posts/{id}\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_200_OK:\n            json = response.json()\n            for key in payload:\n                assert json[key] == payload[key]\n            assert len(json[\"comments\"]) == nb_comments\n\n    @pytest.mark.parametrize(\n        \"id,status_code\",\n        [\n            (existing_id, status.HTTP_204_NO_CONTENT),\n            (not_existing_id, status.HTTP_404_NOT_FOUND),\n            (invalid_id, status.HTTP_404_NOT_FOUND),\n        ],\n    )\n    async def test_delete_post(\n        self, client: httpx.AsyncClient, id: str, status_code: int\n    ):\n        response = await client.delete(f\"/posts/{id}\")\n\n        assert response.status_code == status_code\n\n    @pytest.mark.parametrize(\n        \"post_id,payload,status_code\",\n        [\n            (\n                str(initial_posts[1].id),\n                {\"content\": \"New comment\"},\n                status.HTTP_201_CREATED,\n            ),\n            (not_existing_id, {\"content\": \"New comment\"}, status.HTTP_404_NOT_FOUND),\n            (str(initial_posts[1].id), {}, status.HTTP_422_UNPROCESSABLE_ENTITY),\n        ],\n    )\n    async def test_create_comment(\n        self,\n        client: httpx.AsyncClient,\n        post_id: str,\n        payload: Dict[str, Any],\n        status_code: int,\n    ):\n        response = await client.post(f\"/posts/{post_id}/comments\", json=payload)\n\n        assert response.status_code == status_code\n        if status_code == status.HTTP_201_CREATED:\n            json = response.json()\n            assert \"_id\" in json\n            assert len(json[\"comments\"]) == 1\n"}
{"type": "test_file", "path": "tests/test_chapter2.py", "content": "import asyncio\nimport runpy\n\n\ndef test_chapter2_basics_02():\n    from chapter2.chapter2_basics_02 import even\n\n    assert even == [2, 4, 6, 8, 10]\n\n\ndef test_chapter2_basics_03():\n    from chapter2.chapter2_basics_03 import t, q, r\n\n    assert t[0] == 1\n    assert t[1] == 1\n\n    assert q == 10\n    assert r == 2\n\n\ndef test_chapter2_basics_04():\n    from chapter2.chapter2_basics_04 import forward_order_status\n\n    assert forward_order_status({\"status\": \"NEW\"}) == {\"status\": \"IN_PROGRESS\"}\n    assert forward_order_status({\"status\": \"IN_PROGRESS\"}) == {\"status\": \"SHIPPED\"}\n    assert forward_order_status({\"status\": \"SHIPPED\"}) == {\"status\": \"DONE\"}\n\n\ndef test_chapter2_basics_05():\n    from chapter2.chapter2_basics_05 import items\n\n    assert items == [\"A\", \"B\", \"C\", \"A\", \"B\", \"C\", \"A\", \"B\", \"C\"]\n\n\ndef test_chapter2_classes_objects_01():\n    from chapter2.chapter2_classes_objects_01 import c\n\n    assert c.greet(\"John\") == \"Hello, John\"\n\n\ndef test_chapter2_classes_objects_02():\n    from chapter2.chapter2_classes_objects_02 import c\n\n    assert c.default_name == \"Alan\"\n    assert c.greet() == \"Hello, Alan\"\n    assert c.greet(\"John\") == \"Hello, John\"\n\n\ndef test_chapter2_classes_objects_03():\n    from chapter2.chapter2_classes_objects_03 import t\n\n    assert repr(t) == \"Temperature(25, 'C')\"\n    assert str(t) == \"Temperature is 25 °C\"\n\n\ndef test_chapter2_classes_objects_04():\n    from chapter2.chapter2_classes_objects_04 import tc, tf, tf2\n\n    assert tc == tf\n    assert tc < tf2\n\n\ndef test_chapter2_classes_objects_05():\n    from chapter2.chapter2_classes_objects_05 import Counter\n\n    c = Counter()\n    assert c.counter == 0\n    c()\n    assert c.counter == 1\n    c(10)\n    assert c.counter == 11\n\n\ndef test_chapter2_classes_objects_06():\n    from chapter2.chapter2_classes_objects_06 import c\n\n    assert c.f() == \"A\"\n\n\ndef test_chapter2_classes_objects_07():\n    from chapter2.chapter2_classes_objects_07 import c\n\n    assert c.f() == \"Child A\"\n\n\ndef test_chapter2_classes_objects_08():\n    from chapter2.chapter2_classes_objects_08 import c\n\n    assert c.f() == \"A\"\n    assert c.g() == \"B\"\n\n\ndef test_chapter2_classes_objects_09():\n    from chapter2.chapter2_classes_objects_09 import c\n\n    assert c.f() == \"A\"\n\n\ndef test_chapter2_list_comprehensions_01():\n    from chapter2.chapter2_list_comprehensions_01 import even\n\n    assert even == [2, 4, 6, 8, 10]\n\n\ndef test_chapter2_list_comprehensions_02():\n    from chapter2.chapter2_list_comprehensions_02 import random_elements\n\n    assert random_elements == [10, 1, 7, 8, 10]\n\n\ndef test_chapter2_list_comprehensions_03():\n    from chapter2.chapter2_list_comprehensions_03 import random_unique_elements\n\n    assert random_unique_elements == {8, 1, 10, 7}\n\n\ndef test_chapter2_list_comprehensions_04():\n    from chapter2.chapter2_list_comprehensions_04 import random_dictionary\n\n    assert random_dictionary == {0: 10, 1: 1, 2: 7, 3: 8, 4: 10}\n\n\ndef test_chapter2_list_comprehensions_05():\n    from chapter2.chapter2_list_comprehensions_05 import even, even_bis\n\n    assert even == [2, 4, 6, 8, 10]\n    assert even_bis == []\n\n\ndef test_chapter2_list_comprehensions_06():\n    from chapter2.chapter2_list_comprehensions_06 import even\n\n    assert even == [2, 4, 6, 8, 10]\n\n\ndef test_chapter2_list_comprehensions_07():\n    from chapter2.chapter2_list_comprehensions_07 import even\n\n    assert even == [2, 4, 6, 8, 10]\n\n\ndef test_chapter2_type_hints_01():\n    from chapter2.chapter2_type_hints_01 import greeting\n\n    assert greeting(\"John\") == \"Hello, John\"\n\n\ndef test_chapter2_type_hints_04():\n    from chapter2.chapter2_type_hints_04 import greeting\n\n    assert greeting() == \"Hello, Anonymous\"\n\n\ndef test_chapter2_type_hints_05():\n    from chapter2.chapter2_type_hints_05 import greeting\n\n    assert greeting() == \"Hello, Anonymous\"\n\n\ndef test_chapter2_non_assertive(event_loop):\n    asyncio.set_event_loop(event_loop)\n\n    runpy.run_module(\"chapter2.chapter2_asyncio_01\")\n    runpy.run_module(\"chapter2.chapter2_asyncio_02\")\n    runpy.run_module(\"chapter2.chapter2_asyncio_03\")\n\n    runpy.run_module(\"chapter2.chapter2_basics_01\")\n    runpy.run_module(\"chapter2.chapter2_basics_module\")\n\n    runpy.run_module(\"chapter2.chapter2_type_hints_02\")\n    runpy.run_module(\"chapter2.chapter2_type_hints_03\")\n    runpy.run_module(\"chapter2.chapter2_type_hints_06\")\n    runpy.run_module(\"chapter2.chapter2_type_hints_07\")\n    runpy.run_module(\"chapter2.chapter2_type_hints_08\")\n    runpy.run_module(\"chapter2.chapter2_type_hints_09\")\n    runpy.run_module(\"chapter2.chapter2_type_hints_10\")\n"}
{"type": "source_file", "path": "chapter2/chapter2_asyncio_02.py", "content": "import asyncio\n\n\nasync def main():\n    print(\"Hello ...\")\n    await asyncio.sleep(1)\n    print(\"... World!\")\n\n\nasyncio.run(main())\n"}
{"type": "source_file", "path": "chapter10/project/app/settings.py", "content": "from pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    debug: bool = False\n    environment: str\n    database_url: str\n\n    class Config:\n        env_file = \".env\"\n"}
{"type": "source_file", "path": "chapter13/__init__.py", "content": ""}
{"type": "source_file", "path": "chapter10/project/app/models.py", "content": "from datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\nfrom tortoise.models import Model\nfrom tortoise import fields\n\n\nclass PostBase(BaseModel):\n    title: str\n    content: str\n    publication_date: datetime = Field(default_factory=datetime.now)\n\n    class Config:\n        orm_mode = True\n\n\nclass PostPartialUpdate(BaseModel):\n    title: Optional[str] = None\n    content: Optional[str] = None\n\n\nclass PostCreate(PostBase):\n    pass\n\n\nclass PostDB(PostBase):\n    id: int\n\n\nclass PostTortoise(Model):\n    id = fields.IntField(pk=True, generated=True)\n    publication_date = fields.DatetimeField(null=False)\n    title = fields.CharField(max_length=255, null=False)\n    content = fields.TextField(null=False)\n\n    class Meta:\n        table = \"posts\"\n"}
{"type": "source_file", "path": "chapter13/chapter13_load_joblib.py", "content": "import os\nfrom typing import List, Tuple\n\nimport joblib\nfrom sklearn.pipeline import Pipeline\n\n# Load the model\nmodel_file = os.path.join(os.path.dirname(__file__), \"newsgroups_model.joblib\")\nloaded_model: Tuple[Pipeline, List[str]] = joblib.load(model_file)\nmodel, targets = loaded_model\n\n# Run a prediction\np = model.predict([\"computer cpu memory ram\"])\nprint(targets[p[0]])\n"}
{"type": "source_file", "path": "chapter12/chapter12_pipelines.py", "content": "import pandas as pd\nfrom sklearn.datasets import fetch_20newsgroups\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics import accuracy_score, confusion_matrix\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.pipeline import make_pipeline\n\n# Load some categories of newsgroups dataset\ncategories = [\n    \"soc.religion.christian\",\n    \"talk.religion.misc\",\n    \"comp.sys.mac.hardware\",\n    \"sci.crypt\",\n]\nnewsgroups_training = fetch_20newsgroups(\n    subset=\"train\", categories=categories, random_state=0\n)\nnewsgroups_testing = fetch_20newsgroups(\n    subset=\"test\", categories=categories, random_state=0\n)\n\n# Make the pipeline\nmodel = make_pipeline(\n    TfidfVectorizer(),\n    MultinomialNB(),\n)\n\n# Train the model\nmodel.fit(newsgroups_training.data, newsgroups_training.target)\n\n# Run prediction with the testing set\npredicted_targets = model.predict(newsgroups_testing.data)\n\n# Compute the accuracy\naccuracy = accuracy_score(newsgroups_testing.target, predicted_targets)\nprint(accuracy)\n\n# Show the confusion matrix\nconfusion = confusion_matrix(newsgroups_testing.target, predicted_targets)\nconfusion_df = pd.DataFrame(\n    confusion,\n    index=pd.Index(newsgroups_testing.target_names, name=\"True\"),\n    columns=pd.Index(newsgroups_testing.target_names, name=\"Predicted\"),\n)\nprint(confusion_df)\n"}
{"type": "source_file", "path": "chapter11/chapter11_compare_operations.py", "content": "import numpy as np\n\nnp.random.seed(0)  # Set the random seed to make examples reproducible\n\nm = np.random.randint(10, size=1000000)  # An array with a million of elements\n\n\ndef standard_double(array):\n    output = np.empty(array.size)\n    for i in range(array.size):\n        output[i] = array[i] * 2\n    return output\n\n\ndef numpy_double(array):\n    return array * 2\n"}
{"type": "source_file", "path": "chapter12/chapter12_finding_parameters.py", "content": "from sklearn.datasets import load_digits\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.svm import SVC\n\ndigits = load_digits()\n\ndata = digits.data\ntargets = digits.target\n\n# Create the grid of parameters\nparam_grid = {\"C\": [1, 10, 100, 1000], \"kernel\": [\"linear\", \"poly\", \"rbf\", \"sigmoid\"]}\ngrid = GridSearchCV(SVC(), param_grid)\n\ngrid.fit(data, targets)\n\nprint(\"Best params\", grid.best_params_)\nprint(\"Best score\", grid.best_score_)\n"}
{"type": "source_file", "path": "chapter10/project/app/app.py", "content": "from typing import List, Tuple\n\nfrom fastapi import Depends, FastAPI, Query, status\nfrom tortoise.contrib.fastapi import register_tortoise\n\nfrom app.models import (\n    PostDB,\n    PostCreate,\n    PostPartialUpdate,\n    PostTortoise,\n)\nfrom app.settings import Settings\n\nsettings = Settings()\napp = FastAPI()\n\n\nasync def pagination(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=0),\n) -> Tuple[int, int]:\n    capped_limit = min(100, limit)\n    return (skip, capped_limit)\n\n\nasync def get_post_or_404(id: int) -> PostTortoise:\n    return await PostTortoise.get(id=id)\n\n\n@app.get(\"/posts\")\nasync def list_posts(pagination: Tuple[int, int] = Depends(pagination)) -> List[PostDB]:\n    skip, limit = pagination\n    posts = await PostTortoise.all().offset(skip).limit(limit)\n\n    results = [PostDB.from_orm(post) for post in posts]\n\n    return results\n\n\n@app.get(\"/posts/{id}\", response_model=PostDB)\nasync def get_post(post: PostTortoise = Depends(get_post_or_404)) -> PostDB:\n    return PostDB.from_orm(post)\n\n\n@app.post(\"/posts\", response_model=PostDB, status_code=status.HTTP_201_CREATED)\nasync def create_post(post: PostCreate) -> PostDB:\n    post_tortoise = await PostTortoise.create(**post.dict())\n\n    return PostDB.from_orm(post_tortoise)\n\n\n@app.patch(\"/posts/{id}\", response_model=PostDB)\nasync def update_post(\n    post_update: PostPartialUpdate, post: PostTortoise = Depends(get_post_or_404)\n) -> PostDB:\n    post.update_from_dict(post_update.dict(exclude_unset=True))\n    await post.save()\n\n    return PostDB.from_orm(post)\n\n\n@app.delete(\"/posts/{id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_post(post: PostTortoise = Depends(get_post_or_404)):\n    await post.delete()\n\n\n@app.on_event(\"startup\")\nasync def startup():\n    if settings.debug:\n        print(settings)\n\n\nTORTOISE_ORM = {\n    \"connections\": {\"default\": settings.database_url},\n    \"apps\": {\n        \"models\": {\n            \"models\": [\"app.models\"],\n            \"default_connection\": \"default\",\n        },\n    },\n}\n\nregister_tortoise(\n    app,\n    config=TORTOISE_ORM,\n    generate_schemas=True,\n    add_exception_handlers=True,\n)\n"}
{"type": "source_file", "path": "chapter14/websocket_face_detection/app.py", "content": "import asyncio\nfrom typing import List, Tuple\n\nimport cv2\nimport numpy as np\nfrom fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom pydantic import BaseModel\n\n\napp = FastAPI()\ncascade_classifier = cv2.CascadeClassifier()\n\n\nclass Faces(BaseModel):\n    faces: List[Tuple[int, int, int, int]]\n\n\nasync def receive(websocket: WebSocket, queue: asyncio.Queue):\n    bytes = await websocket.receive_bytes()\n    try:\n        queue.put_nowait(bytes)\n    except asyncio.QueueFull:\n        pass\n\n\nasync def detect(websocket: WebSocket, queue: asyncio.Queue):\n    while True:\n        bytes = await queue.get()\n        data = np.frombuffer(bytes, dtype=np.uint8)\n        img = cv2.imdecode(data, 1)\n        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        faces = cascade_classifier.detectMultiScale(gray)\n        if len(faces) > 0:\n            faces_output = Faces(faces=faces.tolist())\n        else:\n            faces_output = Faces(faces=[])\n        await websocket.send_json(faces_output.dict())\n\n\n@app.websocket(\"/face-detection\")\nasync def face_detection(websocket: WebSocket):\n    await websocket.accept()\n    queue: asyncio.Queue = asyncio.Queue(maxsize=10)\n    detect_task = asyncio.create_task(detect(websocket, queue))\n    try:\n        while True:\n            await receive(websocket, queue)\n    except WebSocketDisconnect:\n        detect_task.cancel()\n        await websocket.close()\n\n\n@app.on_event(\"startup\")\nasync def startup():\n    cascade_classifier.load(\n        cv2.data.haarcascades + \"haarcascade_frontalface_default.xml\"\n    )\n"}
{"type": "source_file", "path": "chapter12/chapter12_gaussian_naive_bayes.py", "content": "from sklearn.datasets import load_digits\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.naive_bayes import GaussianNB\n\ndigits = load_digits()\n\ndata = digits.data\ntargets = digits.target\n\n# Split into training and testing sets\ntraining_data, testing_data, training_targets, testing_targets = train_test_split(\n    data, targets, random_state=0\n)\n\n# Train the model\nmodel = GaussianNB()\nmodel.fit(training_data, training_targets)\n\n# Print mean and standard deviation of digit zero\nprint(\"Mean of each pixel for digit zero\")\nprint(model.theta_[0])\n\nprint(\"Standard deviation of each pixel for digit zero\")\nprint(model.sigma_[0])\n"}
{"type": "source_file", "path": "chapter2/chapter2_asyncio_01.py", "content": "with open(__file__) as f:\n    data = f.read()\n# The program will block here until the data has been read\nprint(data)\n"}
{"type": "source_file", "path": "chapter10/project/app/__init__.py", "content": ""}
{"type": "source_file", "path": "chapter14/websocket_face_detection/__init__.py", "content": ""}
{"type": "source_file", "path": "chapter13/chapter13_caching.py", "content": "import os\nfrom typing import List, Optional, Tuple\n\nimport joblib\nfrom fastapi import FastAPI, Depends, status\nfrom joblib import memory\nfrom pydantic import BaseModel\nfrom sklearn.pipeline import Pipeline\n\n\nclass PredictionInput(BaseModel):\n    text: str\n\n\nclass PredictionOutput(BaseModel):\n    category: str\n\n\nmemory = joblib.Memory(location=\"cache.joblib\")\n\n\n@memory.cache(ignore=[\"model\"])\ndef predict(model: Pipeline, text: str) -> int:\n    prediction = model.predict([text])\n    return prediction[0]\n\n\nclass NewsgroupsModel:\n    model: Optional[Pipeline]\n    targets: Optional[List[str]]\n\n    def load_model(self):\n        \"\"\"Loads the model\"\"\"\n        model_file = os.path.join(os.path.dirname(__file__), \"newsgroups_model.joblib\")\n        loaded_model: Tuple[Pipeline, List[str]] = joblib.load(model_file)\n        model, targets = loaded_model\n        self.model = model\n        self.targets = targets\n\n    def predict(self, input: PredictionInput) -> PredictionOutput:\n        \"\"\"Runs a prediction\"\"\"\n        if not self.model or not self.targets:\n            raise RuntimeError(\"Model is not loaded\")\n        prediction = predict(self.model, input.text)\n        category = self.targets[prediction]\n        return PredictionOutput(category=category)\n\n\napp = FastAPI()\nnewgroups_model = NewsgroupsModel()\n\n\n@app.post(\"/prediction\")\ndef prediction(\n    output: PredictionOutput = Depends(newgroups_model.predict),\n) -> PredictionOutput:\n    return output\n\n\n@app.delete(\"/cache\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_cache():\n    memory.clear()\n\n\n@app.on_event(\"startup\")\nasync def startup():\n    newgroups_model.load_model()\n"}
{"type": "source_file", "path": "chapter12/chapter12_fit_predict.py", "content": "from sklearn.datasets import load_digits\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.naive_bayes import GaussianNB\n\ndigits = load_digits()\n\ndata = digits.data\ntargets = digits.target\n\n# Split into training and testing sets\ntraining_data, testing_data, training_targets, testing_targets = train_test_split(\n    data, targets, random_state=0\n)\n\n# Train the model\nmodel = GaussianNB()\nmodel.fit(training_data, training_targets)\n\n# Run prediction with the testing set\npredicted_targets = model.predict(testing_data)\n\n# Compute the accuracy\naccuracy = accuracy_score(testing_targets, predicted_targets)\nprint(accuracy)\n"}
{"type": "source_file", "path": "chapter14/chapter14_api.py", "content": "from typing import List, Tuple\n\nimport cv2\nimport numpy as np\nfrom fastapi import FastAPI, File, UploadFile\nfrom pydantic import BaseModel\n\n\napp = FastAPI()\ncascade_classifier = cv2.CascadeClassifier()\n\n\nclass Faces(BaseModel):\n    faces: List[Tuple[int, int, int, int]]\n\n\n@app.post(\"/face-detection\", response_model=Faces)\nasync def face_detection(image: UploadFile = File(...)) -> Faces:\n    data = np.fromfile(image.file, dtype=np.uint8)\n    image = cv2.imdecode(data, cv2.IMREAD_UNCHANGED)\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    faces = cascade_classifier.detectMultiScale(gray)\n    if len(faces) > 0:\n        faces_output = Faces(faces=faces.tolist())\n    else:\n        faces_output = Faces(faces=[])\n    return faces_output\n\n\n@app.on_event(\"startup\")\nasync def startup():\n    cascade_classifier.load(\n        cv2.data.haarcascades + \"haarcascade_frontalface_default.xml\"\n    )\n"}
{"type": "source_file", "path": "chapter2/__init__.py", "content": ""}
{"type": "source_file", "path": "chapter11/__init__.py", "content": ""}
{"type": "source_file", "path": "chapter12/chapter12_svm.py", "content": "from sklearn.datasets import load_digits\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.svm import SVC\n\ndigits = load_digits()\n\ndata = digits.data\ntargets = digits.target\n\n# Create the model\nmodel = SVC()\n\n# Run cross-validation\nscore = cross_val_score(model, data, targets)\n\nprint(score)\nprint(score.mean())\n"}
{"type": "source_file", "path": "chapter13/chapter13_dump_joblib.py", "content": "import joblib\nfrom sklearn.datasets import fetch_20newsgroups\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.pipeline import make_pipeline\n\n# Load some categories of newsgroups dataset\ncategories = [\n    \"soc.religion.christian\",\n    \"talk.religion.misc\",\n    \"comp.sys.mac.hardware\",\n    \"sci.crypt\",\n]\nnewsgroups_training = fetch_20newsgroups(\n    subset=\"train\", categories=categories, random_state=0\n)\nnewsgroups_testing = fetch_20newsgroups(\n    subset=\"test\", categories=categories, random_state=0\n)\n\n# Make the pipeline\nmodel = make_pipeline(\n    TfidfVectorizer(),\n    MultinomialNB(),\n)\n\n# Train the model\nmodel.fit(newsgroups_training.data, newsgroups_training.target)\n\n# Serialize the model and the target names\nmodel_file = \"newsgroups_model.joblib\"\nmodel_targets_tuple = (model, newsgroups_training.target_names)\njoblib.dump(model_targets_tuple, model_file)\n"}
{"type": "source_file", "path": "chapter12/__init__.py", "content": ""}
{"type": "source_file", "path": "chapter12/chapter12_cross_validation.py", "content": "from sklearn.datasets import load_digits\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.naive_bayes import GaussianNB\n\ndigits = load_digits()\n\ndata = digits.data\ntargets = digits.target\n\n# Create the model\nmodel = GaussianNB()\n\n# Run cross-validation\nscore = cross_val_score(model, data, targets)\n\nprint(score)\nprint(score.mean())\n"}
{"type": "source_file", "path": "chapter14/__init__.py", "content": ""}
{"type": "source_file", "path": "chapter13/chapter13_async_not_async.py", "content": "import time\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/fast\")\nasync def fast():\n    return {\"endpoint\": \"fast\"}\n\n\n@app.get(\"/slow-async\")\nasync def slow_async():\n    \"\"\"Runs in the main process\"\"\"\n    time.sleep(10)  # Blocking sync operation\n    return {\"endpoint\": \"slow-async\"}\n\n\n@app.get(\"/slow-sync\")\ndef slow_sync():\n    \"\"\"Runs in a thread\"\"\"\n    time.sleep(10)  # Blocking sync operation\n    return {\"endpoint\": \"slow-sync\"}\n"}
{"type": "source_file", "path": "chapter13/chapter13_prediction_endpoint.py", "content": "import os\nfrom typing import List, Optional, Tuple\n\nimport joblib\nfrom fastapi import FastAPI, Depends\nfrom pydantic import BaseModel\nfrom sklearn.pipeline import Pipeline\n\n\nclass PredictionInput(BaseModel):\n    text: str\n\n\nclass PredictionOutput(BaseModel):\n    category: str\n\n\nclass NewsgroupsModel:\n    model: Optional[Pipeline]\n    targets: Optional[List[str]]\n\n    def load_model(self):\n        \"\"\"Loads the model\"\"\"\n        model_file = os.path.join(os.path.dirname(__file__), \"newsgroups_model.joblib\")\n        loaded_model: Tuple[Pipeline, List[str]] = joblib.load(model_file)\n        model, targets = loaded_model\n        self.model = model\n        self.targets = targets\n\n    async def predict(self, input: PredictionInput) -> PredictionOutput:\n        \"\"\"Runs a prediction\"\"\"\n        if not self.model or not self.targets:\n            raise RuntimeError(\"Model is not loaded\")\n        prediction = self.model.predict([input.text])\n        category = self.targets[prediction[0]]\n        return PredictionOutput(category=category)\n\n\napp = FastAPI()\nnewgroups_model = NewsgroupsModel()\n\n\n@app.post(\"/prediction\")\nasync def prediction(\n    output: PredictionOutput = Depends(newgroups_model.predict),\n) -> PredictionOutput:\n    return output\n\n\n@app.on_event(\"startup\")\nasync def startup():\n    newgroups_model.load_model()\n"}
{"type": "source_file", "path": "chapter14/chapter14_opencv.py", "content": "import cv2\n\n# Load the trained model\nface_cascade = cv2.CascadeClassifier(\n    cv2.data.haarcascades + \"haarcascade_frontalface_default.xml\"\n)\n\n# You may need to change the index depending on your computer and camera\nvideo_capture = cv2.VideoCapture(1)\n\nwhile True:\n    # Get an image frame\n    ret, frame = video_capture.read()\n\n    # Convert it to grayscale and run detection\n    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n    faces = face_cascade.detectMultiScale(gray)\n\n    # Draw a rectangle around the faces\n    for x, y, w, h in faces:\n        cv2.rectangle(\n            img=frame,\n            pt1=(x, y),\n            pt2=(x + w, y + h),\n            color=(0, 255, 0),\n            thickness=2,\n        )\n\n    # Display the resulting frame\n    cv2.imshow(\"Chapter 14 - OpenCV\", frame)\n\n    # Break when key \"q\" is pressed\n    if cv2.waitKey(1) == ord(\"q\"):\n        break\n\nvideo_capture.release()\ncv2.destroyAllWindows()\n"}
{"type": "source_file", "path": "chapter2/chapter2_asyncio_03.py", "content": "import asyncio\n\n\nasync def printer(name: str, times: int) -> None:\n    for i in range(times):\n        print(name)\n        await asyncio.sleep(1)\n\n\nasync def main():\n    await asyncio.gather(\n        printer(\"A\", 3),\n        printer(\"B\", 3),\n    )\n\n\nasyncio.run(main())\n"}
{"type": "source_file", "path": "chapter2/chapter2_classes_objects_04.py", "content": "class Temperature:\n    def __init__(self, value, scale):\n        self.value = value\n        self.scale = scale\n        if scale == \"C\":\n            self.value_kelvin = value + 273.15\n        elif scale == \"F\":\n            self.value_kelvin = (value - 32) * 5 / 9 + 273.15\n\n    def __repr__(self):\n        return f\"Temperature({self.value}, {self.scale!r})\"\n\n    def __str__(self):\n        return f\"Temperature is {self.value} °{self.scale}\"\n\n    def __eq__(self, other):\n        return self.value_kelvin == other.value_kelvin\n\n    def __lt__(self, other):\n        return self.value_kelvin < other.value_kelvin\n\n\ntc = Temperature(25, \"C\")\ntf = Temperature(77, \"F\")\ntf2 = Temperature(100, \"F\")\nprint(tc == tf)  # True\nprint(tc < tf2)  # True\n"}
{"type": "source_file", "path": "chapter2/chapter2_classes_objects_06.py", "content": "class A:\n    def f(self):\n        return \"A\"\n\n\nclass Child(A):\n    pass\n\n\nc = Child()\nprint(c.f())  # \"A\"\n"}
{"type": "source_file", "path": "chapter2/chapter2_classes_objects_02.py", "content": "class Greetings:\n    def __init__(self, default_name):\n        self.default_name = default_name\n\n    def greet(self, name=None):\n        return f\"Hello, {name if name else self.default_name}\"\n\n\nc = Greetings(\"Alan\")\nprint(c.default_name)  # \"Alan\"\nprint(c.greet())  # \"Hello, Alan\"\nprint(c.greet(\"John\"))  # \"Hello, John\"\n"}
{"type": "source_file", "path": "chapter2/chapter2_classes_objects_05.py", "content": "class Counter:\n    def __init__(self):\n        self.counter = 0\n\n    def __call__(self, inc=1):\n        self.counter += inc\n\n\nc = Counter()\nprint(c.counter)  # 0\nc()\nprint(c.counter)  # 1\nc(10)\nprint(c.counter)  # 11\n"}
{"type": "source_file", "path": "chapter2/chapter2_classes_objects_03.py", "content": "class Temperature:\n    def __init__(self, value, scale):\n        self.value = value\n        self.scale = scale\n\n    def __repr__(self):\n        return f\"Temperature({self.value}, {self.scale!r})\"\n\n    def __str__(self):\n        return f\"Temperature is {self.value} °{self.scale}\"\n\n\nt = Temperature(25, \"C\")\nprint(repr(t))  # \"Temperature(25, 'C')\"\nprint(str(t))  # \"Temperature is 25 °C\"\nprint(t)\n"}
{"type": "source_file", "path": "chapter2/chapter2_classes_objects_07.py", "content": "class A:\n    def f(self):\n        return \"A\"\n\n\nclass Child(A):\n    def f(self):\n        parent_result = super().f()\n        return f\"Child {parent_result}\"\n\n\nc = Child()\nprint(c.f())  # \"Child A\"\n"}
{"type": "source_file", "path": "chapter2/chapter2_basics_02.py", "content": "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven = []\n\nfor number in numbers:\n    if number % 2 == 0:\n        even.append(number)\n\nprint(even)  # [2, 4, 6, 8, 10]\n"}
{"type": "source_file", "path": "chapter2/chapter2_classes_objects_01.py", "content": "class Greetings:\n    def greet(self, name):\n        return f\"Hello, {name}\"\n\n\nc = Greetings()\nprint(c.greet(\"John\"))  # \"Hello, John\"\n"}
{"type": "source_file", "path": "chapter2/chapter2_basics_05.py", "content": "def retrieve_page(page):\n    if page > 3:\n        return {\"next_page\": None, \"items\": []}\n    return {\"next_page\": page + 1, \"items\": [\"A\", \"B\", \"C\"]}\n\n\nitems = []\npage = 1\nwhile page is not None:\n    page_result = retrieve_page(page)\n    items += page_result[\"items\"]\n    page = page_result[\"next_page\"]\n\n\nprint(items)  # [\"A\", \"B\", \"C\", \"A\", \"B\", \"C\", \"A\", \"B\", \"C\"]\n"}
{"type": "source_file", "path": "chapter2/chapter2_basics_module.py", "content": "def module_function():\n    return \"Hello world\"\n\n\nprint(\"Module is loaded\")\n"}
{"type": "source_file", "path": "chapter2/chapter2_basics_04.py", "content": "def forward_order_status(order):\n    if order[\"status\"] == \"NEW\":\n        order[\"status\"] = \"IN_PROGRESS\"\n    elif order[\"status\"] == \"IN_PROGRESS\":\n        order[\"status\"] = \"SHIPPED\"\n    else:\n        order[\"status\"] = \"DONE\"\n    return order\n\n\nprint(forward_order_status({\"status\": \"NEW\"}))  # {\"status\": \"IN_PROGRESS\"}\nprint(forward_order_status({\"status\": \"IN_PROGRESS\"}))  # {\"status\": \"SHIPPED\"}\nprint(forward_order_status({\"status\": \"SHIPPED\"}))  # {\"status\": \"DONE\"}\n"}
{"type": "source_file", "path": "chapter12/chapter12_load_digits.py", "content": "from sklearn.datasets import load_digits\n\ndigits = load_digits()\n\ndata = digits.data\ntargets = digits.target\n\nprint(data[0].reshape((8, 8)))  # First handwritten digit 8 x 8 matrix\nprint(targets[0])  # Label of first handwritten digit\n"}
{"type": "source_file", "path": "chapter2/chapter2_basics_03.py", "content": "def euclidean_division(dividend, divisor):\n    quotient = dividend // divisor\n    remainder = dividend % divisor\n    return (quotient, remainder)\n\n\nt = euclidean_division(3, 2)\nprint(t[0])  # 1\nprint(t[1])  # 1\n\nq, r = euclidean_division(42, 4)\nprint(q)  # 10\nprint(r)  # 2\n"}
{"type": "source_file", "path": "chapter2/chapter2_basics_01.py", "content": "print(\"Hello world!\")\nx = 100\nprint(f\"Double of {x} is {x * 2}\")\n"}
{"type": "source_file", "path": "chapter2/chapter2_list_comprehensions_03.py", "content": "from random import randint, seed\n\nseed(10)  # Set random seed to make examples reproducible\nrandom_unique_elements = {randint(1, 10) for i in range(5)}\nprint(random_unique_elements)  # {8, 1, 10, 7}\n"}
{"type": "source_file", "path": "chapter2/chapter2_classes_objects_08.py", "content": "class A:\n    def f(self):\n        return \"A\"\n\n\nclass B:\n    def g(self):\n        return \"B\"\n\n\nclass Child(A, B):\n    pass\n\n\nc = Child()\nprint(c.f())  # \"A\"\nprint(c.g())  # \"B\"\n"}
{"type": "source_file", "path": "chapter2/chapter2_list_comprehensions_01.py", "content": "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven = [number for number in numbers if number % 2 == 0]\nprint(even)  # [2, 4, 6, 8, 10]\n"}
{"type": "source_file", "path": "chapter2/chapter2_list_comprehensions_05.py", "content": "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_generator = (number for number in numbers if number % 2 == 0)\neven = list(even_generator)\neven_bis = list(even_generator)\n\nprint(even)  # [2, 4, 6, 8, 10]\nprint(even_bis)  # []\n"}
{"type": "source_file", "path": "chapter2/chapter2_list_comprehensions_02.py", "content": "from random import randint, seed\n\nseed(10)  # Set random seed to make examples reproducible\nrandom_elements = [randint(1, 10) for i in range(5)]\nprint(random_elements)  # [10, 1, 7, 8, 10]\n"}
{"type": "source_file", "path": "chapter2/chapter2_list_comprehensions_04.py", "content": "from random import randint, seed\n\nseed(10)  # Set random seed to make examples reproducible\nrandom_dictionary = {i: randint(1, 10) for i in range(5)}\nprint(random_dictionary)  # {0: 10, 1: 1, 2: 7, 3: 8, 4: 10}\n"}
{"type": "source_file", "path": "chapter2/chapter2_list_comprehensions_06.py", "content": "def even_numbers(max):\n    for i in range(2, max + 1):\n        if i % 2 == 0:\n            yield i\n\n\neven = list(even_numbers(10))\nprint(even)  # [2, 4, 6, 8, 10]\n"}
{"type": "source_file", "path": "chapter2/chapter2_classes_objects_09.py", "content": "class A:\n    def f(self):\n        return \"A\"\n\n\nclass B:\n    def f(self):\n        return \"B\"\n\n\nclass Child(A, B):\n    pass\n\n\nc = Child()\nprint(c.f())  # \"A\"\n"}

{"repo_info": {"repo_name": "arcade", "repo_owner": "IBM", "repo_url": "https://github.com/IBM/arcade"}}
{"type": "test_file", "path": "tests/test_cos_oem_data_access.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pytest\nfrom arcade.data_access.cos import TestBucket\nfrom arcade.data_access.cos.oem import COSOEMData\n\n\n@pytest.fixture\ndef oem_data():\n    bucket = TestBucket()\n    cos_oem = COSOEMData(bucket)\n    return cos_oem\n\n\ndef test_latest_date(oem_data):\n    assert oem_data.date == '20201124'\n\n\ndef test_set_date(oem_data):\n    oem_data.get_oem_data_from_cos(date='20201121')\n    iss_data = oem_data.get('25544')\n    assert iss_data.creation_date.startswith('2020-11-21')\n\n\ndef test_load_oem_data(oem_data):\n    oem_data.get_oem_data_from_cos()\n    iss_data = oem_data.get('25544')\n    assert iss_data.object_name == 'ISS (ZARYA)'\n\n\ndef test_handle_no_data(oem_data):\n    oem_data.get_oem_data_from_cos(aso_ids=['12345'])\n    assert not oem_data.get('12345')\n"}
{"type": "source_file", "path": "arcade/__init__.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"}
{"type": "source_file", "path": "arcade/importers/__init__.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"}
{"type": "source_file", "path": "arcade/importers/cos_oem/cos_oem.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport re\nimport logging\nfrom typing import List, IO, Optional, Dict, Sequence, Union\nimport arcade.models.cos as cos\nimport arcade.models.graph as graph\n\nlogging.basicConfig(level=os.environ.get(\"LOGLEVEL\", \"INFO\"))\nlogger = logging.getLogger(__name__)\n\n\nEphemerisLine = Dict[str, Union[str, List[float]]]\nOEMData = Dict[str, Union[str, List[EphemerisLine]]]\n\n\nclass BaseOEMCOSImporter:\n    \"\"\"A base class for importing orbit ephemeris messages (OEM) from cloud\n    object storage (COS).\n\n    :param oem_bucket: The COS bucket where the OEM files are stored\n    :param data_source_name: The name of the data source node in the graph\n    :param oem_file_fmt: A regex for the file names that pertain to the\n       particular data source\n    :param data_source_public: Whether or not all users should have access\n        to this data source\n    \"\"\"\n    def __init__(self,\n                 oem_bucket: cos.COSBucket,\n                 data_source_name: str,\n                 oem_file_fmt: str,\n                 data_source_public: bool = True) -> None:\n        self.name = data_source_name\n        self.oem_bucket = oem_bucket\n        self.oem_file_fmt = oem_file_fmt\n        self.bucket_node = self._get_bucket_node()\n        self.data_source_node = graph.DataSource.get_or_create(\n            {\n                'name': self.name,\n                'public': data_source_public\n            }\n        )[0]\n\n    def _get_bucket_node(self) -> graph.COSBucket:\n        \"\"\"Gets or creates a neo4j node representing the COS bucket where the\n        OEM files are stored.\n\n        :return: The COS bucket node\n        \"\"\"\n        bucket_node: Optional[graph.COSBucket]\n        bucket_node = graph.COSBucket.nodes.first_or_none(\n            name=self.oem_bucket.name\n        )\n        if bucket_node:\n            return bucket_node\n        else:\n            new_bucket_node = graph.COSBucket(name=self.oem_bucket.name)\n            new_bucket_node.save()\n            return new_bucket_node\n\n    def _get_files(self) -> Sequence[str]:\n        \"\"\"Gets the objects in the bucket that are the OEM files for this\n        particular data source.\n\n        :return: A list of all of the OEM file names.\n        \"\"\"\n        all_files = self.oem_bucket.list_file_names()\n        file_fmt = re.compile(self.oem_file_fmt)\n        files = [f for f in all_files if file_fmt.search(f)]\n        return files\n\n    def _get_aso_node(self,\n                      oem_data: OEMData,\n                      aso_id: str) -> graph.SpaceObject:\n        \"\"\"Finds or creates a SpaceObject node in the graph.\n        :param oem_data:  Data from the orbit ephemeris message that is used to\n            create a SpaceObject node if one is not found\n        :param aso_id: The ID of the ASO to find in the graph\n        :return: A SpaceObject neo4j node instance\n        \"\"\"\n        aso_node = graph.SpaceObject.find_one(aso_id=aso_id)\n        if aso_node:\n            return aso_node\n        else:\n            new_aso_node = graph.SpaceObject(\n                aso_id=aso_id,\n                norad_id=aso_id,\n                cospar_id=oem_data.get('object_id'),\n                name=oem_data.get('object_name')\n            )\n            new_aso_node.save()\n            return new_aso_node\n\n    def _get_cos_object_node(self, object_name: str) -> graph.COSObject:\n        \"\"\"Gets or creates the node in the graph representing the cloud object\n        storage object\n        :param object_name: The name of the COS object in the instance's OEM\n            bucket\n        :return: The ne4j COS object node instance\n        \"\"\"\n        object_node: Optional[graph.COSObject]\n        object_node = self.bucket_node.objects \\\n                          .filter(name=object_name) \\\n                          .first_or_none()\n        if object_node:\n            return object_node\n        else:\n            new_object_node = graph.COSObject(name=object_name, imported=False)\n            new_object_node.save()\n            new_object_node.bucket.connect(self.bucket_node)\n            return new_object_node\n\n    def _save_oem(self,\n                  oem_data: OEMData,\n                  aso_id: str,\n                  object_node: graph.COSObject) -> None:\n        \"\"\"Saves the orbit ephemeris message in the graph.\n\n        :param oem_data: The data in the orbit ephemeris message\n        :param aso_id: The ID of the space object the OEM pertains to\n        :param object_node: The node in the graph representing the COS object\n           the OEM is stored in\n        \"\"\"\n        aso_node = self._get_aso_node(oem_data, aso_id)\n        # Clean out old OEM messages attached to the ASO node\n        oem_date = oem_data['stop_time']\n        old_oems = [oem for oem in aso_node.ephemeris_messages.all()\n                    if self.data_source_node in oem.from_data_source.all()]\n        for old_oem in old_oems:\n            if old_oem.stop_time < oem_date:\n                old_oem.delete()\n            else:\n                return None\n        # Create a new OEM node\n        oem_node = graph.OrbitEphemerisMessage(**oem_data)\n        oem_node.save()\n        # Link the OEM node to the ASO, data source, and COS object nodes\n        oem_node.from_data_source.connect(self.data_source_node)\n        oem_node.in_cos_object.connect(object_node)\n        aso_node.ephemeris_messages.connect(oem_node)\n\n    def _process_fileobj(self,\n                         fileobj: IO[bytes],\n                         object_node: graph.COSObject) -> None:\n        \"\"\"A function that subclasses need to implement that parses and stores\n        the OEM data contained in the passed `fileobj`.\"\"\"\n        raise NotImplementedError\n\n    def run(self) -> None:\n        \"\"\"Fetches, parses, and stores OEM data from the cloud object storage\n        bucket.\n        \"\"\"\n        logger.info(f'Starting import for {self.name}...')\n        files = self._get_files()\n        for f in files:\n            object_node = self._get_cos_object_node(f)\n            if object_node.imported:\n                continue\n            logger.info(f'Fetching file {f} from COS...')\n            fileobj = self.oem_bucket.download_fileobj(f)\n            try:\n                if not fileobj:\n                    continue\n                logger.info(f'Processing file {f}...')\n                self._process_fileobj(fileobj, object_node)\n                object_node.imported = True\n                object_node.save()\n            except Exception as e:\n                logger.error(f'Could not process file {f}, Error: {e}')\n        logger.info(f'Finished import for {self.name}...')\n"}
{"type": "source_file", "path": "arcade/importers/cos_oem/__init__.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"}
{"type": "source_file", "path": "arcade/api.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\nimport neomodel  # type: ignore\nfrom typing import List, Optional\nfrom pydantic import BaseSettings\nfrom fastapi import FastAPI, Depends\nfrom fastapi.responses import RedirectResponse\nfrom fastapi_users import FastAPIUsers\nfrom fastapi_users.authentication import JWTAuthentication\nimport arcade.models.graph as graph\nimport arcade.models.api as models\n\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n# Setup environment settings\nclass APISettings(BaseSettings):\n    neo4j_url: str\n    jwt_secret: str\n\n\nsettings = APISettings()\n\n# Setup the database connection\nneomodel.config.DATABASE_URL = settings.neo4j_url\n\n# Tell fastpai_users how to interact with user data\nuser_db = graph.FastAPIUserDBAdapter(models.UserDB)\n\napi_desc = ('The Advanced Research Collaboration and Application Development '\n            'Environment (ARCADE) provides a unified and coherent API for '\n            'accessing, analyzing, and extending a diverse set of derived '\n            'data products concerning anthropogenic space objects.')\napp = FastAPI(title='ARCADE', description=api_desc)\n\n\njwt_authentication = JWTAuthentication(\n    secret=settings.jwt_secret,\n    lifetime_seconds=3600,\n    tokenUrl=\"auth/jwt/login\"\n)\n\n# Setup fastapi_users to handle user CRUD, authentication, and authorization\nfastapi_users = FastAPIUsers(\n    user_db,\n    [jwt_authentication],\n    models.User,\n    models.UserCreate,\n    models.UserUpdate,\n    models.UserDB\n)\n\n# Add the router for users to get JWTs\napp.include_router(\n    fastapi_users.get_auth_router(jwt_authentication),\n    prefix=\"/auth/jwt\",\n    tags=[\"Authentication\"]\n)\n\n# Add the router that provides the user registration endpoint\napp.include_router(\n    fastapi_users.get_register_router(),\n    prefix=\"/auth\",\n    tags=[\"Authentication\"],\n    include_in_schema=False\n)\n\n# Helper functions that gets the user based on the JWT passed to the endpoint\ncurrent_active_user = fastapi_users.current_user(active=True)\ncurrent_super_user = fastapi_users.current_user(active=True, superuser=True)\n\n\n@app.get('/',\n         response_class=RedirectResponse,\n         include_in_schema=False)\nasync def redirect_to_project() -> str:\n    \"\"\"Redirects the root path to the project website\"\"\"\n    return 'https://ibm.github.io/arcade'\n\n\n@app.get('/user_reports',\n         response_model=List[models.UserReport],\n         include_in_schema=False)\nasync def get_user_reports(user: models.User = Depends(current_super_user)\n                           ) -> List[models.UserReport]:\n    \"\"\"Returns summary statistics for all users\"\"\"\n    report_query = \"\"\"MATCH (u:User)-[r:accessed]->()\n                      RETURN u.email AS email, count(r) AS access_count\"\"\"\n    raw_report, _ = neomodel.db.cypher_query(report_query)\n    report_rows = [models.UserReport(email=row[0], access_count=row[1])\n                   for row in raw_report]\n    return report_rows\n\n\n@app.get('/asos',\n         response_model=List[models.ASO],\n         tags=['ARCADE Endpoints'])\nasync def get_asos(user: models.User = Depends(current_active_user)\n                   ) -> List[models.ASO]:\n    \"\"\"Returns information on all the anthropogenic space objects (ASOs) that\n    ARCADE knows about.\n    \"\"\"\n    aso_nodes = graph.SpaceObject.nodes.all()\n    asos = [models.ASO.from_orm(n) for n in aso_nodes]\n    return asos\n\n\n@app.get('/asos/{aso_id}',\n         response_model=models.ASO,\n         tags=['ARCADE Endpoints'])\nasync def get_aso(aso_id: str,\n                  user: models.User = Depends(current_active_user)\n                  ) -> Optional[models.ASO]:\n    \"\"\"Returns information about the ASO matching the passed ASO ID.\"\"\"\n    aso_node = graph.SpaceObject.find_one(aso_id=aso_id)\n    if not aso_node:\n        return None\n    aso = models.ASO.from_orm(aso_node)\n    return aso\n\n\n@app.get('/ephemeris/{aso_id}',\n         response_model=List[models.OrbitEphemerisMessage],\n         tags=['ARCADE Endpoints'])\nasync def get_ephemeris(aso_id: str,\n                        user: models.User = Depends(current_active_user)\n                        ) -> List[models.OrbitEphemerisMessage]:\n    \"\"\"Provides the most up-to-date ephemeris data for the given ASO\"\"\"\n    oem_nodes = graph.SpaceObject.get_latest_oems(aso_id)\n    if not oem_nodes:\n        return []\n    user_node = graph.User.find_one(uid=str(user.id))\n    if not user_node:\n        return []\n\n    oems = []\n    for oem_node in oem_nodes:\n        if not user_node.can_access(oem_node):\n            continue\n        oem = models.OrbitEphemerisMessage.from_orm(oem_node)\n        user_node.accessed.connect(oem_node, {'endpoint': '/ephemeris'})\n        oems.append(oem)\n\n    return oems\n\n\n@app.get('/interpolate/{aso_id}',\n         response_model=List[models.OrbitEphemerisMessage],\n         tags=['ARCADE Endpoints'])\nasync def get_interpolation(aso_id: str,\n                            step_size: float = 60.0,\n                            user: models.User = Depends(current_active_user)\n                            ) -> List[models.OrbitEphemerisMessage]:\n    \"\"\"Interpolates the ephemeris data for given ASP based on the step\n    size (seconds).\"\"\"\n    oem_nodes = graph.SpaceObject.get_latest_oems(aso_id)\n    if not oem_nodes:\n        return []\n    user_node = graph.User.find_one(uid=str(user.id))\n    if not user_node:\n        return []\n\n    interp_oems = []\n    for oem_node in oem_nodes:\n        if not user_node.can_access(oem_node):\n            continue\n        oem = models.OrbitEphemerisMessage.from_orm(oem_node)\n        interp_oem = oem.interpolate(step_size=step_size)\n        user_node.accessed.connect(oem_node, {'endpoint': '/interpolate'})\n        interp_oems.append(interp_oem)\n\n    return interp_oems\n\n\n@app.get('/compliance/{aso_id}',\n         response_model=models.UNCompliance,\n         tags=['ARCADE Endpoints'])\nasync def get_compliance(aso_id: str,\n                         user: models.User = Depends(current_active_user)\n                         ) -> Optional[models.UNCompliance]:\n    \"\"\"Returns whether the ASO is compliant in registering with the United\n    Nations.\"\"\"\n    aso_node = graph.SpaceObject.find_one(aso_id=aso_id)\n    if not aso_node:\n        return None\n    compliance_nodes = aso_node.compliance.all()\n    if compliance_nodes:\n        compliance_node = compliance_nodes[0]\n    else:\n        return None\n    user_node = graph.User.find_one(uid=str(user.id))\n    if not user_node or not user_node.can_access(compliance_node):\n        return None\n    compliance = models.UNCompliance(aso_id=aso_id,\n                                     is_compliant=compliance_node.is_compliant)\n    user_node.accessed.connect(compliance_node, {'endpoint': '/compliance'})\n    return compliance\n"}
{"type": "source_file", "path": "arcade/importers/cos_oem/runner.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport time\nimport logging\nimport neomodel  # type: ignore\nimport arcade.models.cos as cos\nfrom arcade.importers.cos_oem.ut_oem import UTOEMCOSImporter\nfrom arcade.importers.cos_oem.starlink_oem import StarlinkOEMCOSImporter\n\n\nlogging.basicConfig(level=os.environ.get(\"LOGLEVEL\", \"INFO\"))\nlogger = logging.getLogger(__name__)\n\n\nif __name__ == '__main__':\n    cos_client = cos.build_cos_client()\n    bucket_name = os.environ['COS_BUCKET']\n    bucket = cos.IBMBucket(cos_client, bucket_name)\n    neomodel.config.DATABASE_URL = os.environ['NEO4J_URL']\n\n    ut_importer = UTOEMCOSImporter(bucket)\n    starlink_importer = StarlinkOEMCOSImporter(bucket)\n    importers = [ut_importer, starlink_importer]\n\n    logger.info('Starting all importers...')\n    while True:\n        for importer in importers:\n            importer.run()\n        logger.info('Importers Finished, sleeping 1 hour...')\n        time.sleep(3600)\n"}
{"type": "source_file", "path": "arcade/models/__init__.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"}
{"type": "source_file", "path": "arcade/importers/cos_oem/starlink_oem.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport io\nimport os\nimport logging\nimport zipfile\nfrom typing import List, IO, Tuple\nfrom datetime import datetime\nimport arcade.models.cos as cos\nimport arcade.models.graph as graph\nfrom arcade.importers.cos_oem.cos_oem import (BaseOEMCOSImporter,\n                                              OEMData, EphemerisLine)\n\nlogging.basicConfig(level=os.environ.get(\"LOGLEVEL\", \"INFO\"))\nlogger = logging.getLogger(__name__)\n\n\nclass StarlinkOEMCOSImporter(BaseOEMCOSImporter):\n    \"\"\"A class for fetching OEM data from the Starlink constellation in cloud\n    object storage and loading it into neo4j.\n\n    :param oem_bucket: The COS bucket where the OEM files are stored\n    \"\"\"\n    def __init__(self, oem_bucket: cos.COSBucket) -> None:\n        super().__init__(oem_bucket,\n                         data_source_name='Starlink - OEM',\n                         oem_file_fmt='[0-9]{20}.oem',\n                         data_source_public=True)\n\n    def _convert_header_time(self, time_str: str) -> str:\n        \"\"\"Converts the time strings in the header of the Starlink OEM files\n        into the standard format used in the graph.\n\n        :param time_str: The time string to conver\n        :return: The normalized time string\n        \"\"\"\n        input_time_fmt = '%Y-%m-%d %H:%M:%S %Z'\n        output_time_fmt = '%Y-%m-%dT%H:%M:%S'\n        dt_obj = datetime.strptime(time_str.strip(), input_time_fmt)\n        return dt_obj.strftime(output_time_fmt)\n\n    def _convert_ephem_time(self, time_str: str) -> str:\n        \"\"\"Converts the epoch time strings in the ephemeris lines of the\n        Starlink OEM files into the standard format used in the graph.\n\n        :param time_str: The time string to conver\n        :return: The normalized time string\n        \"\"\"\n        input_time_fmt = '%Y%j%H%M%S.%f'\n        output_time_fmt = '%Y-%m-%dT%H:%M:%S.%f'\n        dt_obj = datetime.strptime(time_str.strip(), input_time_fmt)\n        return dt_obj.strftime(output_time_fmt)\n\n    def _parse_oem_data(self,\n                        zip_file: zipfile.ZipFile,\n                        oem_file_name: str) -> OEMData:\n        \"\"\"Parses the OEM data in text file contained in the passed zip\n        archive.\n\n        :param zip_file: The zip archive containing the OEM text files\n        :param oem_file_name: The text file in the zip archive to parse\n\n        return: The parsed OEM data\n        \"\"\"\n        ephemeris_lines: List[EphemerisLine] = []\n        # Message data not contained in the OEM files\n        oem_data: OEMData = {\n            'originator': 'Starlink',\n            'center_name': 'EARTH',\n            'ref_frame': 'EME2000',\n            'time_system': 'UTC'\n        }\n        with io.TextIOWrapper(zip_file.open(oem_file_name),\n                              encoding='utf8') as oem_file:\n            for line_no, line in enumerate(oem_file):\n                if len(line.strip()) == 0:\n                    break\n                # Header information is on the first 2 lines of the file\n                if line_no == 0:\n                    ts = line[8:]\n                    oem_data['creation_date'] = self._convert_header_time(ts)\n                elif line_no == 1:\n                    start = line[16:39]\n                    stop = line[55:78]\n                    oem_data['start_time'] = self._convert_header_time(start)\n                    oem_data['stop_time'] = self._convert_header_time(stop)\n                else:\n                    # The state vectors are on every 4th line\n                    if not line_no % 4 == 0:\n                        continue\n                    ephem_data = line.split(' ')\n                    epoch = self._convert_ephem_time(ephem_data[0])\n                    state_vector = [float(s) for s in ephem_data[1:]]\n                    ephemeris_line: EphemerisLine\n                    ephemeris_line = dict(epoch=epoch,\n                                          state_vector=state_vector)\n                    ephemeris_lines.append(ephemeris_line)\n            oem_data['ephemeris_lines'] = ephemeris_lines\n        return oem_data\n\n    def _get_aso_id_name(self, file_name: str) -> Tuple[str, str]:\n        \"\"\"Gets the Starlink satellite's name and NORAD ID from the text\n        file name.\n\n        :param file_name: The name of the text file containing the OEM data\n        :return: The NORAD ID and name of the satellite\n        \"\"\"\n        data_parts = file_name.split('_')\n        aso_id = data_parts[1]\n        object_name = data_parts[2]\n        return aso_id, object_name\n\n    def _process_fileobj(self,\n                         fileobj: IO[bytes],\n                         object_node: graph.COSObject) -> None:\n        \"\"\"Extracts and parses the OEM data from the given tar archive file.\n\n        :param tar_file_obj: The file object of the tar archive to extract OEM\n            data out of\n       :param object_node: The node in the graph representing the COS object\n           the OEM is stored in\n        \"\"\"\n        with zipfile.ZipFile(fileobj) as zip_file:\n            txt_file_names = [f for f in zip_file.namelist()\n                              if f.endswith('.txt')]\n            for txt_file_name in txt_file_names:\n                oem_data = self._parse_oem_data(zip_file, txt_file_name)\n                aso_id, object_name = self._get_aso_id_name(txt_file_name)\n                oem_data['object_name'] = object_name\n                self._save_oem(oem_data, aso_id, object_node)\n"}
{"type": "source_file", "path": "arcade/importers/cos_oem/ut_oem.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport gzip\nimport logging\nimport tarfile\nfrom typing import List, IO\nimport arcade.models.cos as cos\nimport arcade.models.graph as graph\nfrom arcade.importers.cos_oem.cos_oem import (BaseOEMCOSImporter,\n                                              OEMData, EphemerisLine)\n\nlogging.basicConfig(level=os.environ.get(\"LOGLEVEL\", \"INFO\"))\nlogger = logging.getLogger(__name__)\n\n\nclass UTOEMCOSImporter(BaseOEMCOSImporter):\n    \"\"\"A class for fetching OEM data from UT in cloud object storage and\n    loading it into neo4j.\n\n    :param oem_bucket: The COS bucket where the OEM files are stored\n    \"\"\"\n    def __init__(self, oem_bucket: cos.COSBucket) -> None:\n        super().__init__(oem_bucket,\n                         data_source_name='UT - OEM',\n                         oem_file_fmt='[0-9]{8}_block_[0-9]{2}.tar',\n                         data_source_public=True)\n\n    def _parse_oem_data(self, gz_file_obj: IO[bytes]) -> OEMData:\n        \"\"\"Parses the OEM data from the passed gzip file.  Assumes there is\n        only one ASO in each file.\n\n        :param gz_file_obj: The file object for the gziped file.\n        :return: The parsed OEM data\n        \"\"\"\n        with gzip.open(gz_file_obj, 'r') as gz_file:\n            ephemeris_lines: List[EphemerisLine] = []\n            oem_data: OEMData = dict()\n            # First section of the file is a header section.\n            section = 'header'\n            for raw_line in gz_file:\n                line = raw_line.decode('utf-8').strip()\n                # Skip blank or comment lines\n                if len(line) == 0 or line.startswith('COMMENT'):\n                    continue\n                # Parses a line that has a property and corresponding value\n                elif '=' in line:\n                    k, v = [s.strip() for s in line.split('=')]\n                    oem_data[k.lower()] = v\n                # Start parsing the metadata section\n                elif line.startswith('META_START'):\n                    section = 'meta'\n                # The metadata is done, start parsing the ephemeris lines\n                elif line.startswith('META_STOP'):\n                    section = 'ephemeris'\n                elif section == 'ephemeris':\n                    line_data = line.split(' ')\n                    epoch = line_data[0]\n                    state_vector = [float(s) for s in line_data[1:]]\n                    ephemeris_line: EphemerisLine\n                    ephemeris_line = dict(epoch=epoch,\n                                          state_vector=state_vector)\n                    ephemeris_lines.append(ephemeris_line)\n                    if epoch == oem_data['stop_time']:\n                        section = 'covariance'\n                # Currently we are not doing anything with the covariance data\n                # and so we stop the parsing\n                elif section == 'covariance':\n                    break\n        oem_data['ephemeris_lines'] = ephemeris_lines\n        return oem_data\n\n    def _get_aso_id_from_file_name(self, filename: str) -> str:\n        \"\"\"Extracts the ASO ID from the OEM gzip file name.\n\n        :param filename: The OEM gzip file name\n        :return: The ASO ID of the object referenced in the OEM file\n        \"\"\"\n        id_parts = filename.split('/')\n        prefix = id_parts[1]\n        suffix = id_parts[-1].split('.')[0].zfill(3)\n        if len(suffix) == 5:\n            return suffix\n        else:\n            return prefix + suffix\n\n    def _process_fileobj(self,\n                         tar_file_obj: IO[bytes],\n                         object_node: graph.COSObject) -> None:\n        \"\"\"Extracts and parses the OEM data from the given tar archive file.\n\n        :param tar_file_obj: The file object of the tar archive to extract OEM\n            data out of\n       :param object_node: The node in the graph representing the COS object\n           the OEM is stored in\n        \"\"\"\n        with tarfile.open(fileobj=tar_file_obj) as tar_file:\n            gz_file_names = [f.name for f in tar_file.getmembers()\n                             if f.name.endswith('.gz')]\n            for gz_file_name in gz_file_names:\n                gz_file_obj = tar_file.extractfile(gz_file_name)\n                if gz_file_obj:\n                    oem_data = self._parse_oem_data(gz_file_obj)\n                    aso_id = self._get_aso_id_from_file_name(gz_file_name)\n                    self._save_oem(oem_data, aso_id, object_node)\n"}
{"type": "source_file", "path": "arcade/importers/un_compliance.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport csv\nimport logging\nimport neomodel  # type: ignore\nimport pandas as pd  # type: ignore\nimport arcade.models.graph as graph\n\n\nlogging.basicConfig(level=os.environ.get(\"LOGLEVEL\", \"INFO\"))\nlogger = logging.getLogger(__name__)\n\n\ndef export_compliance_data(astria_graph: neomodel.db, out_path: str) -> None:\n    \"\"\"Exports UN compliance data from ASTRIAGraph into a CSV file\n    :param astria_graph: The database connection to ASTRIAGraph\n    :param out_path: The path to save the CSV file to\n    \"\"\"\n    query = ('MATCH (c:Compliance)'\n             '<-[:SpaceObjectInstance2Compliance]-'\n             '(so:SpaceObjectInstance) '\n             'RETURN so.NoradId, c.calcTime, c.isCompliant')\n    results, _ = astria_graph.cypher_query(query)\n    result_columns = ['aso_id', 'calc_time', 'is_compliant']\n    df = pd.DataFrame(data=results, columns=result_columns)\n    # Get the most recently calculated compliance for each ASO\n    latest_calc_time = df.groupby('aso_id').max('calc_time').reset_index()\n    latest_calc_time.to_csv(out_path, index=False)\n\n\nclass UNComplianceImporter:\n    \"\"\"A class for importing UN compliance from ASTRIAGraph into the ARCADE\n    neo4j database\n\n    :param import_csv_path: The compliance CSV file exported from ASTRIAGraph\n    \"\"\"\n    def __init__(self, import_csv_path: str) -> None:\n        self.import_csv_path = import_csv_path\n        self.data_source_node = graph.DataSource.get_or_create(\n            {\n                'name': 'UN - Compliance',\n                'public': True\n            }\n        )[0]\n\n    def run(self) -> None:\n        \"\"\"Imports the UN compliance data from the CSV file\"\"\"\n        with open(self.import_csv_path) as csv_file:\n            csv_reader = csv.DictReader(csv_file)\n            for row in csv_reader:\n                aso_node = graph.SpaceObject.find_one(norad_id=row['aso_id'])\n                if aso_node is None:\n                    continue\n                is_compliant = row['is_compliant'] == 'True'\n                compliance_nodes = aso_node.compliance.all()\n                if compliance_nodes:\n                    compliance_node = compliance_nodes[0]\n                    compliance_node.is_compliant = is_compliant\n                    compliance_node.save()\n                else:\n                    compliance_node = graph.Compliance(\n                        is_compliant=is_compliant\n                    )\n                    compliance_node.save()\n                    aso_node.compliance.connect(compliance_node)\n                    compliance_node.from_data_source.connect(\n                        self.data_source_node\n                    )\n\n\nif __name__ == '__main__':\n    neomodel.config.DATABASE_URL = os.environ['NEO4J_URL']\n    importer = UNComplianceImporter(os.environ['COMPLIANCE_CSV_PATH'])\n    logger.info('Importing UN compliance data...')\n    importer.run()\n    logger.info('Finished importing UN compliance data...')\n"}
{"type": "source_file", "path": "arcade/models/api.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import annotations\nfrom typing import List, Dict, Optional\n\nfrom orbdetpy import Frame  # type: ignore\nfrom orbdetpy.utilities import interpolate_ephemeris  # type: ignore\nimport orbdetpy.conversion as conv  # type: ignore\n\nfrom pydantic import BaseModel, validator\nfrom fastapi_users import models as user_models\n\n\nclass User(user_models.BaseUser):\n    \"\"\"A `pydantic` model representing an API user.\"\"\"\n    pass\n\n\nclass UserCreate(user_models.BaseUserCreate):\n    \"\"\"A `pydantic` model representing the data needed to create a User.\"\"\"\n    pass\n\n\nclass UserUpdate(User, user_models.BaseUserUpdate):\n    \"\"\"A `pydantic` model representing the data needed to update a User.\"\"\"\n    pass\n\n\nclass UserDB(User, user_models.BaseUserDB):\n    \"\"\"A `pydantic` model representing how the user is stored in\n    the database.\"\"\"\n    pass\n\n\nclass UserReport(BaseModel):\n    \"\"\"A `pydantic` model representing a report of a user's usage of the\n    ARCADE API.\"\"\"\n    email: str\n    access_count: int\n\n\nclass ASO(BaseModel):\n    \"\"\"A `pydantic` model representing an anthropogenic space object (ASO).\"\"\"\n    aso_id: str\n    norad_id: str\n    cospar_id: Optional[str] = None\n    name: str\n\n    class Config:\n        orm_mode = True\n\n\nclass EphemerisLine(BaseModel):\n    \"\"\"A `pydantic` model for a single line of ephemeris data including the epoch\n    and 6-dimensional state vector.\"\"\"\n    epoch: str\n    state_vector: List[float]\n\n    @validator('state_vector')\n    def validate_state_vect(cls, val: List[float]) -> List[float]:\n        \"\"\"Validates that the state vector has six components.\"\"\"\n        if len(val) != 6:\n            raise ValueError('State vector must be 6-dimensional')\n        else:\n            return val\n\n\nclass OrbitEphemerisMessage(BaseModel):\n    \"\"\"A `pydantic` model representing the ephemeris data extracted from an OEM\n    file for a single ASO.\"\"\"\n    ephemeris_lines: List[EphemerisLine]\n    ccsds_oem_vers: Optional[str] = None\n    creation_date: str\n    originator: str\n    object_name: str\n    object_id: Optional[str] = None\n    center_name: str\n    ref_frame: str\n    time_system: str\n    start_time: str\n    stop_time: str\n\n    class Config:\n        orm_mode = True\n\n    @validator('ref_frame')\n    def validate_frame(cls, val: str) -> str:\n        \"\"\"Validates that the reference frame is one that `orbdetpy`\n        knows about.\"\"\"\n        frame_map: Dict[str, str]\n        frame_map = {\n            'EME2000': Frame.EME2000,\n            'GCRF': Frame.GCRF,\n            'ICRF': Frame.ICRF,\n            'ITRF2000': Frame.ITRF_CIO_CONV_2003_ACCURATE_EOP,\n            'ITRF-93': Frame.ITRF_CIO_CONV_1996_ACCURATE_EOP,\n            'ITRF-97': Frame.ITRF_CIO_CONV_1996_ACCURATE_EOP,\n            'TEME': Frame.TEME,\n            'TOD': Frame.TOD_CONVENTIONS_2010_ACCURATE_EOP\n        }\n        if val not in frame_map:\n            raise ValueError('Unknown reference frame')\n        return frame_map[val]\n\n    def interpolate(self,\n                    step_size: float,\n                    num_points: int = 5) -> OrbitEphemerisMessage:\n        \"\"\"Interpolates the ephemeris data to the desired time step size.\n\n        :param step_size: The interpolated step size in seconds.\n        :param num_points: The number of states to use for interpolation.\n        \"\"\"\n        epochs, state_vects = [], []\n        for emph_line in self.ephemeris_lines:\n            epochs.append(emph_line.epoch)\n            # Convert components from m and m\\s to km and km\\s\n            state_vect = [i*1000.0 for i in emph_line.state_vector]\n            state_vects.append(state_vect)\n        offset_epochs = conv.get_J2000_epoch_offset(epochs)\n        interpolation = interpolate_ephemeris(self.ref_frame,\n                                              offset_epochs,\n                                              state_vects,\n                                              num_points,\n                                              self.ref_frame,\n                                              offset_epochs[0],\n                                              offset_epochs[-1],\n                                              step_size)\n        interp_ephem_lines = []\n        for proto_buf in interpolation:\n            epoch = conv.get_UTC_string(proto_buf.time)\n            state_vector = [i/1000.0 for i in list(proto_buf.true_state)]\n            interp_ephem_line = EphemerisLine(epoch=epoch,\n                                              state_vector=state_vector)\n            interp_ephem_lines.append(interp_ephem_line)\n        interp_oem_data = self.copy()\n        interp_oem_data.ephemeris_lines = interp_ephem_lines\n        return interp_oem_data\n\n\nclass UNCompliance(BaseModel):\n    \"\"\"A `pydantic` model representing an ASO's UN registration compliance\"\"\"\n    aso_id: str\n    is_compliant: bool\n"}
{"type": "source_file", "path": "arcade/models/cos.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport io\nimport os\nfrom typing import List, IO, Optional\nimport ibm_boto3  # type: ignore\nfrom ibm_botocore.client import Config  # type: ignore\nfrom ibm_boto3.resources.base import ServiceResource  # type: ignore\n\n\ndef build_cos_client() -> ServiceResource:\n    \"\"\"Uses environment variables to build a COS client.\"\"\"\n    cos_endpoint = os.environ.get('COS_ENDPOINT')\n    cos_api_key_id = os.environ.get('COS_API_KEY_ID')\n    cos_instance_crn = os.environ.get('COS_INSTANCE_CRN')\n    cos_client = ibm_boto3.resource('s3',\n                                    ibm_api_key_id=cos_api_key_id,\n                                    ibm_service_instance_id=cos_instance_crn,\n                                    config=Config(signature_version='oauth'),\n                                    endpoint_url=cos_endpoint)\n    return cos_client\n\n\nclass COSBucket:\n    def __init__(self, name: str) -> None:\n        self.name = name\n\n    \"\"\"The protocol that COS buckets need to implement.\"\"\"\n    def list_file_names(self) -> List[str]:\n        \"\"\"Lists all the file names in the bucket.\"\"\"\n        raise NotImplementedError\n\n    def download_fileobj(self, file_name: str) -> Optional[IO[bytes]]:\n        \"\"\"Downloads the contents of the given object in the bucket.\"\"\"\n        raise NotImplementedError\n\n\nclass IBMBucket(COSBucket):\n    \"\"\"A bucket abstraction around IBM's cloud object storage.\"\"\"\n    def __init__(self, cos_client: ServiceResource, bucket_name: str):\n        super().__init__(bucket_name)\n        self.cos_client = cos_client\n\n    def list_file_names(self) -> List[str]:\n        try:\n            bucket = self.cos_client.Bucket(self.name)\n            files = bucket.objects.all()\n            file_names = [f.key for f in files]\n            return file_names\n        except Exception:\n            return []\n\n    def download_fileobj(self, file_name: str) -> Optional[IO[bytes]]:\n        try:\n            cos_object = self.cos_client.Object(self.name, file_name).get()\n            obj_bytes = cos_object['Body'].read()\n            file_obj = io.BytesIO(obj_bytes)\n            return file_obj\n        except Exception:\n            return None\n\n\nclass FileSystemBucket(COSBucket):\n    \"\"\"A bucket that uses local file system data.\"\"\"\n\n    def __init__(self, bucket_name: str,\n                 data_path: str = '/arcade/tests/test_data/oem') -> None:\n        super().__init__(bucket_name)\n        self.data_path = data_path\n\n    def list_file_names(self) -> List[str]:\n        try:\n            return os.listdir(self.data_path)\n        except Exception:\n            return []\n\n    def download_fileobj(self, file_name: str) -> Optional[IO[bytes]]:\n        file_path = f'{self.data_path}/{file_name}'\n        try:\n            with open(file_path, 'rb') as f:\n                obj_bytes = f.read()\n                file_obj = io.BytesIO(obj_bytes)\n                return file_obj\n        except Exception:\n            return None\n"}
{"type": "source_file", "path": "arcade/models/graph.py", "content": "# Copyright 2020 IBM Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import annotations\nfrom collections import defaultdict\nfrom typing import Optional, TypeVar, Type, Dict, Union, List\n\nfrom aioify import aioify  # type: ignore\n\nfrom neomodel import (StringProperty, EmailProperty,  # type: ignore\n                      JSONProperty, BooleanProperty, UniqueIdProperty,\n                      DateTimeProperty)\nfrom neomodel import (StructuredNode, RelationshipTo, RelationshipFrom,\n                      StructuredRel)\n\nfrom pydantic import UUID4\nfrom fastapi_users.models import UD\nfrom fastapi_users.db.base import BaseUserDatabase\n\n\nNodeType = TypeVar('NodeType', bound='StructuredNode')\n\n\nclass FindMixin:\n    \"\"\"A mixin that provides convenient functions for finding instances\n    of nodes in the graph.\"\"\"\n    @classmethod\n    def find_one(cls: Type[NodeType], **kwargs: str) -> Optional[NodeType]:\n        \"\"\"Finds the first node of type `cls` matching the `kwargs`.\n        Returns `None` if no node is matched.\"\"\"\n        node: NodeType = cls.nodes.first_or_none(**kwargs)\n        return node\n\n\nclass FastAPIUserDBAdapter(BaseUserDatabase[UD]):\n    \"\"\"A database adapter that allows the `fastapi_users` library to use neo4j\n    as a backend.\n\n    :param user_db_model: The pydantic model representing how a user is stored\n        in the database\n    \"\"\"\n    def __init__(self, user_db_model: Type[UD]):\n        super().__init__(user_db_model)\n\n    @aioify\n    def get(self, uid: UUID4) -> Optional[UD]:\n        \"\"\"Retrieves a user node by its unique ID, returns `None` if no user is\n        found for the provided UUID.\n\n        :param uid: The unique ID for the user node\n        \"\"\"\n        user = User.find_one(uid=str(uid))\n        if user:\n            return self.user_db_model(**user.to_dict())\n        else:\n            return None\n\n    @aioify\n    def get_by_email(self, email: str) -> Optional[UD]:\n        \"\"\"Retrieves a user node by its email address, returns `None` if no\n        user is found for the provided email.\n\n        :param email: The email address of the user node\n        \"\"\"\n        user = User.find_one(email=email)\n        if user:\n            return self.user_db_model(**user.to_dict())\n        else:\n            return None\n\n    @aioify\n    def create(self, user: UD) -> UD:\n        \"\"\"Creates a user node using the data in the pydantic model.\n\n        :param user: pydantic model containing the user's data\n        \"\"\"\n        user_dict = user.dict()\n        # The fastapi_users library requires that the database record use the\n        # `id` property for the user's UUID, however neo4j internally uses the\n        # `id` property as an incrementing integer.  Here we store the\n        # fastapi_users UUID as the `uid` property and remove the `id` field\n        # before storing in neo4j.\n        user_dict['uid'] = user_dict.pop('id')\n        User(**user_dict).save()\n        return user\n\n    @aioify\n    def update(self, user: UD) -> UD:\n        \"\"\"Updates a user node with the data in the provided pydantic model\n\n        :param user: pydantic model containing the user's data\n        \"\"\"\n        user = User.create_or_update(user.dict())\n        return user\n\n    @aioify\n    def delete(self, user: UD) -> None:\n        \"\"\"Deletes a user node from the graph.\n\n        :param user: pydantic model containing the user's data\n        \"\"\"\n        user_node = User.find_one(uid=str(user.id))\n        if user_node:\n            user_node.delete()\n\n\nclass AccessRel(StructuredRel):  # type: ignore\n    \"\"\"The relationship that models when and what data a user accessed through\n    the API.\n    (User)-[:accessed]->(BaseAccess)\n    \"\"\"\n    # The timestamp when the user accessed the data\n    time = DateTimeProperty(default_now=True)\n    # The API endpoint the user used to access the data\n    endpoint = StringProperty(required=True)\n\n\nclass BaseAccess(StructuredNode):  # type: ignore\n    \"\"\"An abstract node type the keeps track of when a user accessed a certain\n    node.  All node types that want user access tracked should inherit from\n    this class.\"\"\"\n    __abstract_node__ = True\n    from_data_source = RelationshipTo('DataSource', 'from_data_source')\n    accessed_by = RelationshipFrom('User', 'accessed', model=AccessRel)\n\n    def get_data_source_node(self) -> DataSource:\n        data_sources: List[DataSource] = self.from_data_source.all()\n        return data_sources[0]\n\n\nclass User(StructuredNode, FindMixin):  # type: ignore\n    \"\"\"A `neomodel` model specifying how a user is stored in neo4j.\"\"\"\n    uid = UniqueIdProperty()\n    email = EmailProperty(unique_index=True, required=True)\n    hashed_password = StringProperty(required=True)\n    is_active = BooleanProperty()\n    is_verified = BooleanProperty()\n    is_superuser = BooleanProperty()\n\n    data_sources = RelationshipTo('DataSource', 'has_access')\n    accessed = RelationshipTo('BaseAccess',\n                              'accessed',\n                              model=AccessRel)\n\n    def post_create(self) -> None:\n        \"\"\"Hook that is run after a user node is created\"\"\"\n        self._add_public_data_sources()\n\n    def _add_public_data_sources(self) -> None:\n        \"\"\"Links the user node to have access to all public data source\n        nodes\"\"\"\n        public_data_sources = DataSource.nodes.filter(public=True)\n        for pds in public_data_sources:\n            self.data_sources.connect(pds)\n\n    def to_dict(self) -> Dict[str, Union[str, bool]]:\n        \"\"\"Converts the user node to a dictionary representation and renames\n        the `uid` key to the `id` key so that the resulting dict can be\n        converted to a fastapi_users pydantic user model.\"\"\"\n        d = self.__dict__.copy()\n        d['id'] = d.pop('uid')\n        return d\n\n    def can_access(self, node: BaseAccess) -> bool:\n        \"\"\"Uses the `has_access` relationship to determine if the user has\n        permission to access data from a specific data source.\n\n        :param node: The node instance that the user wants to access\n        \"\"\"\n        node_source = node.get_data_source_node()\n        user_sources = self.data_sources.all()\n        # Checks that the data source the `node` came from is one in which the\n        # user has access to\n        return node_source in user_sources\n\n\nclass DataSource(StructuredNode):  # type: ignore\n    \"\"\"A `neomodel` model representing a data source that data\n    originates from.\"\"\"\n    name = StringProperty(unique_index=True, required=True)\n    public = BooleanProperty()\n\n    def post_create(self) -> None:\n        \"\"\"Hook that is run after a data source node is created\"\"\"\n        if self.public:\n            self._make_public()\n\n    def _make_public(self) -> None:\n        \"\"\"Links the `has_access` relationship to all users in the graph\"\"\"\n        for user_node in User.nodes.all():\n            user_node.data_sources.connect(self)\n\n\nclass COSBucket(StructuredNode):  # type: ignore\n    \"\"\"A `neomodel` model representing a cloud object storage bucket used in\n    tracking data provenance.\"\"\"\n    name = StringProperty(unique_index=True, required=True)\n\n    objects = RelationshipFrom('COSObject', 'in_bucket')\n\n\nclass COSObject(StructuredNode):  # type: ignore\n    \"\"\"A `neomodel` model representing an object inside of a cloud object\n    storage bucket used in tracking data provenance.\"\"\"\n    name = StringProperty(unique_index=True, required=True)\n    imported = BooleanProperty()\n\n    bucket = RelationshipTo('COSBucket', 'in_bucket')\n\n\nclass SpaceObject(StructuredNode, FindMixin):  # type: ignore\n    \"\"\"A `neomodel` model representing an anthropogenic space object.\"\"\"\n    aso_id = StringProperty(unique_index=True, required=True)\n    norad_id = StringProperty(unique_index=True, required=True)\n    cospar_id = StringProperty()\n    name = StringProperty()\n\n    ephemeris_messages = RelationshipTo('OrbitEphemerisMessage', 'has_oem')\n    compliance = RelationshipTo('Compliance', 'has_compliance')\n\n    @classmethod\n    def get_latest_oems(cls, aso_id: str) -> List[OrbitEphemerisMessage]:\n        \"\"\"Gets the most recent orbit ephemeris messages for an ASO\n\n        :param aso_id: The ID of the ASO to find the most recent OEM for\n        \"\"\"\n        aso_node = cls.find_one(aso_id=aso_id)\n        if aso_node is None:\n            return []\n        oems_by_source = defaultdict(list)\n        for oem in aso_node.ephemeris_messages.all():\n            source = oem.get_data_source_node()\n            oems_by_source[source.name].append(oem)\n\n        latest_oems = []\n        for source_oems in oems_by_source.values():\n            sorted_oems = sorted(source_oems,\n                                 key=lambda o: o.object_name,  # type: ignore\n                                 reverse=True)\n            latest_oems.append(sorted_oems[0])\n\n        return latest_oems\n\n\nclass OrbitEphemerisMessage(BaseAccess):\n    \"\"\"A `neomodel` model representing an orbit ephemeris message. \"\"\"\n    ephemeris_lines = JSONProperty()\n    ccsds_oem_vers = StringProperty()\n    creation_date = StringProperty()\n    originator = StringProperty()\n    object_name = StringProperty()\n    object_id = StringProperty()\n    center_name = StringProperty()\n    ref_frame = StringProperty()\n    time_system = StringProperty()\n    start_time = StringProperty()\n    stop_time = StringProperty()\n\n    in_cos_object = RelationshipTo('COSObject', 'stored_in')\n\n\nclass Compliance(BaseAccess):\n    \"\"\"A `neomodel` model representing whether an ASO is compliant with the\n    UN's registration requirements. \"\"\"\n    is_compliant = BooleanProperty(required=True)\n"}
